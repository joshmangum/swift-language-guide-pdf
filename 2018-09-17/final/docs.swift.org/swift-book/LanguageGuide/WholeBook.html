
<!DOCTYPE html>

<head>
<meta charset="utf-8"/>
<meta content="Apple Inc." name="author"/>
<meta content="width=device-width initial-scale=1" name="viewport"/>
<title>The Basics — The Swift Programming Language (Swift 4.2)</title>
<link href="https://docs.swift.org/LICENSE.txt" rel="license"/>
<link href="../_static/stylesheets/application.css" media="all" rel="stylesheet"/>
<link href="../_static/stylesheets/tspl.css" media="all" rel="stylesheet"/>
<link href="../../favicon.ico" rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon"/>
<link href="https://docs.swift.org/apple-touch-icon.png" rel="apple-touch-icon"/>
<link href="https://docs.swift.org/apple-touch-icon-57x57.png" rel="apple-touch-icon" sizes="57x57"/>
<link href="https://docs.swift.org/apple-touch-icon-72x72.png" rel="apple-touch-icon" sizes="72x72"/>
<link href="https://docs.swift.org/apple-touch-icon-76x76.png" rel="apple-touch-icon" sizes="76x76"/>
<link href="https://docs.swift.org/apple-touch-icon-114x114.png" rel="apple-touch-icon" sizes="114x114"/>
<link href="https://docs.swift.org/apple-touch-icon-120x120.png" rel="apple-touch-icon" sizes="120x120"/>
<link href="https://docs.swift.org/apple-touch-icon-144x144.png" rel="apple-touch-icon" sizes="144x144"/>
<link href="https://docs.swift.org/apple-touch-icon-152x152.png" rel="apple-touch-icon" sizes="152x152"/>
<link href="https://docs.swift.org/apple-touch-icon-180x180.png" rel="apple-touch-icon" sizes="180x180"/>
<link color="#F05339" href="https://docs.swift.org/assets/images/icon-swift.svg" rel="mask-icon"/>
</head>
<body>
<nav role="navigation">
<header role="banner">
<h1 id="logo">
<a aria-label="Swift.org" href="https://swift.org/" role="img" title="Swift.org">
          Swift.org
        </a>
</h1>
</header>
<div class="menu-toggle open" id="menu-toggle"></div>
<h2>The Swift Programming Language<div>Swift 4.2</div></h2>
<ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to Swift</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html">Language Guide</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="TheBasics.html#">The Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html">Basic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html">Strings and Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html">Collection Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html">Control Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html">Closures</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html">Enumerations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html">Structures and Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html">Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html">Subscripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html">Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html">Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html">Deinitialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html">Optional Chaining</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html">Type Casting</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html">Nested Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html">Extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html">Automatic Reference Counting</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html">Memory Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html">Advanced Operators</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html">Language Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html">Revision History</a></li>
</ul>
<li class="toctree-l1 return"><a class="reference internal" href="https://swift.org/">← Return to Swift.org</a></li>
</ul>
</nav>
<main role="main">
<article class="page">
<menu id="bashful" type="toolbar">
<div class="inner">
<menuitem class="menu-bar-item closed" id="jump_to"/>
<span id="jump_to_toggle">On This Page</span>
<div class="chevron">
<div class="chevy chevron-left"></div>
<div class="chevy chevron-right"></div>
</div>
<menu class="details" type="list">
<ul>
<li><a class="reference internal" href="TheBasics.html#">The Basics</a><ul>
<li><a class="reference internal" href="TheBasics.html#ID310">Constants and Variables</a><ul>
<li><a class="reference internal" href="TheBasics.html#ID311">Declaring Constants and Variables</a></li>
<li><a class="reference internal" href="TheBasics.html#ID312">Type Annotations</a></li>
<li><a class="reference internal" href="TheBasics.html#ID313">Naming Constants and Variables</a></li>
<li><a class="reference internal" href="TheBasics.html#ID314">Printing Constants and Variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="TheBasics.html#ID315">Comments</a></li>
<li><a class="reference internal" href="TheBasics.html#ID316">Semicolons</a></li>
<li><a class="reference internal" href="TheBasics.html#ID317">Integers</a><ul>
<li><a class="reference internal" href="TheBasics.html#ID318">Integer Bounds</a></li>
<li><a class="reference internal" href="TheBasics.html#ID319">Int</a></li>
<li><a class="reference internal" href="TheBasics.html#ID320">UInt</a></li>
</ul>
</li>
<li><a class="reference internal" href="TheBasics.html#ID321">Floating-Point Numbers</a></li>
<li><a class="reference internal" href="TheBasics.html#ID322">Type Safety and Type Inference</a></li>
<li><a class="reference internal" href="TheBasics.html#ID323">Numeric Literals</a></li>
<li><a class="reference internal" href="TheBasics.html#ID324">Numeric Type Conversion</a><ul>
<li><a class="reference internal" href="TheBasics.html#ID325">Integer Conversion</a></li>
<li><a class="reference internal" href="TheBasics.html#ID326">Integer and Floating-Point Conversion</a></li>
</ul>
</li>
<li><a class="reference internal" href="TheBasics.html#ID327">Type Aliases</a></li>
<li><a class="reference internal" href="TheBasics.html#ID328">Booleans</a></li>
<li><a class="reference internal" href="TheBasics.html#ID329">Tuples</a></li>
<li><a class="reference internal" href="TheBasics.html#ID330">Optionals</a><ul>
<li><a class="reference internal" href="TheBasics.html#ID331">nil</a></li>
<li><a class="reference internal" href="TheBasics.html#ID332">If Statements and Forced Unwrapping</a></li>
<li><a class="reference internal" href="TheBasics.html#ID333">Optional Binding</a></li>
<li><a class="reference internal" href="TheBasics.html#ID334">Implicitly Unwrapped Optionals</a></li>
</ul>
</li>
<li><a class="reference internal" href="TheBasics.html#ID515">Error Handling</a></li>
<li><a class="reference internal" href="TheBasics.html#ID335">Assertions and Preconditions</a><ul>
<li><a class="reference internal" href="TheBasics.html#ID336">Debugging with Assertions</a></li>
<li><a class="reference internal" href="TheBasics.html#ID554">Enforcing Preconditions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</menu>
</div>
</menu>

<div class="section" id="the-basics">
<h1>The Basics<a class="headerlink" href="TheBasics.html#the-basics" title="Permalink to this headline">¶</a></h1>
<p>Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C.</p>
<p>Swift provides its own versions of all fundamental C and Objective-C types, including <code class="docutils literal notranslate"><span class="pre">Int</span></code> for integers, <code class="docutils literal notranslate"><span class="pre">Double</span></code> and <code class="docutils literal notranslate"><span class="pre">Float</span></code> for floating-point values, <code class="docutils literal notranslate"><span class="pre">Bool</span></code> for Boolean values, and <code class="docutils literal notranslate"><span class="pre">String</span></code> for textual data. Swift also provides powerful versions of the three primary collection types, <code class="docutils literal notranslate"><span class="pre">Array</span></code>, <code class="docutils literal notranslate"><span class="pre">Set</span></code>, and <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>, as described in <a class="reference internal" href="CollectionTypes.html"><span class="doc">Collection Types</span></a>.</p>
<p>Like C, Swift uses variables to store and refer to values by an identifying name. Swift also makes extensive use of variables whose values can’t be changed. These are known as constants, and are much more powerful than constants in C. Constants are used throughout Swift to make code safer and clearer in intent when you work with values that don’t need to change.</p>
<p>In addition to familiar types, Swift introduces advanced types not found in Objective-C, such as tuples. Tuples enable you to create and pass around groupings of values. You can use a tuple to return multiple values from a function as a single compound value.</p>
<p>Swift also introduces optional types, which handle the absence of a value. Optionals say either “there <em>is</em> a value, and it equals <em>x</em>” or “there <em>isn’t</em> a value at all”. Using optionals is similar to using <code class="docutils literal notranslate"><span class="pre">nil</span></code> with pointers in Objective-C, but they work for any type, not just classes. Not only are optionals safer and more expressive than <code class="docutils literal notranslate"><span class="pre">nil</span></code> pointers in Objective-C, they’re at the heart of many of Swift’s most powerful features.</p>
<p>Swift is a <em>type-safe</em> language, which means the language helps you to be clear about the types of values your code can work with. If part of your code requires a <code class="docutils literal notranslate"><span class="pre">String</span></code>, type safety prevents you from passing it an <code class="docutils literal notranslate"><span class="pre">Int</span></code> by mistake. Likewise, type safety prevents you from accidentally passing an optional <code class="docutils literal notranslate"><span class="pre">String</span></code> to a piece of code that requires a nonoptional <code class="docutils literal notranslate"><span class="pre">String</span></code>. Type safety helps you catch and fix errors as early as possible in the development process.</p>
<div class="section" id="ID310">
<h2>Constants and Variables<a class="headerlink" href="TheBasics.html#ID310" title="Permalink to this headline">¶</a></h2>
<p>Constants and variables associate a name (such as <code class="docutils literal notranslate"><span class="pre">maximumNumberOfLoginAttempts</span></code> or <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code>) with a value of a particular type (such as the number <code class="docutils literal notranslate"><span class="pre">10</span></code> or the string <code class="docutils literal notranslate"><span class="pre">"Hello"</span></code>). The value of a <em>constant</em> can’t be changed once it’s set, whereas a <em>variable</em> can be set to a different value in the future.</p>
<div class="section" id="ID311">
<h3>Declaring Constants and Variables<a class="headerlink" href="TheBasics.html#ID311" title="Permalink to this headline">¶</a></h3>
<p>Constants and variables must be declared before they’re used. You declare constants with the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword and variables with the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword. Here’s an example of how constants and variables can be used to track the number of login attempts a user has made:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">maximumNumberOfLoginAttempts</span> = <span class="m">10</span>
</li><li><span class="k">var</span> <span class="nv">currentLoginAttempt</span> = <span class="m">0</span>
</li></ol></div></div></div>
<p>This code can be read as:</p>
<p>“Declare a new constant called <code class="docutils literal notranslate"><span class="pre">maximumNumberOfLoginAttempts</span></code>, and give it a value of <code class="docutils literal notranslate"><span class="pre">10</span></code>. Then, declare a new variable called <code class="docutils literal notranslate"><span class="pre">currentLoginAttempt</span></code>, and give it an initial value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.”</p>
<p>In this example, the maximum number of allowed login attempts is declared as a constant, because the maximum value never changes. The current login attempt counter is declared as a variable, because this value must be incremented after each failed login attempt.</p>
<p>You can declare multiple constants or multiple variables on a single line, separated by commas:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>, <span class="nv">z</span> = <span class="m">0.0</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a stored value in your code won’t change, always declare it as a constant with the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword. Use variables only for storing values that need to be able to change.</p>
</div>
</div>
<div class="section" id="ID312">
<h3>Type Annotations<a class="headerlink" href="TheBasics.html#ID312" title="Permalink to this headline">¶</a></h3>
<p>You can provide a <em>type annotation</em> when you declare a constant or variable, to be clear about the kind of values the constant or variable can store. Write a type annotation by placing a colon after the constant or variable name, followed by a space, followed by the name of the type to use.</p>
<p>This example provides a type annotation for a variable called <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code>, to indicate that the variable can store <code class="docutils literal notranslate"><span class="pre">String</span></code> values:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">welcomeMessage</span>: <span class="nc">String</span>
</li></ol></div></div></div>
<p>The colon in the declaration means “…of type…,” so the code above can be read as:</p>
<p>“Declare a variable called <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code> that is of type <code class="docutils literal notranslate"><span class="pre">String</span></code>.”</p>
<p>The phrase “of type <code class="docutils literal notranslate"><span class="pre">String</span></code>” means “can store any <code class="docutils literal notranslate"><span class="pre">String</span></code> value.” Think of it as meaning “the type of thing” (or “the kind of thing”) that can be stored.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code> variable can now be set to any string value without error:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">welcomeMessage</span> = <span class="s">"Hello"</span>
</li></ol></div></div></div>
<p>You can define multiple related variables of the same type on a single line, separated by commas, with a single type annotation after the final variable name:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">red</span>, <span class="nv">green</span>, <span class="nv">blue</span>: <span class="nc">Double</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It’s rare that you need to write type annotations in practice. If you provide an initial value for a constant or variable at the point that it’s defined, Swift can almost always infer the type to be used for that constant or variable, as described in <a class="reference internal" href="TheBasics.html#ID322"><span class="std std-ref">Type Safety and Type Inference</span></a>. In the <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code> example above, no initial value is provided, and so the type of the <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code> variable is specified with a type annotation rather than being inferred from an initial value.</p>
</div>
</div>
<div class="section" id="ID313">
<h3>Naming Constants and Variables<a class="headerlink" href="TheBasics.html#ID313" title="Permalink to this headline">¶</a></h3>
<p>Constant and variable names can contain almost any character, including Unicode characters:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">π</span> = <span class="m">3.14159</span>
</li><li><span class="k">let</span> <span class="nv">你好</span> = <span class="s">"你好世界"</span>
</li><li><span class="k">let</span> <span class="nv">🐶🐮</span> = <span class="s">"dogcow"</span>
</li></ol></div></div></div>
<p>Constant and variable names can’t contain whitespace characters, mathematical symbols, arrows, private-use Unicode scalar values, or line- and box-drawing characters. Nor can they begin with a number, although numbers may be included elsewhere within the name.</p>
<p>Once you’ve declared a constant or variable of a certain type, you can’t declare it again with the same name, or change it to store values of a different type. Nor can you change a constant into a variable or a variable into a constant.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you need to give a constant or variable the same name as a reserved Swift keyword, surround the keyword with backticks (<code class="docutils literal notranslate"><span class="pre">`</span></code>) when using it as a name. However, avoid using keywords as names unless you have absolutely no choice.</p>
</div>
<p>You can change the value of an existing variable to another value of a compatible type. In this example, the value of <code class="docutils literal notranslate"><span class="pre">friendlyWelcome</span></code> is changed from <code class="docutils literal notranslate"><span class="pre">"Hello!"</span></code> to <code class="docutils literal notranslate"><span class="pre">"Bonjour!"</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">friendlyWelcome</span> = <span class="s">"Hello!"</span>
</li><li><span class="nv">friendlyWelcome</span> = <span class="s">"Bonjour!"</span>
</li><li><span class="c">// friendlyWelcome is now "Bonjour!"</span>
</li></ol></div></div></div>
<p>Unlike a variable, the value of a constant can’t be changed after it’s set. Attempting to do so is reported as an error when your code is compiled:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">languageName</span> = <span class="s">"Swift"</span>
</li><li><span class="nv">languageName</span> = <span class="s">"Swift++"</span>
</li><li><span class="c">// This is a compile-time error: languageName cannot be changed.</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID314">
<h3>Printing Constants and Variables<a class="headerlink" href="TheBasics.html#ID314" title="Permalink to this headline">¶</a></h3>
<p>You can print the current value of a constant or variable with the <code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code> function:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="nv">friendlyWelcome</span>)
</li><li><span class="c">// Prints "Bonjour!"</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code> function is a global function that prints one or more values to an appropriate output. In Xcode, for example, the <code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code> function prints its output in Xcode’s “console” pane. The <code class="docutils literal notranslate"><span class="pre">separator</span></code> and <code class="docutils literal notranslate"><span class="pre">terminator</span></code> parameter have default values, so you can omit them when you call this function. By default, the function terminates the line it prints by adding a line break. To print a value without a line break after it, pass an empty string as the terminator—for example, <code class="docutils literal notranslate"><span class="pre">print(someValue,</span> <span class="pre">terminator:</span> <span class="pre">"")</span></code>. For information about parameters with default values, see <a class="reference internal" href="Functions.html#ID169"><span class="std std-ref">Default Parameter Values</span></a>.</p>
<p>Swift uses <em>string interpolation</em> to include the name of a constant or variable as a placeholder in a longer string, and to prompt Swift to replace it with the current value of that constant or variable. Wrap the name in parentheses and escape it with a backslash before the opening parenthesis:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"The current value of friendlyWelcome is </span>\<span class="p">(</span><span class="nv">friendlyWelcome</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The current value of friendlyWelcome is Bonjour!"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All options you can use with string interpolation are described in <a class="reference internal" href="StringsAndCharacters.html#ID292"><span class="std std-ref">String Interpolation</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="ID315">
<h2>Comments<a class="headerlink" href="TheBasics.html#ID315" title="Permalink to this headline">¶</a></h2>
<p>Use comments to include nonexecutable text in your code, as a note or reminder to yourself. Comments are ignored by the Swift compiler when your code is compiled.</p>
<p>Comments in Swift are very similar to comments in C. Single-line comments begin with two forward-slashes (<code class="docutils literal notranslate"><span class="pre">//</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// This is a comment.</span>
</li></ol></div></div></div>
<p>Multiline comments start with a forward-slash followed by an asterisk (<code class="docutils literal notranslate"><span class="pre">/*</span></code>) and end with an asterisk followed by a forward-slash (<code class="docutils literal notranslate"><span class="pre">*/</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">/* This is also a comment</span>
</li><li><span class="c">but is written over multiple lines. */</span>
</li></ol></div></div></div>
<p>Unlike multiline comments in C, multiline comments in Swift can be nested inside other multiline comments. You write nested comments by starting a multiline comment block and then starting a second multiline comment within the first block. The second block is then closed, followed by the first block:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">/* This is the start of the first multiline comment.</span>
</li><li><span class="c"> /* This is the second, nested multiline comment. */</span>
</li><li><span class="c">This is the end of the first multiline comment. */</span>
</li></ol></div></div></div>
<p>Nested multiline comments enable you to comment out large blocks of code quickly and easily, even if the code already contains multiline comments.</p>
</div>
<div class="section" id="ID316">
<h2>Semicolons<a class="headerlink" href="TheBasics.html#ID316" title="Permalink to this headline">¶</a></h2>
<p>Unlike many other languages, Swift doesn’t require you to write a semicolon (<code class="docutils literal notranslate"><span class="pre">;</span></code>) after each statement in your code, although you can do so if you wish. However, semicolons <em>are</em> required if you want to write multiple separate statements on a single line:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">cat</span> = <span class="s">"🐱"</span>; <span class="nv">print</span>(<span class="nv">cat</span>)
</li><li><span class="c">// Prints "🐱"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID317">
<h2>Integers<a class="headerlink" href="TheBasics.html#ID317" title="Permalink to this headline">¶</a></h2>
<p><em>Integers</em> are whole numbers with no fractional component, such as <code class="docutils literal notranslate"><span class="pre">42</span></code> and <code class="docutils literal notranslate"><span class="pre">-23</span></code>. Integers are either <em>signed</em> (positive, zero, or negative) or <em>unsigned</em> (positive or zero).</p>
<p>Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms. These integers follow a naming convention similar to C, in that an 8-bit unsigned integer is of type <code class="docutils literal notranslate"><span class="pre">UInt8</span></code>, and a 32-bit signed integer is of type <code class="docutils literal notranslate"><span class="pre">Int32</span></code>. Like all types in Swift, these integer types have capitalized names.</p>
<div class="section" id="ID318">
<h3>Integer Bounds<a class="headerlink" href="TheBasics.html#ID318" title="Permalink to this headline">¶</a></h3>
<p>You can access the minimum and maximum values of each integer type with its <code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code> properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">minValue</span> = <span class="nv">UInt8</span>.<span class="nv">min</span> <span class="c">// minValue is equal to 0, and is of type UInt8</span>
</li><li><span class="k">let</span> <span class="nv">maxValue</span> = <span class="nv">UInt8</span>.<span class="nv">max</span> <span class="c">// maxValue is equal to 255, and is of type UInt8</span>
</li></ol></div></div></div>
<p>The values of these properties are of the appropriate-sized number type (such as <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> in the example above) and can therefore be used in expressions alongside other values of the same type.</p>
</div>
<div class="section" id="ID319">
<h3>Int<a class="headerlink" href="TheBasics.html#ID319" title="Permalink to this headline">¶</a></h3>
<p>In most cases, you don’t need to pick a specific size of integer to use in your code. Swift provides an additional integer type, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, which has the same size as the current platform’s native word size:</p>
<ul class="simple">
<li>On a 32-bit platform, <code class="docutils literal notranslate"><span class="pre">Int</span></code> is the same size as <code class="docutils literal notranslate"><span class="pre">Int32</span></code>.</li>
<li>On a 64-bit platform, <code class="docutils literal notranslate"><span class="pre">Int</span></code> is the same size as <code class="docutils literal notranslate"><span class="pre">Int64</span></code>.</li>
</ul>
<p>Unless you need to work with a specific size of integer, always use <code class="docutils literal notranslate"><span class="pre">Int</span></code> for integer values in your code. This aids code consistency and interoperability. Even on 32-bit platforms, <code class="docutils literal notranslate"><span class="pre">Int</span></code> can store any value between <code class="docutils literal notranslate"><span class="pre">-2,147,483,648</span></code> and <code class="docutils literal notranslate"><span class="pre">2,147,483,647</span></code>, and is large enough for many integer ranges.</p>
</div>
<div class="section" id="ID320">
<h3>UInt<a class="headerlink" href="TheBasics.html#ID320" title="Permalink to this headline">¶</a></h3>
<p>Swift also provides an unsigned integer type, <code class="docutils literal notranslate"><span class="pre">UInt</span></code>, which has the same size as the current platform’s native word size:</p>
<ul class="simple">
<li>On a 32-bit platform, <code class="docutils literal notranslate"><span class="pre">UInt</span></code> is the same size as <code class="docutils literal notranslate"><span class="pre">UInt32</span></code>.</li>
<li>On a 64-bit platform, <code class="docutils literal notranslate"><span class="pre">UInt</span></code> is the same size as <code class="docutils literal notranslate"><span class="pre">UInt64</span></code>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use <code class="docutils literal notranslate"><span class="pre">UInt</span></code> only when you specifically need an unsigned integer type with the same size as the platform’s native word size. If this isn’t the case, <code class="docutils literal notranslate"><span class="pre">Int</span></code> is preferred, even when the values to be stored are known to be nonnegative. A consistent use of <code class="docutils literal notranslate"><span class="pre">Int</span></code> for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in <a class="reference internal" href="TheBasics.html#ID322"><span class="std std-ref">Type Safety and Type Inference</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="ID321">
<h2>Floating-Point Numbers<a class="headerlink" href="TheBasics.html#ID321" title="Permalink to this headline">¶</a></h2>
<p><em>Floating-point numbers</em> are numbers with a fractional component, such as <code class="docutils literal notranslate"><span class="pre">3.14159</span></code>, <code class="docutils literal notranslate"><span class="pre">0.1</span></code>, and <code class="docutils literal notranslate"><span class="pre">-273.15</span></code>.</p>
<p>Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an <code class="docutils literal notranslate"><span class="pre">Int</span></code>. Swift provides two signed floating-point number types:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Double</span></code> represents a 64-bit floating-point number.</li>
<li><code class="docutils literal notranslate"><span class="pre">Float</span></code> represents a 32-bit floating-point number.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">Double</span></code> has a precision of at least 15 decimal digits, whereas the precision of <code class="docutils literal notranslate"><span class="pre">Float</span></code> can be as little as 6 decimal digits. The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code. In situations where either type would be appropriate, <code class="docutils literal notranslate"><span class="pre">Double</span></code> is preferred.</p>
</div>
</div>
<div class="section" id="ID322">
<h2>Type Safety and Type Inference<a class="headerlink" href="TheBasics.html#ID322" title="Permalink to this headline">¶</a></h2>
<p>Swift is a <em>type-safe</em> language. A type safe language encourages you to be clear about the types of values your code can work with. If part of your code requires a <code class="docutils literal notranslate"><span class="pre">String</span></code>, you can’t pass it an <code class="docutils literal notranslate"><span class="pre">Int</span></code> by mistake.</p>
<p>Because Swift is type safe, it performs <em>type checks</em> when compiling your code and flags any mismatched types as errors. This enables you to catch and fix errors as early as possible in the development process.</p>
<p>Type-checking helps you avoid errors when you’re working with different types of values. However, this doesn’t mean that you have to specify the type of every constant and variable that you declare. If you don’t specify the type of value you need, Swift uses <em>type inference</em> to work out the appropriate type. Type inference enables a compiler to deduce the type of a particular expression automatically when it compiles your code, simply by examining the values you provide.</p>
<p>Because of type inference, Swift requires far fewer type declarations than languages such as C or Objective-C. Constants and variables are still explicitly typed, but much of the work of specifying their type is done for you.</p>
<p>Type inference is particularly useful when you declare a constant or variable with an initial value. This is often done by assigning a <em>literal value</em> (or <em>literal</em>) to the constant or variable at the point that you declare it. (A literal value is a value that appears directly in your source code, such as <code class="docutils literal notranslate"><span class="pre">42</span></code> and <code class="docutils literal notranslate"><span class="pre">3.14159</span></code> in the examples below.)</p>
<p>For example, if you assign a literal value of <code class="docutils literal notranslate"><span class="pre">42</span></code> to a new constant without saying what type it is, Swift infers that you want the constant to be an <code class="docutils literal notranslate"><span class="pre">Int</span></code>, because you have initialized it with a number that looks like an integer:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">meaningOfLife</span> = <span class="m">42</span>
</li><li><span class="c">// meaningOfLife is inferred to be of type Int</span>
</li></ol></div></div></div>
<p>Likewise, if you don’t specify a type for a floating-point literal, Swift infers that you want to create a <code class="docutils literal notranslate"><span class="pre">Double</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">pi</span> = <span class="m">3.14159</span>
</li><li><span class="c">// pi is inferred to be of type Double</span>
</li></ol></div></div></div>
<p>Swift always chooses <code class="docutils literal notranslate"><span class="pre">Double</span></code> (rather than <code class="docutils literal notranslate"><span class="pre">Float</span></code>) when inferring the type of floating-point numbers.</p>
<p>If you combine integer and floating-point literals in an expression, a type of <code class="docutils literal notranslate"><span class="pre">Double</span></code> will be inferred from the context:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">anotherPi</span> = <span class="m">3</span> + <span class="m">0.14159</span>
</li><li><span class="c">// anotherPi is also inferred to be of type Double</span>
</li></ol></div></div></div>
<p>The literal value of <code class="docutils literal notranslate"><span class="pre">3</span></code> has no explicit type in and of itself, and so an appropriate output type of <code class="docutils literal notranslate"><span class="pre">Double</span></code> is inferred from the presence of a floating-point literal as part of the addition.</p>
</div>
<div class="section" id="ID323">
<h2>Numeric Literals<a class="headerlink" href="TheBasics.html#ID323" title="Permalink to this headline">¶</a></h2>
<p>Integer literals can be written as:</p>
<ul class="simple">
<li>A <em>decimal</em> number, with no prefix</li>
<li>A <em>binary</em> number, with a <code class="docutils literal notranslate"><span class="pre">0b</span></code> prefix</li>
<li>An <em>octal</em> number, with a <code class="docutils literal notranslate"><span class="pre">0o</span></code> prefix</li>
<li>A <em>hexadecimal</em> number, with a <code class="docutils literal notranslate"><span class="pre">0x</span></code> prefix</li>
</ul>
<p>All of these integer literals have a decimal value of <code class="docutils literal notranslate"><span class="pre">17</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">decimalInteger</span> = <span class="m">17</span>
</li><li><span class="k">let</span> <span class="nv">binaryInteger</span> = <span class="m">0b10001</span> <span class="c">// 17 in binary notation</span>
</li><li><span class="k">let</span> <span class="nv">octalInteger</span> = <span class="m">0o21</span> <span class="c">// 17 in octal notation</span>
</li><li><span class="k">let</span> <span class="nv">hexadecimalInteger</span> = <span class="m">0x11</span> <span class="c">// 17 in hexadecimal notation</span>
</li></ol></div></div></div>
<p>Floating-point literals can be decimal (with no prefix), or hexadecimal (with a <code class="docutils literal notranslate"><span class="pre">0x</span></code> prefix). They must always have a number (or hexadecimal number) on both sides of the decimal point. Decimal floats can also have an optional <em>exponent</em>, indicated by an uppercase or lowercase <code class="docutils literal notranslate"><span class="pre">e</span></code>; hexadecimal floats must have an exponent, indicated by an uppercase or lowercase <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>For decimal numbers with an exponent of <code class="docutils literal notranslate"><span class="pre">exp</span></code>, the base number is multiplied by 10<sup>exp</sup>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">1.25e2</span></code> means 1.25 x 10<sup>2</sup>, or <code class="docutils literal notranslate"><span class="pre">125.0</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">1.25e-2</span></code> means 1.25 x 10<sup>-2</sup>, or <code class="docutils literal notranslate"><span class="pre">0.0125</span></code>.</li>
</ul>
<p>For hexadecimal numbers with an exponent of <code class="docutils literal notranslate"><span class="pre">exp</span></code>, the base number is multiplied by 2<sup>exp</sup>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">0xFp2</span></code> means 15 x 2<sup>2</sup>, or <code class="docutils literal notranslate"><span class="pre">60.0</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">0xFp-2</span></code> means 15 x 2<sup>-2</sup>, or <code class="docutils literal notranslate"><span class="pre">3.75</span></code>.</li>
</ul>
<p>All of these floating-point literals have a decimal value of <code class="docutils literal notranslate"><span class="pre">12.1875</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">decimalDouble</span> = <span class="m">12.1875</span>
</li><li><span class="k">let</span> <span class="nv">exponentDouble</span> = <span class="m">1.21875e1</span>
</li><li><span class="k">let</span> <span class="nv">hexadecimalDouble</span> = <span class="m">0xC.3p0</span>
</li></ol></div></div></div>
<p>Numeric literals can contain extra formatting to make them easier to read. Both integers and floats can be padded with extra zeros and can contain underscores to help with readability. Neither type of formatting affects the underlying value of the literal:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">paddedDouble</span> = <span class="m">000123.456</span>
</li><li><span class="k">let</span> <span class="nv">oneMillion</span> = <span class="m">1_000_000</span>
</li><li><span class="k">let</span> <span class="nv">justOverOneMillion</span> = <span class="m">1_000_000.000_000_1</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID324">
<h2>Numeric Type Conversion<a class="headerlink" href="TheBasics.html#ID324" title="Permalink to this headline">¶</a></h2>
<p>Use the <code class="docutils literal notranslate"><span class="pre">Int</span></code> type for all general-purpose integer constants and variables in your code, even if they’re known to be nonnegative. Using the default integer type in everyday situations means that integer constants and variables are immediately interoperable in your code and will match the inferred type for integer literal values.</p>
<p>Use other integer types only when they’re specifically needed for the task at hand, because of explicitly sized data from an external source, or for performance, memory usage, or other necessary optimization. Using explicitly sized types in these situations helps to catch any accidental value overflows and implicitly documents the nature of the data being used.</p>
<div class="section" id="ID325">
<h3>Integer Conversion<a class="headerlink" href="TheBasics.html#ID325" title="Permalink to this headline">¶</a></h3>
<p>The range of numbers that can be stored in an integer constant or variable is different for each numeric type. An <code class="docutils literal notranslate"><span class="pre">Int8</span></code> constant or variable can store numbers between <code class="docutils literal notranslate"><span class="pre">-128</span></code> and <code class="docutils literal notranslate"><span class="pre">127</span></code>, whereas a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> constant or variable can store numbers between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">255</span></code>. A number that won’t fit into a constant or variable of a sized integer type is reported as an error when your code is compiled:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">cannotBeNegative</span>: <span class="nc">UInt8</span> = <span class="m">-1</span>
</li><li><span class="c">// UInt8 cannot store negative numbers, and so this will report an error</span>
</li><li><span class="k">let</span> <span class="nv">tooBig</span>: <span class="nc">Int8</span> = <span class="nv">Int8</span>.<span class="nv">max</span> + <span class="m">1</span>
</li><li><span class="c">// Int8 cannot store a number larger than its maximum value,</span>
</li><li><span class="c">// and so this will also report an error</span>
</li></ol></div></div></div>
<p>Because each numeric type can store a different range of values, you must opt in to numeric type conversion on a case-by-case basis. This opt-in approach prevents hidden conversion errors and helps make type conversion intentions explicit in your code.</p>
<p>To convert one specific number type to another, you initialize a new number of the desired type with the existing value. In the example below, the constant <code class="docutils literal notranslate"><span class="pre">twoThousand</span></code> is of type <code class="docutils literal notranslate"><span class="pre">UInt16</span></code>, whereas the constant <code class="docutils literal notranslate"><span class="pre">one</span></code> is of type <code class="docutils literal notranslate"><span class="pre">UInt8</span></code>. They can’t be added together directly, because they’re not of the same type. Instead, this example calls <code class="docutils literal notranslate"><span class="pre">UInt16(one)</span></code> to create a new <code class="docutils literal notranslate"><span class="pre">UInt16</span></code> initialized with the value of <code class="docutils literal notranslate"><span class="pre">one</span></code>, and uses this value in place of the original:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">twoThousand</span>: <span class="nc">UInt16</span> = <span class="m">2_000</span>
</li><li><span class="k">let</span> <span class="nv">one</span>: <span class="nc">UInt8</span> = <span class="m">1</span>
</li><li><span class="k">let</span> <span class="nv">twoThousandAndOne</span> = <span class="nv">twoThousand</span> + <span class="nv">UInt16</span>(<span class="nv">one</span>)
</li></ol></div></div></div>
<p>Because both sides of the addition are now of type <code class="docutils literal notranslate"><span class="pre">UInt16</span></code>, the addition is allowed. The output constant (<code class="docutils literal notranslate"><span class="pre">twoThousandAndOne</span></code>) is inferred to be of type <code class="docutils literal notranslate"><span class="pre">UInt16</span></code>, because it’s the sum of two <code class="docutils literal notranslate"><span class="pre">UInt16</span></code> values.</p>
<p><code class="docutils literal notranslate"><span class="pre">SomeType(ofInitialValue)</span></code> is the default way to call the initializer of a Swift type and pass in an initial value. Behind the scenes, <code class="docutils literal notranslate"><span class="pre">UInt16</span></code> has an initializer that accepts a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> value, and so this initializer is used to make a new <code class="docutils literal notranslate"><span class="pre">UInt16</span></code> from an existing <code class="docutils literal notranslate"><span class="pre">UInt8</span></code>. You can’t pass in <em>any</em> type here, however—it has to be a type for which <code class="docutils literal notranslate"><span class="pre">UInt16</span></code> provides an initializer. Extending existing types to provide initializers that accept new types (including your own type definitions) is covered in <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>.</p>
</div>
<div class="section" id="ID326">
<h3>Integer and Floating-Point Conversion<a class="headerlink" href="TheBasics.html#ID326" title="Permalink to this headline">¶</a></h3>
<p>Conversions between integer and floating-point numeric types must be made explicit:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">three</span> = <span class="m">3</span>
</li><li><span class="k">let</span> <span class="nv">pointOneFourOneFiveNine</span> = <span class="m">0.14159</span>
</li><li><span class="k">let</span> <span class="nv">pi</span> = <span class="nv">Double</span>(<span class="nv">three</span>) + <span class="nv">pointOneFourOneFiveNine</span>
</li><li><span class="c">// pi equals 3.14159, and is inferred to be of type Double</span>
</li></ol></div></div></div>
<p>Here, the value of the constant <code class="docutils literal notranslate"><span class="pre">three</span></code> is used to create a new value of type <code class="docutils literal notranslate"><span class="pre">Double</span></code>, so that both sides of the addition are of the same type. Without this conversion in place, the addition would not be allowed.</p>
<p>Floating-point to integer conversion must also be made explicit. An integer type can be initialized with a <code class="docutils literal notranslate"><span class="pre">Double</span></code> or <code class="docutils literal notranslate"><span class="pre">Float</span></code> value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">integerPi</span> = <span class="nv">Int</span>(<span class="nv">pi</span>)
</li><li><span class="c">// integerPi equals 3, and is inferred to be of type Int</span>
</li></ol></div></div></div>
<p>Floating-point values are always truncated when used to initialize a new integer value in this way. This means that <code class="docutils literal notranslate"><span class="pre">4.75</span></code> becomes <code class="docutils literal notranslate"><span class="pre">4</span></code>, and <code class="docutils literal notranslate"><span class="pre">-3.9</span></code> becomes <code class="docutils literal notranslate"><span class="pre">-3</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The rules for combining numeric constants and variables are different from the rules for numeric literals. The literal value <code class="docutils literal notranslate"><span class="pre">3</span></code> can be added directly to the literal value <code class="docutils literal notranslate"><span class="pre">0.14159</span></code>, because number literals don’t have an explicit type in and of themselves. Their type is inferred only at the point that they’re evaluated by the compiler.</p>
</div>
</div>
</div>
<div class="section" id="ID327">
<h2>Type Aliases<a class="headerlink" href="TheBasics.html#ID327" title="Permalink to this headline">¶</a></h2>
<p><em>Type aliases</em> define an alternative name for an existing type. You define type aliases with the <code class="docutils literal notranslate"><span class="pre">typealias</span></code> keyword.</p>
<p>Type aliases are useful when you want to refer to an existing type by a name that is contextually more appropriate, such as when working with data of a specific size from an external source:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">typealias</span> <span class="nv">AudioSample</span> = <span class="nc">UInt16</span>
</li></ol></div></div></div>
<p>Once you define a type alias, you can use the alias anywhere you might use the original name:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">maxAmplitudeFound</span> = <span class="nv">AudioSample</span>.<span class="nv">min</span>
</li><li><span class="c">// maxAmplitudeFound is now 0</span>
</li></ol></div></div></div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">AudioSample</span></code> is defined as an alias for <code class="docutils literal notranslate"><span class="pre">UInt16</span></code>. Because it’s an alias, the call to <code class="docutils literal notranslate"><span class="pre">AudioSample.min</span></code> actually calls <code class="docutils literal notranslate"><span class="pre">UInt16.min</span></code>, which provides an initial value of <code class="docutils literal notranslate"><span class="pre">0</span></code> for the <code class="docutils literal notranslate"><span class="pre">maxAmplitudeFound</span></code> variable.</p>
</div>
<div class="section" id="ID328">
<h2>Booleans<a class="headerlink" href="TheBasics.html#ID328" title="Permalink to this headline">¶</a></h2>
<p>Swift has a basic <em>Boolean</em> type, called <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. Boolean values are referred to as <em>logical</em>, because they can only ever be true or false. Swift provides two Boolean constant values, <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">orangesAreOrange</span> = <span class="k">true</span>
</li><li><span class="k">let</span> <span class="nv">turnipsAreDelicious</span> = <span class="k">false</span>
</li></ol></div></div></div>
<p>The types of <code class="docutils literal notranslate"><span class="pre">orangesAreOrange</span></code> and <code class="docutils literal notranslate"><span class="pre">turnipsAreDelicious</span></code> have been inferred as <code class="docutils literal notranslate"><span class="pre">Bool</span></code> from the fact that they were initialized with Boolean literal values. As with <code class="docutils literal notranslate"><span class="pre">Int</span></code> and <code class="docutils literal notranslate"><span class="pre">Double</span></code> above, you don’t need to declare constants or variables as <code class="docutils literal notranslate"><span class="pre">Bool</span></code> if you set them to <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code> as soon as you create them. Type inference helps make Swift code more concise and readable when it initializes constants or variables with other values whose type is already known.</p>
<p>Boolean values are particularly useful when you work with conditional statements such as the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">turnipsAreDelicious</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Mmm, tasty turnips!"</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Eww, turnips are horrible."</span>)
</li><li>}
</li><li><span class="c">// Prints "Eww, turnips are horrible."</span>
</li></ol></div></div></div>
<p>Conditional statements such as the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement are covered in more detail in <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>.</p>
<p>Swift’s type safety prevents non-Boolean values from being substituted for <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. The following example reports a compile-time error:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">i</span> = <span class="m">1</span>
</li><li><span class="k">if</span> <span class="nv">i</span> {
</li><li> <span class="c">// this example will not compile, and will report an error</span>
</li><li>}
</li></ol></div></div></div>
<p>However, the alternative example below is valid:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">i</span> = <span class="m">1</span>
</li><li><span class="k">if</span> <span class="nv">i</span> == <span class="m">1</span> {
</li><li> <span class="c">// this example will compile successfully</span>
</li><li>}
</li></ol></div></div></div>
<p>The result of the <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></code> comparison is of type <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, and so this second example passes the type-check. Comparisons like <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></code> are discussed in <a class="reference internal" href="BasicOperators.html"><span class="doc">Basic Operators</span></a>.</p>
<p>As with other examples of type safety in Swift, this approach avoids accidental errors and ensures that the intention of a particular section of code is always clear.</p>
</div>
<div class="section" id="ID329">
<h2>Tuples<a class="headerlink" href="TheBasics.html#ID329" title="Permalink to this headline">¶</a></h2>
<p><em>Tuples</em> group multiple values into a single compound value. The values within a tuple can be of any type and don’t have to be of the same type as each other.</p>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">(404,</span> <span class="pre">"Not</span> <span class="pre">Found")</span></code> is a tuple that describes an <em>HTTP status code</em>. An HTTP status code is a special value returned by a web server whenever you request a web page. A status code of <code class="docutils literal notranslate"><span class="pre">404</span> <span class="pre">Not</span> <span class="pre">Found</span></code> is returned if you request a webpage that doesn’t exist.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">http404Error</span> = (<span class="m">404</span>, <span class="s">"Not Found"</span>)
</li><li><span class="c">// http404Error is of type (Int, String), and equals (404, "Not Found")</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">(404,</span> <span class="pre">"Not</span> <span class="pre">Found")</span></code> tuple groups together an <code class="docutils literal notranslate"><span class="pre">Int</span></code> and a <code class="docutils literal notranslate"><span class="pre">String</span></code> to give the HTTP status code two separate values: a number and a human-readable description. It can be described as “a tuple of type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">String)</span></code>”.</p>
<p>You can create tuples from any permutation of types, and they can contain as many different types as you like. There’s nothing stopping you from having a tuple of type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int,</span> <span class="pre">Int)</span></code>, or <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">Bool)</span></code>, or indeed any other permutation you require.</p>
<p>You can <em>decompose</em> a tuple’s contents into separate constants or variables, which you then access as usual:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> (<span class="nv">statusCode</span>, <span class="nv">statusMessage</span>) = <span class="nv">http404Error</span>
</li><li><span class="nv">print</span>(<span class="s">"The status code is </span>\<span class="p">(</span><span class="nv">statusCode</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The status code is 404"</span>
</li><li><span class="nv">print</span>(<span class="s">"The status message is </span>\<span class="p">(</span><span class="nv">statusMessage</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The status message is Not Found"</span>
</li></ol></div></div></div>
<p>If you only need some of the tuple’s values, ignore parts of the tuple with an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) when you decompose the tuple:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> (<span class="nv">justTheStatusCode</span>, <span class="k">_</span>) = <span class="nv">http404Error</span>
</li><li><span class="nv">print</span>(<span class="s">"The status code is </span>\<span class="p">(</span><span class="nv">justTheStatusCode</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The status code is 404"</span>
</li></ol></div></div></div>
<p>Alternatively, access the individual element values in a tuple using index numbers starting at zero:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"The status code is </span>\<span class="p">(</span><span class="nv">http404Error</span>.<span class="m">0</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The status code is 404"</span>
</li><li><span class="nv">print</span>(<span class="s">"The status message is </span>\<span class="p">(</span><span class="nv">http404Error</span>.<span class="m">1</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The status message is Not Found"</span>
</li></ol></div></div></div>
<p>You can name the individual elements in a tuple when the tuple is defined:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">http200Status</span> = (<span class="nv">statusCode</span>: <span class="m">200</span>, <span class="nv">description</span>: <span class="s">"OK"</span>)
</li></ol></div></div></div>
<p>If you name the elements in a tuple, you can use the element names to access the values of those elements:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"The status code is </span>\<span class="p">(</span><span class="nv">http200Status</span>.<span class="nv">statusCode</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The status code is 200"</span>
</li><li><span class="nv">print</span>(<span class="s">"The status message is </span>\<span class="p">(</span><span class="nv">http200Status</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The status message is OK"</span>
</li></ol></div></div></div>
<p>Tuples are particularly useful as the return values of functions. A function that tries to retrieve a web page might return the <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">String)</span></code> tuple type to describe the success or failure of the page retrieval. By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type. For more information, see <a class="reference internal" href="Functions.html#ID164"><span class="std std-ref">Functions with Multiple Return Values</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Tuples are useful for temporary groups of related values. They’re not suited to the creation of complex data structures. If your data structure is likely to persist beyond a temporary scope, model it as a class or structure, rather than as a tuple. For more information, see <a class="reference internal" href="ClassesAndStructures.html"><span class="doc">Structures and Classes</span></a>.</p>
</div>
</div>
<div class="section" id="ID330">
<h2>Optionals<a class="headerlink" href="TheBasics.html#ID330" title="Permalink to this headline">¶</a></h2>
<p>You use <em>optionals</em> in situations where a value may be absent. An optional represents two possibilities: Either there <em>is</em> a value, and you can unwrap the optional to access that value, or there <em>isn’t</em> a value at all.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The concept of optionals doesn’t exist in C or Objective-C. The nearest thing in Objective-C is the ability to return <code class="docutils literal notranslate"><span class="pre">nil</span></code> from a method that would otherwise return an object, with <code class="docutils literal notranslate"><span class="pre">nil</span></code> meaning “the absence of a valid object.” However, this only works for objects—it doesn’t work for structures, basic C types, or enumeration values. For these types, Objective-C methods typically return a special value (such as <code class="docutils literal notranslate"><span class="pre">NSNotFound</span></code>) to indicate the absence of a value. This approach assumes that the method’s caller knows there’s a special value to test against and remembers to check for it. Swift’s optionals let you indicate the absence of a value for <em>any type at all</em>, without the need for special constants.</p>
</div>
<p>Here’s an example of how optionals can be used to cope with the absence of a value. Swift’s <code class="docutils literal notranslate"><span class="pre">Int</span></code> type has an initializer which tries to convert a <code class="docutils literal notranslate"><span class="pre">String</span></code> value into an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value. However, not every string can be converted into an integer. The string <code class="docutils literal notranslate"><span class="pre">"123"</span></code> can be converted into the numeric value <code class="docutils literal notranslate"><span class="pre">123</span></code>, but the string <code class="docutils literal notranslate"><span class="pre">"hello,</span> <span class="pre">world"</span></code> doesn’t have an obvious numeric value to convert to.</p>
<p>The example below uses the initializer to try to convert a <code class="docutils literal notranslate"><span class="pre">String</span></code> into an <code class="docutils literal notranslate"><span class="pre">Int</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">possibleNumber</span> = <span class="s">"123"</span>
</li><li><span class="k">let</span> <span class="nv">convertedNumber</span> = <span class="nv">Int</span>(<span class="nv">possibleNumber</span>)
</li><li><span class="c">// convertedNumber is inferred to be of type "Int?", or "optional Int"</span>
</li></ol></div></div></div>
<p>Because the initializer might fail, it returns an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">Int</span></code>, rather than an <code class="docutils literal notranslate"><span class="pre">Int</span></code>. An optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> is written as <code class="docutils literal notranslate"><span class="pre">Int?</span></code>, not <code class="docutils literal notranslate"><span class="pre">Int</span></code>. The question mark indicates that the value it contains is optional, meaning that it might contain <em>some</em> <code class="docutils literal notranslate"><span class="pre">Int</span></code> value, or it might contain <em>no value at all</em>. (It can’t contain anything else, such as a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value or a <code class="docutils literal notranslate"><span class="pre">String</span></code> value. It’s either an <code class="docutils literal notranslate"><span class="pre">Int</span></code>, or it’s nothing at all.)</p>
<div class="section" id="ID331">
<h3>nil<a class="headerlink" href="TheBasics.html#ID331" title="Permalink to this headline">¶</a></h3>
<p>You set an optional variable to a valueless state by assigning it the special value <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">serverResponseCode</span>: <span class="nc">Int</span>? = <span class="m">404</span>
</li><li><span class="c">// serverResponseCode contains an actual Int value of 404</span>
</li><li><span class="nv">serverResponseCode</span> = <span class="k">nil</span>
</li><li><span class="c">// serverResponseCode now contains no value</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can’t use <code class="docutils literal notranslate"><span class="pre">nil</span></code> with nonoptional constants and variables. If a constant or variable in your code needs to work with the absence of a value under certain conditions, always declare it as an optional value of the appropriate type.</p>
</div>
<p>If you define an optional variable without providing a default value, the variable is automatically set to <code class="docutils literal notranslate"><span class="pre">nil</span></code> for you:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">surveyAnswer</span>: <span class="nc">String</span>?
</li><li><span class="c">// surveyAnswer is automatically set to nil</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Swift’s <code class="docutils literal notranslate"><span class="pre">nil</span></code> isn’t the same as <code class="docutils literal notranslate"><span class="pre">nil</span></code> in Objective-C. In Objective-C, <code class="docutils literal notranslate"><span class="pre">nil</span></code> is a pointer to a nonexistent object. In Swift, <code class="docutils literal notranslate"><span class="pre">nil</span></code> isn’t a pointer—it’s the absence of a value of a certain type. Optionals of <em>any</em> type can be set to <code class="docutils literal notranslate"><span class="pre">nil</span></code>, not just object types.</p>
</div>
</div>
<div class="section" id="ID332">
<h3>If Statements and Forced Unwrapping<a class="headerlink" href="TheBasics.html#ID332" title="Permalink to this headline">¶</a></h3>
<p>You can use an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement to find out whether an optional contains a value by comparing the optional against <code class="docutils literal notranslate"><span class="pre">nil</span></code>. You perform this comparison with the “equal to” operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) or the “not equal to” operator (<code class="docutils literal notranslate"><span class="pre">!=</span></code>).</p>
<p>If an optional has a value, it’s considered to be “not equal to” <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">convertedNumber</span> != <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="s">"convertedNumber contains some integer value."</span>)
</li><li>}
</li><li><span class="c">// Prints "convertedNumber contains some integer value."</span>
</li></ol></div></div></div>
<p>Once you’re sure that the optional <em>does</em> contain a value, you can access its underlying value by adding an exclamation mark (<code class="docutils literal notranslate"><span class="pre">!</span></code>) to the end of the optional’s name. The exclamation mark effectively says, “I know that this optional definitely has a value; please use it.” This is known as <em>forced unwrapping</em> of the optional’s value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">convertedNumber</span> != <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="s">"convertedNumber has an integer value of </span>\<span class="p">(</span><span class="nv">convertedNumber</span>!<span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li><span class="c">// Prints "convertedNumber has an integer value of 123."</span>
</li></ol></div></div></div>
<p>For more about the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, see <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Trying to use <code class="docutils literal notranslate"><span class="pre">!</span></code> to access a nonexistent optional value triggers a runtime error. Always make sure that an optional contains a non-<code class="docutils literal notranslate"><span class="pre">nil</span></code> value before using <code class="docutils literal notranslate"><span class="pre">!</span></code> to force-unwrap its value.</p>
</div>
</div>
<div class="section" id="ID333">
<h3>Optional Binding<a class="headerlink" href="TheBasics.html#ID333" title="Permalink to this headline">¶</a></h3>
<p>You use <em>optional binding</em> to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable. Optional binding can be used with <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action. <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> statements are described in more detail in <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>.</p>
<p>Write an optional binding for an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement as follows:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="gi">constantName</span> = <span class="gi">someOptional</span> {
</li><li> <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>You can rewrite the <code class="docutils literal notranslate"><span class="pre">possibleNumber</span></code> example from the <a class="reference internal" href="TheBasics.html#ID330"><span class="std std-ref">Optionals</span></a> section to use optional binding rather than forced unwrapping:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">actualNumber</span> = <span class="nv">Int</span>(<span class="nv">possibleNumber</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"The string \"</span>\<span class="p">(</span><span class="nv">possibleNumber</span><span class="p">)</span><span class="s">\" has an integer value of </span>\<span class="p">(</span><span class="nv">actualNumber</span><span class="p">)</span><span class="s">"</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The string \"</span>\<span class="p">(</span><span class="nv">possibleNumber</span><span class="p">)</span><span class="s">\" could not be converted to an integer"</span>)
</li><li>}
</li><li><span class="c">// Prints "The string "123" has an integer value of 123"</span>
</li></ol></div></div></div>
<p>This code can be read as:</p>
<p>“If the optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> returned by <code class="docutils literal notranslate"><span class="pre">Int(possibleNumber)</span></code> contains a value, set a new constant called <code class="docutils literal notranslate"><span class="pre">actualNumber</span></code> to the value contained in the optional.”</p>
<p>If the conversion is successful, the <code class="docutils literal notranslate"><span class="pre">actualNumber</span></code> constant becomes available for use within the first branch of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement. It has already been initialized with the value contained <em>within</em> the optional, and so there’s no need to use the <code class="docutils literal notranslate"><span class="pre">!</span></code> suffix to access its value. In this example, <code class="docutils literal notranslate"><span class="pre">actualNumber</span></code> is simply used to print the result of the conversion.</p>
<p>You can use both constants and variables with optional binding. If you wanted to manipulate the value of <code class="docutils literal notranslate"><span class="pre">actualNumber</span></code> within the first branch of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, you could write <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">var</span> <span class="pre">actualNumber</span></code> instead, and the value contained within the optional would be made available as a variable rather than a constant.</p>
<p>You can include as many optional bindings and Boolean conditions in a single <code class="docutils literal notranslate"><span class="pre">if</span></code> statement as you need to, separated by commas. If any of the values in the optional bindings are <code class="docutils literal notranslate"><span class="pre">nil</span></code> or any Boolean condition evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code>, the whole <code class="docutils literal notranslate"><span class="pre">if</span></code> statement’s condition is considered to be <code class="docutils literal notranslate"><span class="pre">false</span></code>. The following <code class="docutils literal notranslate"><span class="pre">if</span></code> statements are equivalent:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">firstNumber</span> = <span class="nv">Int</span>(<span class="s">"4"</span>), <span class="k">let</span> <span class="nv">secondNumber</span> = <span class="nv">Int</span>(<span class="s">"42"</span>), <span class="nv">firstNumber</span> &lt; <span class="nv">secondNumber</span> &amp;&amp; <span class="nv">secondNumber</span> &lt; <span class="m">100</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">firstNumber</span><span class="p">)</span><span class="s"> &lt; </span>\<span class="p">(</span><span class="nv">secondNumber</span><span class="p">)</span><span class="s"> &lt; 100"</span>)
</li><li>}
</li><li><span class="c">// Prints "4 &lt; 42 &lt; 100"</span>
</li><li>
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">firstNumber</span> = <span class="nv">Int</span>(<span class="s">"4"</span>) {
</li><li> <span class="k">if</span> <span class="k">let</span> <span class="nv">secondNumber</span> = <span class="nv">Int</span>(<span class="s">"42"</span>) {
</li><li> <span class="k">if</span> <span class="nv">firstNumber</span> &lt; <span class="nv">secondNumber</span> &amp;&amp; <span class="nv">secondNumber</span> &lt; <span class="m">100</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">firstNumber</span><span class="p">)</span><span class="s"> &lt; </span>\<span class="p">(</span><span class="nv">secondNumber</span><span class="p">)</span><span class="s"> &lt; 100"</span>)
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="c">// Prints "4 &lt; 42 &lt; 100"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Constants and variables created with optional binding in an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement are available only within the body of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement. In contrast, the constants and variables created with a <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement are available in the lines of code that follow the <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement, as described in <a class="reference internal" href="ControlFlow.html#ID525"><span class="std std-ref">Early Exit</span></a>.</p>
</div>
</div>
<div class="section" id="ID334">
<h3>Implicitly Unwrapped Optionals<a class="headerlink" href="TheBasics.html#ID334" title="Permalink to this headline">¶</a></h3>
<p>As described above, optionals indicate that a constant or variable is allowed to have “no value”. Optionals can be checked with an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement to see if a value exists, and can be conditionally unwrapped with optional binding to access the optional’s value if it does exist.</p>
<p>Sometimes it’s clear from a program’s structure that an optional will <em>always</em> have a value, after that value is first set. In these cases, it’s useful to remove the need to check and unwrap the optional’s value every time it’s accessed, because it can be safely assumed to have a value all of the time.</p>
<p>These kinds of optionals are defined as <em>implicitly unwrapped optionals</em>. You write an implicitly unwrapped optional by placing an exclamation mark (<code class="docutils literal notranslate"><span class="pre">String!</span></code>) rather than a question mark (<code class="docutils literal notranslate"><span class="pre">String?</span></code>) after the type that you want to make optional.</p>
<p>Implicitly unwrapped optionals are useful when an optional’s value is confirmed to exist immediately after the optional is first defined and can definitely be assumed to exist at every point thereafter. The primary use of implicitly unwrapped optionals in Swift is during class initialization, as described in <a class="reference internal" href="AutomaticReferenceCounting.html#ID55"><span class="std std-ref">Unowned References and Implicitly Unwrapped Optional Properties</span></a>.</p>
<p>An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a nonoptional value, without the need to unwrap the optional value each time it’s accessed. The following example shows the difference in behavior between an optional string and an implicitly unwrapped optional string when accessing their wrapped value as an explicit <code class="docutils literal notranslate"><span class="pre">String</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">possibleString</span>: <span class="nc">String</span>? = <span class="s">"An optional string."</span>
</li><li><span class="k">let</span> <span class="nv">forcedString</span>: <span class="nc">String</span> = <span class="nv">possibleString</span>! <span class="c">// requires an exclamation mark</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">assumedString</span>: <span class="nc">String</span>! = <span class="s">"An implicitly unwrapped optional string."</span>
</li><li><span class="k">let</span> <span class="nv">implicitString</span>: <span class="nc">String</span> = <span class="nv">assumedString</span> <span class="c">// no need for an exclamation mark</span>
</li></ol></div></div></div>
<p>You can think of an implicitly unwrapped optional as giving permission for the optional to be unwrapped automatically whenever it’s used. Rather than placing an exclamation mark after the optional’s name each time you use it, you place an exclamation mark after the optional’s type when you declare it.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If an implicitly unwrapped optional is <code class="docutils literal notranslate"><span class="pre">nil</span></code> and you try to access its wrapped value, you’ll trigger a runtime error. The result is exactly the same as if you place an exclamation mark after a normal optional that doesn’t contain a value.</p>
</div>
<p>You can still treat an implicitly unwrapped optional like a normal optional, to check if it contains a value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">assumedString</span> != <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="nv">assumedString</span>!)
</li><li>}
</li><li><span class="c">// Prints "An implicitly unwrapped optional string."</span>
</li></ol></div></div></div>
<p>You can also use an implicitly unwrapped optional with optional binding, to check and unwrap its value in a single statement:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">definiteString</span> = <span class="nv">assumedString</span> {
</li><li> <span class="nv">print</span>(<span class="nv">definiteString</span>)
</li><li>}
</li><li><span class="c">// Prints "An implicitly unwrapped optional string."</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Don’t use an implicitly unwrapped optional when there’s a possibility of a variable becoming <code class="docutils literal notranslate"><span class="pre">nil</span></code> at a later point. Always use a normal optional type if you need to check for a <code class="docutils literal notranslate"><span class="pre">nil</span></code> value during the lifetime of a variable.</p>
</div>
</div>
</div>
<div class="section" id="ID515">
<h2>Error Handling<a class="headerlink" href="TheBasics.html#ID515" title="Permalink to this headline">¶</a></h2>
<p>You use <em>error handling</em> to respond to error conditions your program may encounter during execution.</p>
<p>In contrast to optionals, which can use the presence or absence of a value to communicate success or failure of a function, error handling allows you to determine the underlying cause of failure, and, if necessary, propagate the error to another part of your program.</p>
<p>When a function encounters an error condition, it <em>throws</em> an error. That function’s caller can then <em>catch</em> the error and respond appropriately.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">canThrowAnError</span>() <span class="k">throws</span> {
</li><li> <span class="c">// this function may or may not throw an error</span>
</li><li>}
</li></ol></div></div></div>
<p>A function indicates that it can throw an error by including the <code class="docutils literal notranslate"><span class="pre">throws</span></code> keyword in its declaration. When you call a function that can throw an error, you prepend the <code class="docutils literal notranslate"><span class="pre">try</span></code> keyword to the expression.</p>
<p>Swift automatically propagates errors out of their current scope until they’re handled by a <code class="docutils literal notranslate"><span class="pre">catch</span></code> clause.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">do</span> {
</li><li> <span class="k">try</span> <span class="nv">canThrowAnError</span>()
</li><li> <span class="c">// no error was thrown</span>
</li><li>} <span class="k">catch</span> {
</li><li> <span class="c">// an error was thrown</span>
</li><li>}
</li></ol></div></div></div>
<p>A <code class="docutils literal notranslate"><span class="pre">do</span></code> statement creates a new containing scope, which allows errors to be propagated to one or more <code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses.</p>
<p>Here’s an example of how error handling can be used to respond to different error conditions:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">makeASandwich</span>() <span class="k">throws</span> {
</li><li> <span class="c">// ...</span>
</li><li>}
</li><li>
</li><li><span class="k">do</span> {
</li><li> <span class="k">try</span> <span class="nv">makeASandwich</span>()
</li><li> <span class="nv">eatASandwich</span>()
</li><li>} <span class="k">catch</span> <span class="nv">SandwichError</span>.<span class="nv">outOfCleanDishes</span> {
</li><li> <span class="nv">washDishes</span>()
</li><li>} <span class="k">catch</span> <span class="nv">SandwichError</span>.<span class="nv">missingIngredients</span>(<span class="k">let</span> <span class="nv">ingredients</span>) {
</li><li> <span class="nv">buyGroceries</span>(<span class="nv">ingredients</span>)
</li><li>}
</li></ol></div></div></div>
<p>In this example, the <code class="docutils literal notranslate"><span class="pre">makeASandwich()</span></code> function will throw an error if no clean dishes are available or if any ingredients are missing. Because <code class="docutils literal notranslate"><span class="pre">makeASandwich()</span></code> can throw an error, the function call is wrapped in a <code class="docutils literal notranslate"><span class="pre">try</span></code> expression. By wrapping the function call in a <code class="docutils literal notranslate"><span class="pre">do</span></code> statement, any errors that are thrown will be propagated to the provided <code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses.</p>
<p>If no error is thrown, the <code class="docutils literal notranslate"><span class="pre">eatASandwich()</span></code> function is called. If an error is thrown and it matches the <code class="docutils literal notranslate"><span class="pre">SandwichError.outOfCleanDishes</span></code> case, then the <code class="docutils literal notranslate"><span class="pre">washDishes()</span></code> function will be called. If an error is thrown and it matches the <code class="docutils literal notranslate"><span class="pre">SandwichError.missingIngredients</span></code> case, then the <code class="docutils literal notranslate"><span class="pre">buyGroceries(_:)</span></code> function is called with the associated <code class="docutils literal notranslate"><span class="pre">[String]</span></code> value captured by the <code class="docutils literal notranslate"><span class="pre">catch</span></code> pattern.</p>
<p>Throwing, catching, and propagating errors is covered in greater detail in <a class="reference internal" href="ErrorHandling.html"><span class="doc">Error Handling</span></a>.</p>
</div>
<div class="section" id="ID335">
<h2>Assertions and Preconditions<a class="headerlink" href="TheBasics.html#ID335" title="Permalink to this headline">¶</a></h2>
<p><em>Assertions</em> and <em>preconditions</em> are checks that happen at runtime. You use them to make sure an essential condition is satisfied before executing any further code. If the Boolean condition in the assertion or precondition evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>, code execution continues as usual. If the condition evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code>, the current state of the program is invalid; code execution ends, and your app is terminated.</p>
<p>You use assertions and preconditions to express the assumptions you make and the expectations you have while coding, so you can include them as part of your code. Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production.</p>
<p>In addition to verifying your expectations at runtime, assertions and preconditions also become a useful form of documentation within the code. Unlike the error conditions discussed in <a class="reference internal" href="TheBasics.html#ID515"><span class="std std-ref">Error Handling</span></a> above, assertions and preconditions aren’t used for recoverable or expected errors. Because a failed assertion or precondition indicates an invalid program state, there’s no way to catch a failed assertion.</p>
<p>Using assertions and preconditions isn’t a substitute for designing your code in such a way that invalid conditions are unlikely to arise. However, using them to enforce valid data and state causes your app to terminate more predictably if an invalid state occurs, and helps make the problem easier to debug. Stopping execution as soon as an invalid state is detected also helps limit the damage caused by that invalid state.</p>
<p>The difference between assertions and preconditions is in when they’re checked: Assertions are checked only in debug builds, but preconditions are checked in both debug and production builds. In production builds, the condition inside an assertion isn’t evaluated. This means you can use as many assertions as you want during your development process, without impacting performance in production.</p>
<div class="section" id="ID336">
<h3>Debugging with Assertions<a class="headerlink" href="TheBasics.html#ID336" title="Permalink to this headline">¶</a></h3>
<p>You write an assertion by calling the <a class="reference external" href="https://developer.apple.com/documentation/swift/1541112-assert"><code class="docutils literal notranslate"><span class="pre">assert(_:_:file:line:)</span></code></a> function from the Swift standard library. You pass this function an expression that evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code> and a message to display if the result of the condition is <code class="docutils literal notranslate"><span class="pre">false</span></code>. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">age</span> = <span class="m">-3</span>
</li><li><span class="nv">assert</span>(<span class="nv">age</span> &gt;= <span class="m">0</span>, <span class="s">"A person's age can't be less than zero."</span>)
</li><li><span class="c">// This assertion fails because -3 is not &gt;= 0.</span>
</li></ol></div></div></div>
<p>In this example, code execution continues if <code class="docutils literal notranslate"><span class="pre">age</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>, that is, if the value of <code class="docutils literal notranslate"><span class="pre">age</span></code> is nonnegative. If the value of <code class="docutils literal notranslate"><span class="pre">age</span></code> is negative, as in the code above, then <code class="docutils literal notranslate"><span class="pre">age</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code>, and the assertion fails, terminating the application.</p>
<p>You can omit the assertion message—for example, when it would just repeat the condition as prose.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">assert</span>(<span class="nv">age</span> &gt;= <span class="m">0</span>)
</li></ol></div></div></div>
<p>If the code already checks the condition, you use the <a class="reference external" href="https://developer.apple.com/documentation/swift/1539616-assertionfailure"><code class="docutils literal notranslate"><span class="pre">assertionFailure(_:file:line:)</span></code></a> function to indicate that an assertion has failed. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">age</span> &gt; <span class="m">10</span> {
</li><li> <span class="nv">print</span>(<span class="s">"You can ride the roller-coaster or the ferris wheel."</span>)
</li><li>} <span class="k">else</span> <span class="k">if</span> <span class="nv">age</span> &gt;= <span class="m">0</span> {
</li><li> <span class="nv">print</span>(<span class="s">"You can ride the ferris wheel."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">assertionFailure</span>(<span class="s">"A person's age can't be less than zero."</span>)
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID554">
<h3>Enforcing Preconditions<a class="headerlink" href="TheBasics.html#ID554" title="Permalink to this headline">¶</a></h3>
<p>Use a precondition whenever a condition has the potential to be false, but must <em>definitely</em> be true for your code to continue execution. For example, use a precondition to check that a subscript is not out of bounds, or to check that a function has been passed a valid value.</p>
<p>You write a precondition by calling the <a class="reference external" href="https://developer.apple.com/documentation/swift/1540960-precondition"><code class="docutils literal notranslate"><span class="pre">precondition(_:_:file:line:)</span></code></a> function. You pass this function an expression that evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code> and a message to display if the result of the condition is <code class="docutils literal notranslate"><span class="pre">false</span></code>. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// In the implementation of a subscript...</span>
</li><li><span class="nv">precondition</span>(<span class="nv">index</span> &gt; <span class="m">0</span>, <span class="s">"Index must be greater than zero."</span>)
</li></ol></div></div></div>
<p>You can also call the <a class="reference external" href="https://developer.apple.com/documentation/swift/1539374-preconditionfailure"><code class="docutils literal notranslate"><span class="pre">preconditionFailure(_:file:line:)</span></code></a> function to indicate that a failure has occurred—for example, if the default case of a switch was taken, but all valid input data should have been handled by one of the switch’s other cases.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you compile in unchecked mode (<code class="docutils literal notranslate"><span class="pre">-Ounchecked</span></code>), preconditions aren’t checked. The compiler assumes that preconditions are always true, and it optimizes your code accordingly. However, the <code class="docutils literal notranslate"><span class="pre">fatalError(_:file:line:)</span></code> function always halts execution, regardless of optimization settings.</p>
<p class="last">You can use the <code class="docutils literal notranslate"><span class="pre">fatalError(_:file:line:)</span></code> function during prototyping and early development to create stubs for functionality that hasn’t been implemented yet, by writing <code class="docutils literal notranslate"><span class="pre">fatalError("Unimplemented")</span></code> as the stub implementation. Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.</p>
</div>
</div>
</div>
</div><div class="section" id="basic-operators">
<h1>Basic Operators<a class="headerlink" href="BasicOperators.html#basic-operators" title="Permalink to this headline">¶</a></h1>
<p>An <em>operator</em> is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) adds two numbers, as in <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>, and the logical AND operator (<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>) combines two Boolean values, as in <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">enteredDoorCode</span> <span class="pre">&amp;&amp;</span> <span class="pre">passedRetinaScan</span></code>.</p>
<p>Swift supports most standard C operators and improves several capabilities to eliminate common coding errors. The assignment operator (<code class="docutils literal notranslate"><span class="pre">=</span></code>) doesn’t return a value, to prevent it from being mistakenly used when the equal to operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) is intended. Arithmetic operators (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code> and so forth) detect and disallow value overflow, to avoid unexpected results when working with numbers that become larger or smaller than the allowed value range of the type that stores them. You can opt in to value overflow behavior by using Swift’s overflow operators, as described in <a class="reference internal" href="AdvancedOperators.html#ID37"><span class="std std-ref">Overflow Operators</span></a>.</p>
<p>Swift also provides range operators that aren’t found in C, such as <code class="docutils literal notranslate"><span class="pre">a..&lt;b</span></code> and <code class="docutils literal notranslate"><span class="pre">a...b</span></code>, as a shortcut for expressing a range of values.</p>
<p>This chapter describes the common operators in Swift. <a class="reference internal" href="AdvancedOperators.html"><span class="doc">Advanced Operators</span></a> covers Swift’s advanced operators, and describes how to define your own custom operators and implement the standard operators for your own custom types.</p>
<div class="section" id="ID61">
<h2>Terminology<a class="headerlink" href="BasicOperators.html#ID61" title="Permalink to this headline">¶</a></h2>
<p>Operators are unary, binary, or ternary:</p>
<ul class="simple">
<li><em>Unary</em> operators operate on a single target (such as <code class="docutils literal notranslate"><span class="pre">-a</span></code>). Unary <em>prefix</em> operators appear immediately before their target (such as <code class="docutils literal notranslate"><span class="pre">!b</span></code>), and unary <em>postfix</em> operators appear immediately after their target (such as <code class="docutils literal notranslate"><span class="pre">c!</span></code>).</li>
<li><em>Binary</em> operators operate on two targets (such as <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span></code>) and are <em>infix</em> because they appear in between their two targets.</li>
<li><em>Ternary</em> operators operate on three targets. Like C, Swift has only one ternary operator, the ternary conditional operator (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">?</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">c</span></code>).</li>
</ul>
<p>The values that operators affect are <em>operands</em>. In the expression <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>, the <code class="docutils literal notranslate"><span class="pre">+</span></code> symbol is a binary operator and its two operands are the values <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</div>
<div class="section" id="ID62">
<h2>Assignment Operator<a class="headerlink" href="BasicOperators.html#ID62" title="Permalink to this headline">¶</a></h2>
<p>The <em>assignment operator</em> (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code>) initializes or updates the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> with the value of <code class="docutils literal notranslate"><span class="pre">b</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">b</span> = <span class="m">10</span>
</li><li><span class="k">var</span> <span class="nv">a</span> = <span class="m">5</span>
</li><li><span class="nv">a</span> = <span class="nv">b</span>
</li><li><span class="c">// a is now equal to 10</span>
</li></ol></div></div></div>
<p>If the right side of the assignment is a tuple with multiple values, its elements can be decomposed into multiple constants or variables at once:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> (<span class="nv">x</span>, <span class="nv">y</span>) = (<span class="m">1</span>, <span class="m">2</span>)
</li><li><span class="c">// x is equal to 1, and y is equal to 2</span>
</li></ol></div></div></div>
<p>Unlike the assignment operator in C and Objective-C, the assignment operator in Swift does not itself return a value. The following statement is not valid:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">x</span> = <span class="nv">y</span> {
</li><li> <span class="c">// This is not valid, because x = y does not return a value.</span>
</li><li>}
</li></ol></div></div></div>
<p>This feature prevents the assignment operator (<code class="docutils literal notranslate"><span class="pre">=</span></code>) from being used by accident when the equal to operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) is actually intended. By making <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code> invalid, Swift helps you to avoid these kinds of errors in your code.</p>
</div>
<div class="section" id="ID63">
<h2>Arithmetic Operators<a class="headerlink" href="BasicOperators.html#ID63" title="Permalink to this headline">¶</a></h2>
<p>Swift supports the four standard <em>arithmetic operators</em> for all number types:</p>
<ul class="simple">
<li>Addition (<code class="docutils literal notranslate"><span class="pre">+</span></code>)</li>
<li>Subtraction (<code class="docutils literal notranslate"><span class="pre">-</span></code>)</li>
<li>Multiplication (<code class="docutils literal notranslate"><span class="pre">*</span></code>)</li>
<li>Division (<code class="docutils literal notranslate"><span class="pre">/</span></code>)</li>
</ul>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">1</span> + <span class="m">2</span> <span class="c">// equals 3</span>
</li><li><span class="m">5</span> - <span class="m">3</span> <span class="c">// equals 2</span>
</li><li><span class="m">2</span> * <span class="m">3</span> <span class="c">// equals 6</span>
</li><li><span class="m">10.0</span> / <span class="m">2.5</span> <span class="c">// equals 4.0</span>
</li></ol></div></div></div>
<p>Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators don’t allow values to overflow by default. You can opt in to value overflow behavior by using Swift’s overflow operators (such as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;+</span> <span class="pre">b</span></code>). See <a class="reference internal" href="AdvancedOperators.html#ID37"><span class="std std-ref">Overflow Operators</span></a>.</p>
<p>The addition operator is also supported for <code class="docutils literal notranslate"><span class="pre">String</span></code> concatenation:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="s">"hello, "</span> + <span class="s">"world"</span> <span class="c">// equals "hello, world"</span>
</li></ol></div></div></div>
<div class="section" id="ID64">
<h3>Remainder Operator<a class="headerlink" href="BasicOperators.html#ID64" title="Permalink to this headline">¶</a></h3>
<p>The <em>remainder operator</em> (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>) works out how many multiples of <code class="docutils literal notranslate"><span class="pre">b</span></code> will fit inside <code class="docutils literal notranslate"><span class="pre">a</span></code> and returns the value that is left over (known as the <em>remainder</em>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The remainder operator (<code class="docutils literal notranslate"><span class="pre">%</span></code>) is also known as a <em>modulo operator</em> in other languages. However, its behavior in Swift for negative numbers means that, strictly speaking, it’s a remainder rather than a modulo operation.</p>
</div>
<p>Here’s how the remainder operator works. To calculate <code class="docutils literal notranslate"><span class="pre">9</span> <span class="pre">%</span> <span class="pre">4</span></code>, you first work out how many <code class="docutils literal notranslate"><span class="pre">4</span></code>s will fit inside <code class="docutils literal notranslate"><span class="pre">9</span></code>:</p>
<img alt="../_images/remainderInteger_2x.png" class="align-center" src="../_images/remainderInteger_2x.png" style="width: 337px;"/>
<p>You can fit two <code class="docutils literal notranslate"><span class="pre">4</span></code>s inside <code class="docutils literal notranslate"><span class="pre">9</span></code>, and the remainder is <code class="docutils literal notranslate"><span class="pre">1</span></code> (shown in orange).</p>
<p>In Swift, this would be written as:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">9</span> % <span class="m">4</span> <span class="c">// equals 1</span>
</li></ol></div></div></div>
<p>To determine the answer for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>, the <code class="docutils literal notranslate"><span class="pre">%</span></code> operator calculates the following equation and returns <code class="docutils literal notranslate"><span class="pre">remainder</span></code> as its output:</p>
<p><code class="docutils literal notranslate"><span class="pre">a</span></code> = (<code class="docutils literal notranslate"><span class="pre">b</span></code> x <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">multiplier</span></code>) + <code class="docutils literal notranslate"><span class="pre">remainder</span></code></p>
<p>where <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">multiplier</span></code> is the largest number of multiples of <code class="docutils literal notranslate"><span class="pre">b</span></code> that will fit inside <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Inserting <code class="docutils literal notranslate"><span class="pre">9</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code> into this equation yields:</p>
<p><code class="docutils literal notranslate"><span class="pre">9</span></code> = (<code class="docutils literal notranslate"><span class="pre">4</span></code> x <code class="docutils literal notranslate"><span class="pre">2</span></code>) + <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<p>The same method is applied when calculating the remainder for a negative value of <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">-9</span> % <span class="m">4</span> <span class="c">// equals -1</span>
</li></ol></div></div></div>
<p>Inserting <code class="docutils literal notranslate"><span class="pre">-9</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code> into the equation yields:</p>
<p><code class="docutils literal notranslate"><span class="pre">-9</span></code> = (<code class="docutils literal notranslate"><span class="pre">4</span></code> x <code class="docutils literal notranslate"><span class="pre">-2</span></code>) + <code class="docutils literal notranslate"><span class="pre">-1</span></code></p>
<p>giving a remainder value of <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<p>The sign of <code class="docutils literal notranslate"><span class="pre">b</span></code> is ignored for negative values of <code class="docutils literal notranslate"><span class="pre">b</span></code>. This means that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">-b</span></code> always give the same answer.</p>
</div>
<div class="section" id="ID67">
<h3>Unary Minus Operator<a class="headerlink" href="BasicOperators.html#ID67" title="Permalink to this headline">¶</a></h3>
<p>The sign of a numeric value can be toggled using a prefixed <code class="docutils literal notranslate"><span class="pre">-</span></code>, known as the <em>unary minus operator</em>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">three</span> = <span class="m">3</span>
</li><li><span class="k">let</span> <span class="nv">minusThree</span> = -<span class="nv">three</span> <span class="c">// minusThree equals -3</span>
</li><li><span class="k">let</span> <span class="nv">plusThree</span> = -<span class="nv">minusThree</span> <span class="c">// plusThree equals 3, or "minus minus three"</span>
</li></ol></div></div></div>
<p>The unary minus operator (<code class="docutils literal notranslate"><span class="pre">-</span></code>) is prepended directly before the value it operates on, without any white space.</p>
</div>
<div class="section" id="ID68">
<h3>Unary Plus Operator<a class="headerlink" href="BasicOperators.html#ID68" title="Permalink to this headline">¶</a></h3>
<p>The <em>unary plus operator</em> (<code class="docutils literal notranslate"><span class="pre">+</span></code>) simply returns the value it operates on, without any change:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">minusSix</span> = <span class="m">-6</span>
</li><li><span class="k">let</span> <span class="nv">alsoMinusSix</span> = +<span class="nv">minusSix</span> <span class="c">// alsoMinusSix equals -6</span>
</li></ol></div></div></div>
<p>Although the unary plus operator doesn’t actually do anything, you can use it to provide symmetry in your code for positive numbers when also using the unary minus operator for negative numbers.</p>
</div>
</div>
<div class="section" id="ID69">
<h2>Compound Assignment Operators<a class="headerlink" href="BasicOperators.html#ID69" title="Permalink to this headline">¶</a></h2>
<p>Like C, Swift provides <em>compound assignment operators</em> that combine assignment (<code class="docutils literal notranslate"><span class="pre">=</span></code>) with another operation. One example is the <em>addition assignment operator</em> (<code class="docutils literal notranslate"><span class="pre">+=</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">a</span> = <span class="m">1</span>
</li><li><span class="nv">a</span> += <span class="m">2</span>
</li><li><span class="c">// a is now equal to 3</span>
</li></ol></div></div></div>
<p>The expression <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">2</span></code>. Effectively, the addition and the assignment are combined into one operator that performs both tasks at the same time.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The compound assignment operators don’t return a value. For example, you can’t write <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code>.</p>
</div>
<p>For information about the operators provided by the Swift standard library, see <a class="reference external" href="https://developer.apple.com/documentation/swift/operator_declarations">Operator Declarations</a>.</p>
</div>
<div class="section" id="ID70">
<h2>Comparison Operators<a class="headerlink" href="BasicOperators.html#ID70" title="Permalink to this headline">¶</a></h2>
<p>Swift supports all standard C <em>comparison operators</em>:</p>
<ul class="simple">
<li>Equal to (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code>)</li>
<li>Not equal to (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code>)</li>
<li>Greater than (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code>)</li>
<li>Less than (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code>)</li>
<li>Greater than or equal to (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code>)</li>
<li>Less than or equal to (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code>)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Swift also provides two <em>identity operators</em> (<code class="docutils literal notranslate"><span class="pre">===</span></code> and <code class="docutils literal notranslate"><span class="pre">!==</span></code>), which you use to test whether two object references both refer to the same object instance. For more information, see <a class="reference internal" href="ClassesAndStructures.html"><span class="doc">Structures and Classes</span></a>.</p>
</div>
<p>Each of the comparison operators returns a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value to indicate whether or not the statement is true:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">1</span> == <span class="m">1</span> <span class="c">// true because 1 is equal to 1</span>
</li><li><span class="m">2</span> != <span class="m">1</span> <span class="c">// true because 2 is not equal to 1</span>
</li><li><span class="m">2</span> &gt; <span class="m">1</span> <span class="c">// true because 2 is greater than 1</span>
</li><li><span class="m">1</span> &lt; <span class="m">2</span> <span class="c">// true because 1 is less than 2</span>
</li><li><span class="m">1</span> &gt;= <span class="m">1</span> <span class="c">// true because 1 is greater than or equal to 1</span>
</li><li><span class="m">2</span> &lt;= <span class="m">1</span> <span class="c">// false because 2 is not less than or equal to 1</span>
</li></ol></div></div></div>
<p>Comparison operators are often used in conditional statements, such as the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">name</span> = <span class="s">"world"</span>
</li><li><span class="k">if</span> <span class="nv">name</span> == <span class="s">"world"</span> {
</li><li> <span class="nv">print</span>(<span class="s">"hello, world"</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"I'm sorry </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">, but I don't recognize you"</span>)
</li><li>}
</li><li><span class="c">// Prints "hello, world", because name is indeed equal to "world".</span>
</li></ol></div></div></div>
<p>For more about the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, see <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>.</p>
<p>You can compare two tuples if they have the same type and the same number of values. Tuples are compared from left to right, one value at a time, until the comparison finds two values that aren’t equal. Those two values are compared, and the result of that comparison determines the overall result of the tuple comparison. If all the elements are equal, then the tuples themselves are equal. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>(<span class="m">1</span>, <span class="s">"zebra"</span>) &lt; (<span class="m">2</span>, <span class="s">"apple"</span>)   <span class="c">// true because 1 is less than 2; "zebra" and "apple" are not compared</span>
</li><li>(<span class="m">3</span>, <span class="s">"apple"</span>) &lt; (<span class="m">3</span>, <span class="s">"bird"</span>)    <span class="c">// true because 3 is equal to 3, and "apple" is less than "bird"</span>
</li><li>(<span class="m">4</span>, <span class="s">"dog"</span>) == (<span class="m">4</span>, <span class="s">"dog"</span>)      <span class="c">// true because 4 is equal to 4, and "dog" is equal to "dog"</span>
</li></ol></div></div></div>
<p>In the example above, you can see the left-to-right comparison behavior on the first line. Because <code class="docutils literal notranslate"><span class="pre">1</span></code> is less than <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">"zebra")</span></code> is considered less than <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">"apple")</span></code>, regardless of any other values in the tuples. It doesn’t matter that <code class="docutils literal notranslate"><span class="pre">"zebra"</span></code> isn’t less than <code class="docutils literal notranslate"><span class="pre">"apple"</span></code>, because the comparison is already determined by the tuples’ first elements. However, when the tuples’ first elements are the same, their second elements <em>are</em> compared—this is what happens on the second and third line.</p>
<p>Tuples can be compared with a given operator only if the operator can be applied to each value in the respective tuples. For example, as demonstrated in the code below, you can compare two tuples of type <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">Int)</span></code> because both <code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Int</span></code> values can be compared using the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator. In contrast, two tuples of type <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">Bool)</span></code> can’t be compared with the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator because the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator can’t be applied to <code class="docutils literal notranslate"><span class="pre">Bool</span></code> values.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>(<span class="s">"blue"</span>, <span class="m">-1</span>) &lt; (<span class="s">"purple"</span>, <span class="m">1</span>)        <span class="c">// OK, evaluates to true</span>
</li><li>(<span class="s">"blue"</span>, <span class="k">false</span>) &lt; (<span class="s">"purple"</span>, <span class="k">true</span>)  <span class="c">// Error because &lt; can't compare Boolean values</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements. To compare tuples with seven or more elements, you must implement the comparison operators yourself.</p>
</div>
</div>
<div class="section" id="ID71">
<h2>Ternary Conditional Operator<a class="headerlink" href="BasicOperators.html#ID71" title="Permalink to this headline">¶</a></h2>
<p>The <em>ternary conditional operator</em> is a special operator with three parts, which takes the form <code class="docutils literal notranslate"><span class="pre">question</span> <span class="pre">?</span> <span class="pre">answer1</span> <span class="pre">:</span> <span class="pre">answer2</span></code>. It’s a shortcut for evaluating one of two expressions based on whether <code class="docutils literal notranslate"><span class="pre">question</span></code> is true or false. If <code class="docutils literal notranslate"><span class="pre">question</span></code> is true, it evaluates <code class="docutils literal notranslate"><span class="pre">answer1</span></code> and returns its value; otherwise, it evaluates <code class="docutils literal notranslate"><span class="pre">answer2</span></code> and returns its value.</p>
<p>The ternary conditional operator is shorthand for the code below:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">question</span> {
</li><li> <span class="nv">answer1</span>
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">answer2</span>
</li><li>}
</li></ol></div></div></div>
<p>Here’s an example, which calculates the height for a table row. The row height should be 50 points taller than the content height if the row has a header, and 20 points taller if the row doesn’t have a header:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">contentHeight</span> = <span class="m">40</span>
</li><li><span class="k">let</span> <span class="nv">hasHeader</span> = <span class="k">true</span>
</li><li><span class="k">let</span> <span class="nv">rowHeight</span> = <span class="nv">contentHeight</span> + (<span class="nv">hasHeader</span> ? <span class="m">50</span> : <span class="m">20</span>)
</li><li><span class="c">// rowHeight is equal to 90</span>
</li></ol></div></div></div>
<p>The example above is shorthand for the code below:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">contentHeight</span> = <span class="m">40</span>
</li><li><span class="k">let</span> <span class="nv">hasHeader</span> = <span class="k">true</span>
</li><li><span class="k">let</span> <span class="nv">rowHeight</span>: <span class="nc">Int</span>
</li><li><span class="k">if</span> <span class="nv">hasHeader</span> {
</li><li> <span class="nv">rowHeight</span> = <span class="nv">contentHeight</span> + <span class="m">50</span>
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">rowHeight</span> = <span class="nv">contentHeight</span> + <span class="m">20</span>
</li><li>}
</li><li><span class="c">// rowHeight is equal to 90</span>
</li></ol></div></div></div>
<p>The first example’s use of the ternary conditional operator means that <code class="docutils literal notranslate"><span class="pre">rowHeight</span></code> can be set to the correct value on a single line of code, which is more concise than the code used in the second example.</p>
<p>The ternary conditional operator provides an efficient shorthand for deciding which of two expressions to consider. Use the ternary conditional operator with care, however. Its conciseness can lead to hard-to-read code if overused. Avoid combining multiple instances of the ternary conditional operator into one compound statement.</p>
</div>
<div class="section" id="ID72">
<h2>Nil-Coalescing Operator<a class="headerlink" href="BasicOperators.html#ID72" title="Permalink to this headline">¶</a></h2>
<p>The <em>nil-coalescing operator</em> (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">??</span> <span class="pre">b</span></code>) unwraps an optional <code class="docutils literal notranslate"><span class="pre">a</span></code> if it contains a value, or returns a default value <code class="docutils literal notranslate"><span class="pre">b</span></code> if <code class="docutils literal notranslate"><span class="pre">a</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The expression <code class="docutils literal notranslate"><span class="pre">a</span></code> is always of an optional type. The expression <code class="docutils literal notranslate"><span class="pre">b</span></code> must match the type that is stored inside <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>The nil-coalescing operator is shorthand for the code below:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">a</span> != <span class="k">nil</span> ? <span class="nv">a</span>! : <span class="nv">b</span>
</li></ol></div></div></div>
<p>The code above uses the ternary conditional operator and forced unwrapping (<code class="docutils literal notranslate"><span class="pre">a!</span></code>) to access the value wrapped inside <code class="docutils literal notranslate"><span class="pre">a</span></code> when <code class="docutils literal notranslate"><span class="pre">a</span></code> is not <code class="docutils literal notranslate"><span class="pre">nil</span></code>, and to return <code class="docutils literal notranslate"><span class="pre">b</span></code> otherwise. The nil-coalescing operator provides a more elegant way to encapsulate this conditional checking and unwrapping in a concise and readable form.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> is non-<code class="docutils literal notranslate"><span class="pre">nil</span></code>, the value of <code class="docutils literal notranslate"><span class="pre">b</span></code> is not evaluated. This is known as <em>short-circuit evaluation</em>.</p>
</div>
<p>The example below uses the nil-coalescing operator to choose between a default color name and an optional user-defined color name:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">defaultColorName</span> = <span class="s">"red"</span>
</li><li><span class="k">var</span> <span class="nv">userDefinedColorName</span>: <span class="nc">String</span>?   <span class="c">// defaults to nil</span>
</li><li>
</li><li><span class="k">var</span> <span class="nv">colorNameToUse</span> = <span class="nv">userDefinedColorName</span> ?? <span class="nv">defaultColorName</span>
</li><li><span class="c">// userDefinedColorName is nil, so colorNameToUse is set to the default of "red"</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code> variable is defined as an optional <code class="docutils literal notranslate"><span class="pre">String</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Because <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code> is of an optional type, you can use the nil-coalescing operator to consider its value. In the example above, the operator is used to determine an initial value for a <code class="docutils literal notranslate"><span class="pre">String</span></code> variable called <code class="docutils literal notranslate"><span class="pre">colorNameToUse</span></code>. Because <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span> <span class="pre">??</span> <span class="pre">defaultColorName</span></code> returns the value of <code class="docutils literal notranslate"><span class="pre">defaultColorName</span></code>, or <code class="docutils literal notranslate"><span class="pre">"red"</span></code>.</p>
<p>If you assign a non-<code class="docutils literal notranslate"><span class="pre">nil</span></code> value to <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code> and perform the nil-coalescing operator check again, the value wrapped inside <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code> is used instead of the default:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">userDefinedColorName</span> = <span class="s">"green"</span>
</li><li><span class="nv">colorNameToUse</span> = <span class="nv">userDefinedColorName</span> ?? <span class="nv">defaultColorName</span>
</li><li><span class="c">// userDefinedColorName is not nil, so colorNameToUse is set to "green"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID73">
<h2>Range Operators<a class="headerlink" href="BasicOperators.html#ID73" title="Permalink to this headline">¶</a></h2>
<p>Swift includes several <em>range operators</em>, which are shortcuts for expressing a range of values.</p>
<div class="section" id="ID74">
<h3>Closed Range Operator<a class="headerlink" href="BasicOperators.html#ID74" title="Permalink to this headline">¶</a></h3>
<p>The <em>closed range operator</em> (<code class="docutils literal notranslate"><span class="pre">a...b</span></code>) defines a range that runs from <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">b</span></code>, and includes the values <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. The value of <code class="docutils literal notranslate"><span class="pre">a</span></code> must not be greater than <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>The closed range operator is useful when iterating over a range in which you want all of the values to be used, such as with a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">5</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">index</span><span class="p">)</span><span class="s"> times 5 is </span>\<span class="p">(</span><span class="nv">index</span> * <span class="m">5</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// 1 times 5 is 5</span>
</li><li><span class="c">// 2 times 5 is 10</span>
</li><li><span class="c">// 3 times 5 is 15</span>
</li><li><span class="c">// 4 times 5 is 20</span>
</li><li><span class="c">// 5 times 5 is 25</span>
</li></ol></div></div></div>
<p>For more about <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loops, see <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>.</p>
</div>
<div class="section" id="ID75">
<h3>Half-Open Range Operator<a class="headerlink" href="BasicOperators.html#ID75" title="Permalink to this headline">¶</a></h3>
<p>The <em>half-open range operator</em> (<code class="docutils literal notranslate"><span class="pre">a..&lt;b</span></code>) defines a range that runs from <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">b</span></code>, but doesn’t include <code class="docutils literal notranslate"><span class="pre">b</span></code>. It’s said to be <em>half-open</em> because it contains its first value, but not its final value. As with the closed range operator, the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> must not be greater than <code class="docutils literal notranslate"><span class="pre">b</span></code>. If the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">b</span></code>, then the resulting range will be empty.</p>
<p>Half-open ranges are particularly useful when you work with zero-based lists such as arrays, where it’s useful to count up to (but not including) the length of the list:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">names</span> = [<span class="s">"Anna"</span>, <span class="s">"Alex"</span>, <span class="s">"Brian"</span>, <span class="s">"Jack"</span>]
</li><li><span class="k">let</span> <span class="nv">count</span> = <span class="nv">names</span>.<span class="nv">count</span>
</li><li><span class="k">for</span> <span class="nv">i</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="nv">count</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Person </span>\<span class="p">(</span><span class="nv">i</span> + <span class="m">1</span><span class="p">)</span><span class="s"> is called </span>\<span class="p">(</span><span class="nv">names</span>[<span class="nv">i</span>]<span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Person 1 is called Anna</span>
</li><li><span class="c">// Person 2 is called Alex</span>
</li><li><span class="c">// Person 3 is called Brian</span>
</li><li><span class="c">// Person 4 is called Jack</span>
</li></ol></div></div></div>
<p>Note that the array contains four items, but <code class="docutils literal notranslate"><span class="pre">0..&lt;count</span></code> only counts as far as <code class="docutils literal notranslate"><span class="pre">3</span></code> (the index of the last item in the array), because it’s a half-open range. For more about arrays, see <a class="reference internal" href="CollectionTypes.html#ID107"><span class="std std-ref">Arrays</span></a>.</p>
</div>
<div class="section" id="ID562">
<h3>One-Sided Ranges<a class="headerlink" href="BasicOperators.html#ID562" title="Permalink to this headline">¶</a></h3>
<p>The closed range operator has an alternative form for ranges that continue as far as possible in one direction—for example, a range that includes all the elements of an array from index 2 to the end of the array. In these cases, you can omit the value from one side of the range operator. This kind of range is called a <em>one-sided range</em> because the operator has a value on only one side. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">name</span> <span class="k">in</span> <span class="nv">names</span>[<span class="m">2</span>...] {
</li><li> <span class="nv">print</span>(<span class="nv">name</span>)
</li><li>}
</li><li><span class="c">// Brian</span>
</li><li><span class="c">// Jack</span>
</li><li>
</li><li><span class="k">for</span> <span class="nv">name</span> <span class="k">in</span> <span class="nv">names</span>[...<span class="m">2</span>] {
</li><li> <span class="nv">print</span>(<span class="nv">name</span>)
</li><li>}
</li><li><span class="c">// Anna</span>
</li><li><span class="c">// Alex</span>
</li><li><span class="c">// Brian</span>
</li></ol></div></div></div>
<p>The half-open range operator also has a one-sided form that’s written with only its final value. Just like when you include a value on both sides, the final value isn’t part of the range. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">name</span> <span class="k">in</span> <span class="nv">names</span>[..&lt;<span class="m">2</span>] {
</li><li> <span class="nv">print</span>(<span class="nv">name</span>)
</li><li>}
</li><li><span class="c">// Anna</span>
</li><li><span class="c">// Alex</span>
</li></ol></div></div></div>
<p>One-sided ranges can be used in other contexts, not just in subscripts. You can’t iterate over a one-sided range that omits a first value, because it isn’t clear where iteration should begin. You <em>can</em> iterate over a one-sided range that omits its final value; however, because the range continues indefinitely, make sure you add an explicit end condition for the loop. You can also check whether a one-sided range contains a particular value, as shown in the code below.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">range</span> = ...<span class="m">5</span>
</li><li><span class="nv">range</span>.<span class="nv">contains</span>(<span class="m">7</span>)   <span class="c">// false</span>
</li><li><span class="nv">range</span>.<span class="nv">contains</span>(<span class="m">4</span>)   <span class="c">// true</span>
</li><li><span class="nv">range</span>.<span class="nv">contains</span>(<span class="m">-1</span>)  <span class="c">// true</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID76">
<h2>Logical Operators<a class="headerlink" href="BasicOperators.html#ID76" title="Permalink to this headline">¶</a></h2>
<p><em>Logical operators</em> modify or combine the Boolean logic values <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>. Swift supports the three standard logical operators found in C-based languages:</p>
<ul class="simple">
<li>Logical NOT (<code class="docutils literal notranslate"><span class="pre">!a</span></code>)</li>
<li>Logical AND (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span></code>)</li>
<li>Logical OR (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">||</span> <span class="pre">b</span></code>)</li>
</ul>
<div class="section" id="ID77">
<h3>Logical NOT Operator<a class="headerlink" href="BasicOperators.html#ID77" title="Permalink to this headline">¶</a></h3>
<p>The <em>logical NOT operator</em> (<code class="docutils literal notranslate"><span class="pre">!a</span></code>) inverts a Boolean value so that <code class="docutils literal notranslate"><span class="pre">true</span></code> becomes <code class="docutils literal notranslate"><span class="pre">false</span></code>, and <code class="docutils literal notranslate"><span class="pre">false</span></code> becomes <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>The logical NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space. It can be read as “not <code class="docutils literal notranslate"><span class="pre">a</span></code>”, as seen in the following example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">allowedEntry</span> = <span class="k">false</span>
</li><li><span class="k">if</span> !<span class="nv">allowedEntry</span> {
</li><li> <span class="nv">print</span>(<span class="s">"ACCESS DENIED"</span>)
</li><li>}
</li><li><span class="c">// Prints "ACCESS DENIED"</span>
</li></ol></div></div></div>
<p>The phrase <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">!allowedEntry</span></code> can be read as “if not allowed entry.” The subsequent line is only executed if “not allowed entry” is true; that is, if <code class="docutils literal notranslate"><span class="pre">allowedEntry</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>As in this example, careful choice of Boolean constant and variable names can help to keep code readable and concise, while avoiding double negatives or confusing logic statements.</p>
</div>
<div class="section" id="ID78">
<h3>Logical AND Operator<a class="headerlink" href="BasicOperators.html#ID78" title="Permalink to this headline">¶</a></h3>
<p>The <em>logical AND operator</em> (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span></code>) creates logical expressions where both values must be <code class="docutils literal notranslate"><span class="pre">true</span></code> for the overall expression to also be <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>If either value is <code class="docutils literal notranslate"><span class="pre">false</span></code>, the overall expression will also be <code class="docutils literal notranslate"><span class="pre">false</span></code>. In fact, if the <em>first</em> value is <code class="docutils literal notranslate"><span class="pre">false</span></code>, the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to <code class="docutils literal notranslate"><span class="pre">true</span></code>. This is known as <em>short-circuit evaluation</em>.</p>
<p>This example considers two <code class="docutils literal notranslate"><span class="pre">Bool</span></code> values and only allows access if both values are <code class="docutils literal notranslate"><span class="pre">true</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">enteredDoorCode</span> = <span class="k">true</span>
</li><li><span class="k">let</span> <span class="nv">passedRetinaScan</span> = <span class="k">false</span>
</li><li><span class="k">if</span> <span class="nv">enteredDoorCode</span> &amp;&amp; <span class="nv">passedRetinaScan</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Welcome!"</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"ACCESS DENIED"</span>)
</li><li>}
</li><li><span class="c">// Prints "ACCESS DENIED"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID79">
<h3>Logical OR Operator<a class="headerlink" href="BasicOperators.html#ID79" title="Permalink to this headline">¶</a></h3>
<p>The <em>logical OR operator</em> (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">||</span> <span class="pre">b</span></code>) is an infix operator made from two adjacent pipe characters. You use it to create logical expressions in which only <em>one</em> of the two values has to be <code class="docutils literal notranslate"><span class="pre">true</span></code> for the overall expression to be <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Like the Logical AND operator above, the Logical OR operator uses short-circuit evaluation to consider its expressions. If the left side of a Logical OR expression is <code class="docutils literal notranslate"><span class="pre">true</span></code>, the right side is not evaluated, because it can’t change the outcome of the overall expression.</p>
<p>In the example below, the first <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value (<code class="docutils literal notranslate"><span class="pre">hasDoorKey</span></code>) is <code class="docutils literal notranslate"><span class="pre">false</span></code>, but the second value (<code class="docutils literal notranslate"><span class="pre">knowsOverridePassword</span></code>) is <code class="docutils literal notranslate"><span class="pre">true</span></code>. Because one value is <code class="docutils literal notranslate"><span class="pre">true</span></code>, the overall expression also evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>, and access is allowed:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">hasDoorKey</span> = <span class="k">false</span>
</li><li><span class="k">let</span> <span class="nv">knowsOverridePassword</span> = <span class="k">true</span>
</li><li><span class="k">if</span> <span class="nv">hasDoorKey</span> || <span class="nv">knowsOverridePassword</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Welcome!"</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"ACCESS DENIED"</span>)
</li><li>}
</li><li><span class="c">// Prints "Welcome!"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID80">
<h3>Combining Logical Operators<a class="headerlink" href="BasicOperators.html#ID80" title="Permalink to this headline">¶</a></h3>
<p>You can combine multiple logical operators to create longer compound expressions:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">enteredDoorCode</span> &amp;&amp; <span class="nv">passedRetinaScan</span> || <span class="nv">hasDoorKey</span> || <span class="nv">knowsOverridePassword</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Welcome!"</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"ACCESS DENIED"</span>)
</li><li>}
</li><li><span class="c">// Prints "Welcome!"</span>
</li></ol></div></div></div>
<p>This example uses multiple <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">||</span></code> operators to create a longer compound expression. However, the <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">||</span></code> operators still operate on only two values, so this is actually three smaller expressions chained together. The example can be read as:</p>
<p>If we’ve entered the correct door code and passed the retina scan, or if we have a valid door key, or if we know the emergency override password, then allow access.</p>
<p>Based on the values of <code class="docutils literal notranslate"><span class="pre">enteredDoorCode</span></code>, <code class="docutils literal notranslate"><span class="pre">passedRetinaScan</span></code>, and <code class="docutils literal notranslate"><span class="pre">hasDoorKey</span></code>, the first two subexpressions are <code class="docutils literal notranslate"><span class="pre">false</span></code>. However, the emergency override password is known, so the overall compound expression still evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The Swift logical operators <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">||</span></code> are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.</p>
</div>
</div>
<div class="section" id="ID81">
<h3>Explicit Parentheses<a class="headerlink" href="BasicOperators.html#ID81" title="Permalink to this headline">¶</a></h3>
<p>It’s sometimes useful to include parentheses when they’re not strictly needed, to make the intention of a complex expression easier to read. In the door access example above, it’s useful to add parentheses around the first part of the compound expression to make its intent explicit:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> (<span class="nv">enteredDoorCode</span> &amp;&amp; <span class="nv">passedRetinaScan</span>) || <span class="nv">hasDoorKey</span> || <span class="nv">knowsOverridePassword</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Welcome!"</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"ACCESS DENIED"</span>)
</li><li>}
</li><li><span class="c">// Prints "Welcome!"</span>
</li></ol></div></div></div>
<p>The parentheses make it clear that the first two values are considered as part of a separate possible state in the overall logic. The output of the compound expression doesn’t change, but the overall intention is clearer to the reader. Readability is always preferred over brevity; use parentheses where they help to make your intentions clear.</p>
</div>
</div>
</div><div class="section" id="strings-and-characters">
<h1>Strings and Characters<a class="headerlink" href="StringsAndCharacters.html#strings-and-characters" title="Permalink to this headline">¶</a></h1>
<p>A <em>string</em> is a series of characters, such as <code class="docutils literal notranslate"><span class="pre">"hello,</span> <span class="pre">world"</span></code> or <code class="docutils literal notranslate"><span class="pre">"albatross"</span></code>. Swift strings are represented by the <code class="docutils literal notranslate"><span class="pre">String</span></code> type. The contents of a <code class="docutils literal notranslate"><span class="pre">String</span></code> can be accessed in various ways, including as a collection of <code class="docutils literal notranslate"><span class="pre">Character</span></code> values.</p>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Character</span></code> types provide a fast, Unicode-compliant way to work with text in your code. The syntax for string creation and manipulation is lightweight and readable, with a string literal syntax that is similar to C. String concatenation is as simple as combining two strings with the <code class="docutils literal notranslate"><span class="pre">+</span></code> operator, and string mutability is managed by choosing between a constant or a variable, just like any other value in Swift. You can also use strings to insert constants, variables, literals, and expressions into longer strings, in a process known as string interpolation. This makes it easy to create custom string values for display, storage, and printing.</p>
<p>Despite this simplicity of syntax, Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> type is a fast, modern string implementation. Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> type is bridged with Foundation’s <code class="docutils literal notranslate"><span class="pre">NSString</span></code> class. Foundation also extends <code class="docutils literal notranslate"><span class="pre">String</span></code> to expose methods defined by <code class="docutils literal notranslate"><span class="pre">NSString</span></code>. This means, if you import Foundation, you can access those <code class="docutils literal notranslate"><span class="pre">NSString</span></code> methods on <code class="docutils literal notranslate"><span class="pre">String</span></code> without casting.</p>
<p class="last">For more information about using <code class="docutils literal notranslate"><span class="pre">String</span></code> with Foundation and Cocoa, see <a class="reference external" href="https://developer.apple.com/documentation/swift/string#2919514">Bridging Between String and NSString</a>.</p>
</div>
<div class="section" id="ID286">
<h2>String Literals<a class="headerlink" href="StringsAndCharacters.html#ID286" title="Permalink to this headline">¶</a></h2>
<p>You can include predefined <code class="docutils literal notranslate"><span class="pre">String</span></code> values within your code as <em>string literals</em>. A string literal is a sequence of characters surrounded by double quotation marks (<code class="docutils literal notranslate"><span class="pre">"</span></code>).</p>
<p>Use a string literal as an initial value for a constant or variable:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someString</span> = <span class="s">"Some string literal value"</span>
</li></ol></div></div></div>
<p>Note that Swift infers a type of <code class="docutils literal notranslate"><span class="pre">String</span></code> for the <code class="docutils literal notranslate"><span class="pre">someString</span></code> constant because it’s initialized with a string literal value.</p>
<div class="section" id="ID564">
<h3>Multiline String Literals<a class="headerlink" href="StringsAndCharacters.html#ID564" title="Permalink to this headline">¶</a></h3>
<p>If you need a string that spans several lines, use a multiline string literal—a sequence of characters surrounded by three double quotation marks:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">quotation</span> = <span class="s">"""</span>
</li><li><span class="s">The White Rabbit put on his spectacles.  "Where shall I begin,</span>
</li><li><span class="s">please your Majesty?" he asked.</span>
</li><li>
</li><li><span class="s">"Begin at the beginning," the King said gravely, "and go on</span>
</li><li><span class="s">till you come to the end; then stop."</span>
</li><li><span class="s">"""</span>
</li></ol></div></div></div>
<p>A multiline string literal includes all of the lines between its opening and closing quotation marks. The string begins on the first line after the opening quotation marks (<code class="docutils literal notranslate"><span class="pre">"""</span></code>) and ends on the line before the closing quotation marks, which means that neither of the strings below start or end with a line break:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">singleLineString</span> = <span class="s">"These are the same."</span>
</li><li><span class="k">let</span> <span class="nv">multilineString</span> = <span class="s">"""</span>
</li><li><span class="s">These are the same.</span>
</li><li><span class="s">"""</span>
</li></ol></div></div></div>
<p>When your source code includes a line break inside of a multiline string literal, that line break also appears in the string’s value. If you want to use line breaks to make your source code easier to read, but you don’t want the line breaks to be part of the string’s value, write a backslash (<code class="docutils literal notranslate"><span class="pre">\</span></code>) at the end of those lines:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">softWrappedQuotation</span> = <span class="s">"""</span>
</li><li><span class="s">The White Rabbit put on his spectacles.  "Where shall I begin, \</span>
</li><li><span class="s">please your Majesty?" he asked.</span>
</li><li>
</li><li><span class="s">"Begin at the beginning," the King said gravely, "and go on \</span>
</li><li><span class="s">till you come to the end; then stop."</span>
</li><li><span class="s">"""</span>
</li></ol></div></div></div>
<p>To make a multiline string literal that begins or ends with a line feed, write a blank line as the first or last line. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">lineBreaks</span> = <span class="s">"""</span>
</li><li>
</li><li><span class="s">This string starts with a line break.</span>
</li><li><span class="s">It also ends with a line break.</span>
</li><li>
</li><li><span class="s">"""</span>
</li></ol></div></div></div>
<p>A multiline string can be indented to match the surrounding code. The whitespace before the closing quotation marks (<code class="docutils literal notranslate"><span class="pre">"""</span></code>) tells Swift what whitespace to ignore before all of the other lines. However, if you write whitespace at the beginning of a line in addition to what’s before the closing quotation marks, that whitespace <em>is</em> included.</p>
<img alt="../_images/multilineStringWhitespace_2x.png" class="align-center" src="../_images/multilineStringWhitespace_2x.png" style="width: 478px;"/>
<p>In the example above, even though the entire multiline string literal is indented, the first and last lines in the string don’t begin with any whitespace. The middle line has more indentation than the closing quotation marks, so it starts with that extra four-space indentation.</p>
</div>
<div class="section" id="ID295">
<h3>Special Characters in String Literals<a class="headerlink" href="StringsAndCharacters.html#ID295" title="Permalink to this headline">¶</a></h3>
<p>String literals can include the following special characters:</p>
<ul class="simple">
<li>The escaped special characters <code class="docutils literal notranslate"><span class="pre">\0</span></code> (null character), <code class="docutils literal notranslate"><span class="pre">\\</span></code> (backslash), <code class="docutils literal notranslate"><span class="pre">\t</span></code> (horizontal tab), <code class="docutils literal notranslate"><span class="pre">\n</span></code> (line feed), <code class="docutils literal notranslate"><span class="pre">\r</span></code> (carriage return), <code class="docutils literal notranslate"><span class="pre">\"</span></code> (double quotation mark) and <code class="docutils literal notranslate"><span class="pre">\'</span></code> (single quotation mark)</li>
<li>An arbitrary Unicode scalar value, written as <code class="docutils literal notranslate"><span class="pre">\u{</span></code><em>n</em><code class="docutils literal notranslate"><span class="pre">}</span></code>, where <em>n</em> is a 1–8 digit hexadecimal number (Unicode is discussed in <a class="reference internal" href="StringsAndCharacters.html#ID293"><span class="std std-ref">Unicode</span></a> below)</li>
</ul>
<p>The code below shows four examples of these special characters. The <code class="docutils literal notranslate"><span class="pre">wiseWords</span></code> constant contains two escaped double quotation marks. The <code class="docutils literal notranslate"><span class="pre">dollarSign</span></code>, <code class="docutils literal notranslate"><span class="pre">blackHeart</span></code>, and <code class="docutils literal notranslate"><span class="pre">sparklingHeart</span></code> constants demonstrate the Unicode scalar format:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">wiseWords</span> = <span class="s">"\"Imagination is more important than knowledge\" - Einstein"</span>
</li><li><span class="c">// "Imagination is more important than knowledge" - Einstein</span>
</li><li><span class="k">let</span> <span class="nv">dollarSign</span> = <span class="s">"\u{24}"</span> <span class="c">// $,  Unicode scalar U+0024</span>
</li><li><span class="k">let</span> <span class="nv">blackHeart</span> = <span class="s">"\u{2665}"</span> <span class="c">// ♥,  Unicode scalar U+2665</span>
</li><li><span class="k">let</span> <span class="nv">sparklingHeart</span> = <span class="s">"\u{1F496}"</span> <span class="c">// 💖, Unicode scalar U+1F496</span>
</li></ol></div></div></div>
<p>Because multiline string literals use three double quotation marks instead of just one, you can include a double quotation mark (<code class="docutils literal notranslate"><span class="pre">"</span></code>) inside of a multiline string literal without escaping it. To include the text <code class="docutils literal notranslate"><span class="pre">"""</span></code> in a multiline string, escape at least one of the quotation marks. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">threeDoubleQuotationMarks</span> = <span class="s">"""</span>
</li><li><span class="s">Escaping the first quotation mark \"""</span>
</li><li><span class="s">Escaping all three quotation marks \"\"\"</span>
</li><li><span class="s">"""</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID287">
<h2>Initializing an Empty String<a class="headerlink" href="StringsAndCharacters.html#ID287" title="Permalink to this headline">¶</a></h2>
<p>To create an empty <code class="docutils literal notranslate"><span class="pre">String</span></code> value as the starting point for building a longer string, either assign an empty string literal to a variable, or initialize a new <code class="docutils literal notranslate"><span class="pre">String</span></code> instance with initializer syntax:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">emptyString</span> = <span class="s">""</span> <span class="c">// empty string literal</span>
</li><li><span class="k">var</span> <span class="nv">anotherEmptyString</span> = <span class="nv">String</span>()  <span class="c">// initializer syntax</span>
</li><li><span class="c">// these two strings are both empty, and are equivalent to each other</span>
</li></ol></div></div></div>
<p>Find out whether a <code class="docutils literal notranslate"><span class="pre">String</span></code> value is empty by checking its Boolean <code class="docutils literal notranslate"><span class="pre">isEmpty</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">emptyString</span>.<span class="nv">isEmpty</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Nothing to see here"</span>)
</li><li>}
</li><li><span class="c">// Prints "Nothing to see here"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID288">
<h2>String Mutability<a class="headerlink" href="StringsAndCharacters.html#ID288" title="Permalink to this headline">¶</a></h2>
<p>You indicate whether a particular <code class="docutils literal notranslate"><span class="pre">String</span></code> can be modified (or <em>mutated</em>) by assigning it to a variable (in which case it can be modified), or to a constant (in which case it can’t be modified):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">variableString</span> = <span class="s">"Horse"</span>
</li><li><span class="nv">variableString</span> += <span class="s">" and carriage"</span>
</li><li><span class="c">// variableString is now "Horse and carriage"</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">constantString</span> = <span class="s">"Highlander"</span>
</li><li><span class="nv">constantString</span> += <span class="s">" and another Highlander"</span>
</li><li><span class="c">// this reports a compile-time error - a constant string cannot be modified</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This approach is different from string mutation in Objective-C and Cocoa, where you choose between two classes (<code class="docutils literal notranslate"><span class="pre">NSString</span></code> and <code class="docutils literal notranslate"><span class="pre">NSMutableString</span></code>) to indicate whether a string can be mutated.</p>
</div>
</div>
<div class="section" id="ID289">
<h2>Strings Are Value Types<a class="headerlink" href="StringsAndCharacters.html#ID289" title="Permalink to this headline">¶</a></h2>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> type is a <em>value type</em>. If you create a new <code class="docutils literal notranslate"><span class="pre">String</span></code> value, that <code class="docutils literal notranslate"><span class="pre">String</span></code> value is <em>copied</em> when it’s passed to a function or method, or when it’s assigned to a constant or variable. In each case, a new copy of the existing <code class="docutils literal notranslate"><span class="pre">String</span></code> value is created, and the new copy is passed or assigned, not the original version. Value types are described in <a class="reference internal" href="ClassesAndStructures.html#ID88"><span class="std std-ref">Structures and Enumerations Are Value Types</span></a>.</p>
<p>Swift’s copy-by-default <code class="docutils literal notranslate"><span class="pre">String</span></code> behavior ensures that when a function or method passes you a <code class="docutils literal notranslate"><span class="pre">String</span></code> value, it’s clear that you own that exact <code class="docutils literal notranslate"><span class="pre">String</span></code> value, regardless of where it came from. You can be confident that the string you are passed won’t be modified unless you modify it yourself.</p>
<p>Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary. This means you always get great performance when working with strings as value types.</p>
</div>
<div class="section" id="ID290">
<h2>Working with Characters<a class="headerlink" href="StringsAndCharacters.html#ID290" title="Permalink to this headline">¶</a></h2>
<p>You can access the individual <code class="docutils literal notranslate"><span class="pre">Character</span></code> values for a <code class="docutils literal notranslate"><span class="pre">String</span></code> by iterating over the string with a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">character</span> <span class="k">in</span> <span class="s">"Dog!🐶"</span> {
</li><li> <span class="nv">print</span>(<span class="nv">character</span>)
</li><li>}
</li><li><span class="c">// D</span>
</li><li><span class="c">// o</span>
</li><li><span class="c">// g</span>
</li><li><span class="c">// !</span>
</li><li><span class="c">// 🐶</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop is described in <a class="reference internal" href="ControlFlow.html#ID121"><span class="std std-ref">For-In Loops</span></a>.</p>
<p>Alternatively, you can create a stand-alone <code class="docutils literal notranslate"><span class="pre">Character</span></code> constant or variable from a single-character string literal by providing a <code class="docutils literal notranslate"><span class="pre">Character</span></code> type annotation:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">exclamationMark</span>: <span class="nc">Character</span> = <span class="s">"!"</span>
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">String</span></code> values can be constructed by passing an array of <code class="docutils literal notranslate"><span class="pre">Character</span></code> values as an argument to its initializer:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">catCharacters</span>: [<span class="nc">Character</span>] = [<span class="s">"C"</span>, <span class="s">"a"</span>, <span class="s">"t"</span>, <span class="s">"!"</span>, <span class="s">"🐱"</span>]
</li><li><span class="k">let</span> <span class="nv">catString</span> = <span class="nv">String</span>(<span class="nv">catCharacters</span>)
</li><li><span class="nv">print</span>(<span class="nv">catString</span>)
</li><li><span class="c">// Prints "Cat!🐱"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID291">
<h2>Concatenating Strings and Characters<a class="headerlink" href="StringsAndCharacters.html#ID291" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">String</span></code> values can be added together (or <em>concatenated</em>) with the addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) to create a new <code class="docutils literal notranslate"><span class="pre">String</span></code> value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">string1</span> = <span class="s">"hello"</span>
</li><li><span class="k">let</span> <span class="nv">string2</span> = <span class="s">" there"</span>
</li><li><span class="k">var</span> <span class="nv">welcome</span> = <span class="nv">string1</span> + <span class="nv">string2</span>
</li><li><span class="c">// welcome now equals "hello there"</span>
</li></ol></div></div></div>
<p>You can also append a <code class="docutils literal notranslate"><span class="pre">String</span></code> value to an existing <code class="docutils literal notranslate"><span class="pre">String</span></code> variable with the addition assignment operator (<code class="docutils literal notranslate"><span class="pre">+=</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">instruction</span> = <span class="s">"look over"</span>
</li><li><span class="nv">instruction</span> += <span class="nv">string2</span>
</li><li><span class="c">// instruction now equals "look over there"</span>
</li></ol></div></div></div>
<p>You can append a <code class="docutils literal notranslate"><span class="pre">Character</span></code> value to a <code class="docutils literal notranslate"><span class="pre">String</span></code> variable with the <code class="docutils literal notranslate"><span class="pre">String</span></code> type’s <code class="docutils literal notranslate"><span class="pre">append()</span></code> method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">exclamationMark</span>: <span class="nc">Character</span> = <span class="s">"!"</span>
</li><li><span class="nv">welcome</span>.<span class="nv">append</span>(<span class="nv">exclamationMark</span>)
</li><li><span class="c">// welcome now equals "hello there!"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can’t append a <code class="docutils literal notranslate"><span class="pre">String</span></code> or <code class="docutils literal notranslate"><span class="pre">Character</span></code> to an existing <code class="docutils literal notranslate"><span class="pre">Character</span></code> variable, because a <code class="docutils literal notranslate"><span class="pre">Character</span></code> value must contain a single character only.</p>
</div>
<p>If you’re using multiline string literals to build up the lines of a longer string, you want every line in the string to end with a line break, including the last line. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">badStart</span> = <span class="s">"""</span>
</li><li><span class="s">one</span>
</li><li><span class="s">two</span>
</li><li><span class="s">"""</span>
</li><li><span class="k">let</span> <span class="nv">end</span> = <span class="s">"""</span>
</li><li><span class="s">three</span>
</li><li><span class="s">"""</span>
</li><li><span class="nv">print</span>(<span class="nv">badStart</span> + <span class="nv">end</span>)
</li><li><span class="c">// Prints two lines:</span>
</li><li><span class="c">// one</span>
</li><li><span class="c">// twothree</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">goodStart</span> = <span class="s">"""</span>
</li><li><span class="s">one</span>
</li><li><span class="s">two</span>
</li><li>
</li><li><span class="s">"""</span>
</li><li><span class="nv">print</span>(<span class="nv">goodStart</span> + <span class="nv">end</span>)
</li><li><span class="c">// Prints three lines:</span>
</li><li><span class="c">// one</span>
</li><li><span class="c">// two</span>
</li><li><span class="c">// three</span>
</li></ol></div></div></div>
<p>In the code above, concatenating <code class="docutils literal notranslate"><span class="pre">badStart</span></code> with <code class="docutils literal notranslate"><span class="pre">end</span></code> produces a two-line string, which isn’t the desired result. Because the last line of <code class="docutils literal notranslate"><span class="pre">badStart</span></code> doesn’t end with a line break, that line gets combined with the first line of <code class="docutils literal notranslate"><span class="pre">end</span></code>. In contrast, both lines of <code class="docutils literal notranslate"><span class="pre">goodStart</span></code> end with a line break, so when it’s combined with <code class="docutils literal notranslate"><span class="pre">end</span></code> the result has three lines, as expected.</p>
</div>
<div class="section" id="ID292">
<h2>String Interpolation<a class="headerlink" href="StringsAndCharacters.html#ID292" title="Permalink to this headline">¶</a></h2>
<p><em>String interpolation</em> is a way to construct a new <code class="docutils literal notranslate"><span class="pre">String</span></code> value from a mix of constants, variables, literals, and expressions by including their values inside a string literal. You can use string interpolation in both single-line and multiline string literals. Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash (<code class="docutils literal notranslate"><span class="pre">\</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">multiplier</span> = <span class="m">3</span>
</li><li><span class="k">let</span> <span class="nv">message</span> = <span class="s">"</span>\<span class="p">(</span><span class="nv">multiplier</span><span class="p">)</span><span class="s"> times 2.5 is </span>\<span class="p">(</span><span class="nv">Double</span>(<span class="nv">multiplier</span>) * <span class="m">2.5</span><span class="p">)</span><span class="s">"</span>
</li><li><span class="c">// message is "3 times 2.5 is 7.5"</span>
</li></ol></div></div></div>
<p>In the example above, the value of <code class="docutils literal notranslate"><span class="pre">multiplier</span></code> is inserted into a string literal as <code class="docutils literal notranslate"><span class="pre">\(multiplier)</span></code>. This placeholder is replaced with the actual value of <code class="docutils literal notranslate"><span class="pre">multiplier</span></code> when the string interpolation is evaluated to create an actual string.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">multiplier</span></code> is also part of a larger expression later in the string. This expression calculates the value of <code class="docutils literal notranslate"><span class="pre">Double(multiplier)</span> <span class="pre">*</span> <span class="pre">2.5</span></code> and inserts the result (<code class="docutils literal notranslate"><span class="pre">7.5</span></code>) into the string. In this case, the expression is written as <code class="docutils literal notranslate"><span class="pre">\(Double(multiplier)</span> <span class="pre">*</span> <span class="pre">2.5)</span></code> when it’s included inside the string literal.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The expressions you write inside parentheses within an interpolated string can’t contain an unescaped backslash (<code class="docutils literal notranslate"><span class="pre">\</span></code>), a carriage return, or a line feed. However, they can contain other string literals.</p>
</div>
</div>
<div class="section" id="ID293">
<h2>Unicode<a class="headerlink" href="StringsAndCharacters.html#ID293" title="Permalink to this headline">¶</a></h2>
<p><em>Unicode</em> is an international standard for encoding, representing, and processing text in different writing systems. It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page. Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Character</span></code> types are fully Unicode-compliant, as described in this section.</p>
<div class="section" id="ID294">
<h3>Unicode Scalar Values<a class="headerlink" href="StringsAndCharacters.html#ID294" title="Permalink to this headline">¶</a></h3>
<p>Behind the scenes, Swift’s native <code class="docutils literal notranslate"><span class="pre">String</span></code> type is built from <em>Unicode scalar values</em>. A Unicode scalar value is a unique 21-bit number for a character or modifier, such as <code class="docutils literal notranslate"><span class="pre">U+0061</span></code> for <code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">A</span></code> (<code class="docutils literal notranslate"><span class="pre">"a"</span></code>), or <code class="docutils literal notranslate"><span class="pre">U+1F425</span></code> for <code class="docutils literal notranslate"><span class="pre">FRONT-FACING</span> <span class="pre">BABY</span> <span class="pre">CHICK</span></code> (<code class="docutils literal notranslate"><span class="pre">"🐥"</span></code>).</p>
<p>Note that not all 21-bit Unicode scalar values are assigned to a character—some scalars are reserved for future assignment or for use in UTF-16 encoding. Scalar values that have been assigned to a character typically also have a name, such as <code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">FRONT-FACING</span> <span class="pre">BABY</span> <span class="pre">CHICK</span></code> in the examples above.</p>
</div>
<div class="section" id="ID296">
<h3>Extended Grapheme Clusters<a class="headerlink" href="StringsAndCharacters.html#ID296" title="Permalink to this headline">¶</a></h3>
<p>Every instance of Swift’s <code class="docutils literal notranslate"><span class="pre">Character</span></code> type represents a single <em>extended grapheme cluster</em>. An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.</p>
<p>Here’s an example. The letter <code class="docutils literal notranslate"><span class="pre">é</span></code> can be represented as the single Unicode scalar <code class="docutils literal notranslate"><span class="pre">é</span></code> (<code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">E</span> <span class="pre">WITH</span> <span class="pre">ACUTE</span></code>, or <code class="docutils literal notranslate"><span class="pre">U+00E9</span></code>). However, the same letter can also be represented as a <em>pair</em> of scalars—a standard letter <code class="docutils literal notranslate"><span class="pre">e</span></code> (<code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">E</span></code>, or <code class="docutils literal notranslate"><span class="pre">U+0065</span></code>), followed by the <code class="docutils literal notranslate"><span class="pre">COMBINING</span> <span class="pre">ACUTE</span> <span class="pre">ACCENT</span></code> scalar (<code class="docutils literal notranslate"><span class="pre">U+0301</span></code>). The <code class="docutils literal notranslate"><span class="pre">COMBINING</span> <span class="pre">ACUTE</span> <span class="pre">ACCENT</span></code> scalar is graphically applied to the scalar that precedes it, turning an <code class="docutils literal notranslate"><span class="pre">e</span></code> into an <code class="docutils literal notranslate"><span class="pre">é</span></code> when it’s rendered by a Unicode-aware text-rendering system.</p>
<p>In both cases, the letter <code class="docutils literal notranslate"><span class="pre">é</span></code> is represented as a single Swift <code class="docutils literal notranslate"><span class="pre">Character</span></code> value that represents an extended grapheme cluster. In the first case, the cluster contains a single scalar; in the second case, it’s a cluster of two scalars:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">eAcute</span>: <span class="nc">Character</span> = <span class="s">"\u{E9}"</span> <span class="c">// é</span>
</li><li><span class="k">let</span> <span class="nv">combinedEAcute</span>: <span class="nc">Character</span> = <span class="s">"\u{65}\u{301}"</span> <span class="c">// e followed by ́</span>
</li><li><span class="c">// eAcute is é, combinedEAcute is é</span>
</li></ol></div></div></div>
<p>Extended grapheme clusters are a flexible way to represent many complex script characters as a single <code class="docutils literal notranslate"><span class="pre">Character</span></code> value. For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence. Both of these representations qualify as a single <code class="docutils literal notranslate"><span class="pre">Character</span></code> value in Swift:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">precomposed</span>: <span class="nc">Character</span> = <span class="s">"\u{D55C}"</span> <span class="c">// 한</span>
</li><li><span class="k">let</span> <span class="nv">decomposed</span>: <span class="nc">Character</span> = <span class="s">"\u{1112}\u{1161}\u{11AB}"</span> <span class="c">// ᄒ, ᅡ, ᆫ</span>
</li><li><span class="c">// precomposed is 한, decomposed is 한</span>
</li></ol></div></div></div>
<p>Extended grapheme clusters enable scalars for enclosing marks (such as <code class="docutils literal notranslate"><span class="pre">COMBINING</span> <span class="pre">ENCLOSING</span> <span class="pre">CIRCLE</span></code>, or <code class="docutils literal notranslate"><span class="pre">U+20DD</span></code>) to enclose other Unicode scalars as part of a single <code class="docutils literal notranslate"><span class="pre">Character</span></code> value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">enclosedEAcute</span>: <span class="nc">Character</span> = <span class="s">"\u{E9}\u{20DD}"</span>
</li><li><span class="c">// enclosedEAcute is é⃝</span>
</li></ol></div></div></div>
<p>Unicode scalars for regional indicator symbols can be combined in pairs to make a single <code class="docutils literal notranslate"><span class="pre">Character</span></code> value, such as this combination of <code class="docutils literal notranslate"><span class="pre">REGIONAL</span> <span class="pre">INDICATOR</span> <span class="pre">SYMBOL</span> <span class="pre">LETTER</span> <span class="pre">U</span></code> (<code class="docutils literal notranslate"><span class="pre">U+1F1FA</span></code>) and <code class="docutils literal notranslate"><span class="pre">REGIONAL</span> <span class="pre">INDICATOR</span> <span class="pre">SYMBOL</span> <span class="pre">LETTER</span> <span class="pre">S</span></code> (<code class="docutils literal notranslate"><span class="pre">U+1F1F8</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">regionalIndicatorForUS</span>: <span class="nc">Character</span> = <span class="s">"\u{1F1FA}\u{1F1F8}"</span>
</li><li><span class="c">// regionalIndicatorForUS is 🇺🇸</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID297">
<h2>Counting Characters<a class="headerlink" href="StringsAndCharacters.html#ID297" title="Permalink to this headline">¶</a></h2>
<p>To retrieve a count of the <code class="docutils literal notranslate"><span class="pre">Character</span></code> values in a string, use the <code class="docutils literal notranslate"><span class="pre">count</span></code> property of the string:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">unusualMenagerie</span> = <span class="s">"Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"</span>
</li><li><span class="nv">print</span>(<span class="s">"unusualMenagerie has </span>\<span class="p">(</span><span class="nv">unusualMenagerie</span>.<span class="nv">count</span><span class="p">)</span><span class="s"> characters"</span>)
</li><li><span class="c">// Prints "unusualMenagerie has 40 characters"</span>
</li></ol></div></div></div>
<p>Note that Swift’s use of extended grapheme clusters for <code class="docutils literal notranslate"><span class="pre">Character</span></code> values means that string concatenation and modification may not always affect a string’s character count.</p>
<p>For example, if you initialize a new string with the four-character word <code class="docutils literal notranslate"><span class="pre">cafe</span></code>, and then append a <code class="docutils literal notranslate"><span class="pre">COMBINING</span> <span class="pre">ACUTE</span> <span class="pre">ACCENT</span></code> (<code class="docutils literal notranslate"><span class="pre">U+0301</span></code>) to the end of the string, the resulting string will still have a character count of <code class="docutils literal notranslate"><span class="pre">4</span></code>, with a fourth character of <code class="docutils literal notranslate"><span class="pre">é</span></code>, not <code class="docutils literal notranslate"><span class="pre">e</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">word</span> = <span class="s">"cafe"</span>
</li><li><span class="nv">print</span>(<span class="s">"the number of characters in </span>\<span class="p">(</span><span class="nv">word</span><span class="p">)</span><span class="s"> is </span>\<span class="p">(</span><span class="nv">word</span>.<span class="nv">count</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "the number of characters in cafe is 4"</span>
</li><li>
</li><li><span class="nv">word</span> += <span class="s">"\u{301}"</span> <span class="c">// COMBINING ACUTE ACCENT, U+0301</span>
</li><li>
</li><li><span class="nv">print</span>(<span class="s">"the number of characters in </span>\<span class="p">(</span><span class="nv">word</span><span class="p">)</span><span class="s"> is </span>\<span class="p">(</span><span class="nv">word</span>.<span class="nv">count</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "the number of characters in café is 4"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Extended grapheme clusters can be composed of multiple Unicode scalars. This means that different characters—and different representations of the same character—can require different amounts of memory to store. Because of this, characters in Swift don’t each take up the same amount of memory within a string’s representation. As a result, the number of characters in a string can’t be calculated without iterating through the string to determine its extended grapheme cluster boundaries. If you are working with particularly long string values, be aware that the <code class="docutils literal notranslate"><span class="pre">count</span></code> property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.</p>
<p class="last">The count of the characters returned by the <code class="docutils literal notranslate"><span class="pre">count</span></code> property isn’t always the same as the <code class="docutils literal notranslate"><span class="pre">length</span></code> property of an <code class="docutils literal notranslate"><span class="pre">NSString</span></code> that contains the same characters. The length of an <code class="docutils literal notranslate"><span class="pre">NSString</span></code> is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.</p>
</div>
</div>
<div class="section" id="ID494">
<h2>Accessing and Modifying a String<a class="headerlink" href="StringsAndCharacters.html#ID494" title="Permalink to this headline">¶</a></h2>
<p>You access and modify a string through its methods and properties, or by using subscript syntax.</p>
<div class="section" id="ID534">
<h3>String Indices<a class="headerlink" href="StringsAndCharacters.html#ID534" title="Permalink to this headline">¶</a></h3>
<p>Each <code class="docutils literal notranslate"><span class="pre">String</span></code> value has an associated <em>index type</em>, <code class="docutils literal notranslate"><span class="pre">String.Index</span></code>, which corresponds to the position of each <code class="docutils literal notranslate"><span class="pre">Character</span></code> in the string.</p>
<p>As mentioned above, different characters can require different amounts of memory to store, so in order to determine which <code class="docutils literal notranslate"><span class="pre">Character</span></code> is at a particular position, you must iterate over each Unicode scalar from the start or end of that <code class="docutils literal notranslate"><span class="pre">String</span></code>. For this reason, Swift strings can’t be indexed by integer values.</p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">startIndex</span></code> property to access the position of the first <code class="docutils literal notranslate"><span class="pre">Character</span></code> of a <code class="docutils literal notranslate"><span class="pre">String</span></code>. The <code class="docutils literal notranslate"><span class="pre">endIndex</span></code> property is the position after the last character in a <code class="docutils literal notranslate"><span class="pre">String</span></code>. As a result, the <code class="docutils literal notranslate"><span class="pre">endIndex</span></code> property isn’t a valid argument to a string’s subscript. If a <code class="docutils literal notranslate"><span class="pre">String</span></code> is empty, <code class="docutils literal notranslate"><span class="pre">startIndex</span></code> and <code class="docutils literal notranslate"><span class="pre">endIndex</span></code> are equal.</p>
<p>You access the indices before and after a given index using the <code class="docutils literal notranslate"><span class="pre">index(before:)</span></code> and <code class="docutils literal notranslate"><span class="pre">index(after:)</span></code> methods of <code class="docutils literal notranslate"><span class="pre">String</span></code>. To access an index farther away from the given index, you can use the <code class="docutils literal notranslate"><span class="pre">index(_:offsetBy:)</span></code> method instead of calling one of these methods multiple times.</p>
<p>You can use subscript syntax to access the <code class="docutils literal notranslate"><span class="pre">Character</span></code> at a particular <code class="docutils literal notranslate"><span class="pre">String</span></code> index.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">greeting</span> = <span class="s">"Guten Tag!"</span>
</li><li><span class="nv">greeting</span>[<span class="nv">greeting</span>.<span class="nv">startIndex</span>]
</li><li><span class="c">// G</span>
</li><li><span class="nv">greeting</span>[<span class="nv">greeting</span>.<span class="nv">index</span>(<span class="nv">before</span>: <span class="nv">greeting</span>.<span class="nv">endIndex</span>)]
</li><li><span class="c">// !</span>
</li><li><span class="nv">greeting</span>[<span class="nv">greeting</span>.<span class="nv">index</span>(<span class="nv">after</span>: <span class="nv">greeting</span>.<span class="nv">startIndex</span>)]
</li><li><span class="c">// u</span>
</li><li><span class="k">let</span> <span class="nv">index</span> = <span class="nv">greeting</span>.<span class="nv">index</span>(<span class="nv">greeting</span>.<span class="nv">startIndex</span>, <span class="nv">offsetBy</span>: <span class="m">7</span>)
</li><li><span class="nv">greeting</span>[<span class="nv">index</span>]
</li><li><span class="c">// a</span>
</li></ol></div></div></div>
<p>Attempting to access an index outside of a string’s range or a <code class="docutils literal notranslate"><span class="pre">Character</span></code> at an index outside of a string’s range will trigger a runtime error.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">greeting</span>[<span class="nv">greeting</span>.<span class="nv">endIndex</span>] <span class="c">// Error</span>
</li><li><span class="nv">greeting</span>.<span class="nv">index</span>(<span class="nv">after</span>: <span class="nv">greeting</span>.<span class="nv">endIndex</span>) <span class="c">// Error</span>
</li></ol></div></div></div>
<p>Use the <code class="docutils literal notranslate"><span class="pre">indices</span></code> property to access all of the indices of individual characters in a string.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> <span class="nv">greeting</span>.<span class="nv">indices</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">greeting</span>[<span class="nv">index</span>]<span class="p">)</span><span class="s"> "</span>, <span class="nv">terminator</span>: <span class="s">""</span>)
</li><li>}
</li><li><span class="c">// Prints "G u t e n   T a g ! "</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can use the <code class="docutils literal notranslate"><span class="pre">startIndex</span></code> and <code class="docutils literal notranslate"><span class="pre">endIndex</span></code> properties and the <code class="docutils literal notranslate"><span class="pre">index(before:)</span></code>, <code class="docutils literal notranslate"><span class="pre">index(after:)</span></code>, and <code class="docutils literal notranslate"><span class="pre">index(_:offsetBy:)</span></code> methods on any type that conforms to the <code class="docutils literal notranslate"><span class="pre">Collection</span></code> protocol. This includes <code class="docutils literal notranslate"><span class="pre">String</span></code>, as shown here, as well as collection types such as <code class="docutils literal notranslate"><span class="pre">Array</span></code>, <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>, and <code class="docutils literal notranslate"><span class="pre">Set</span></code>.</p>
</div>
</div>
<div class="section" id="ID496">
<h3>Inserting and Removing<a class="headerlink" href="StringsAndCharacters.html#ID496" title="Permalink to this headline">¶</a></h3>
<p>To insert a single character into a string at a specified index, use the <code class="docutils literal notranslate"><span class="pre">insert(_:at:)</span></code> method, and to insert the contents of another string at a specified index, use the <code class="docutils literal notranslate"><span class="pre">insert(contentsOf:at:)</span></code> method.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">welcome</span> = <span class="s">"hello"</span>
</li><li><span class="nv">welcome</span>.<span class="nv">insert</span>(<span class="s">"!"</span>, <span class="nv">at</span>: <span class="nv">welcome</span>.<span class="nv">endIndex</span>)
</li><li><span class="c">// welcome now equals "hello!"</span>
</li><li>
</li><li><span class="nv">welcome</span>.<span class="nv">insert</span>(<span class="nv">contentsOf</span>: <span class="s">" there"</span>, <span class="nv">at</span>: <span class="nv">welcome</span>.<span class="nv">index</span>(<span class="nv">before</span>: <span class="nv">welcome</span>.<span class="nv">endIndex</span>))
</li><li><span class="c">// welcome now equals "hello there!"</span>
</li></ol></div></div></div>
<p>To remove a single character from a string at a specified index, use the <code class="docutils literal notranslate"><span class="pre">remove(at:)</span></code> method, and to remove a substring at a specified range, use the <code class="docutils literal notranslate"><span class="pre">removeSubrange(_:)</span></code> method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">welcome</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="nv">welcome</span>.<span class="nv">index</span>(<span class="nv">before</span>: <span class="nv">welcome</span>.<span class="nv">endIndex</span>))
</li><li><span class="c">// welcome now equals "hello there"</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">range</span> = <span class="nv">welcome</span>.<span class="nv">index</span>(<span class="nv">welcome</span>.<span class="nv">endIndex</span>, <span class="nv">offsetBy</span>: <span class="m">-6</span>)..&lt;<span class="nv">welcome</span>.<span class="nv">endIndex</span>
</li><li><span class="nv">welcome</span>.<span class="nv">removeSubrange</span>(<span class="nv">range</span>)
</li><li><span class="c">// welcome now equals "hello"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can use the <code class="docutils literal notranslate"><span class="pre">insert(_:at:)</span></code>, <code class="docutils literal notranslate"><span class="pre">insert(contentsOf:at:)</span></code>, <code class="docutils literal notranslate"><span class="pre">remove(at:)</span></code>, and <code class="docutils literal notranslate"><span class="pre">removeSubrange(_:)</span></code> methods on any type that conforms to the <code class="docutils literal notranslate"><span class="pre">RangeReplaceableCollection</span></code> protocol. This includes <code class="docutils literal notranslate"><span class="pre">String</span></code>, as shown here, as well as collection types such as <code class="docutils literal notranslate"><span class="pre">Array</span></code>, <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>, and <code class="docutils literal notranslate"><span class="pre">Set</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="ID555">
<h2>Substrings<a class="headerlink" href="StringsAndCharacters.html#ID555" title="Permalink to this headline">¶</a></h2>
<p>When you get a substring from a string—for example, using a subscript or a method like <code class="docutils literal notranslate"><span class="pre">prefix(_:)</span></code>—the result is an instance of <a class="reference external" href="https://developer.apple.com/documentation/swift/substring"><code class="docutils literal notranslate"><span class="pre">Substring</span></code></a>, not another string. Substrings in Swift have most of the same methods as strings, which means you can work with substrings the same way you work with strings. However, unlike strings, you use substrings for only a short amount of time while performing actions on a string. When you’re ready to store the result for a longer time, you convert the substring to an instance of <code class="docutils literal notranslate"><span class="pre">String</span></code>. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">greeting</span> = <span class="s">"Hello, world!"</span>
</li><li><span class="k">let</span> <span class="nv">index</span> = <span class="nv">greeting</span>.<span class="nv">firstIndex</span>(<span class="nv">of</span>: <span class="s">","</span>) ?? <span class="nv">greeting</span>.<span class="nv">endIndex</span>
</li><li><span class="k">let</span> <span class="nv">beginning</span> = <span class="nv">greeting</span>[..&lt;<span class="nv">index</span>]
</li><li><span class="c">// beginning is "Hello"</span>
</li><li>
</li><li><span class="c">// Convert the result to a String for long-term storage.</span>
</li><li><span class="k">let</span> <span class="nv">newString</span> = <span class="nv">String</span>(<span class="nv">beginning</span>)
</li></ol></div></div></div>
<p>Like strings, each substring has a region of memory where the characters that make up the substring are stored. The difference between strings and substrings is that, as a performance optimization, a substring can reuse part of the memory that’s used to store the original string, or part of the memory that’s used to store another substring. (Strings have a similar optimization, but if two strings share memory, they are equal.) This performance optimization means you don’t have to pay the performance cost of copying memory until you modify either the string or substring. As mentioned above, substrings aren’t suitable for long-term storage—because they reuse the storage of the original string, the entire original string must be kept in memory as long as any of its substrings are being used.</p>
<p>In the example above, <code class="docutils literal notranslate"><span class="pre">greeting</span></code> is a string, which means it has a region of memory where the characters that make up the string are stored. Because <code class="docutils literal notranslate"><span class="pre">beginning</span></code> is a substring of <code class="docutils literal notranslate"><span class="pre">greeting</span></code>, it reuses the memory that <code class="docutils literal notranslate"><span class="pre">greeting</span></code> uses. In contrast, <code class="docutils literal notranslate"><span class="pre">newString</span></code> is a string—when it’s created from the substring, it has its own storage. The figure below shows these relationships:</p>
<img alt="../_images/stringSubstring_2x.png" class="align-center" src="../_images/stringSubstring_2x.png" style="width: 366px;"/>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both <code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Substring</span></code> conform to the <a class="reference external" href="https://developer.apple.com/documentation/swift/stringprotocol"><code class="docutils literal notranslate"><span class="pre">StringProtocol</span></code></a> protocol, which means it’s often convenient for string-manipulation functions to accept a <code class="docutils literal notranslate"><span class="pre">StringProtocol</span></code> value. You can call such functions with either a <code class="docutils literal notranslate"><span class="pre">String</span></code> or <code class="docutils literal notranslate"><span class="pre">Substring</span></code> value.</p>
</div>
</div>
<div class="section" id="ID298">
<h2>Comparing Strings<a class="headerlink" href="StringsAndCharacters.html#ID298" title="Permalink to this headline">¶</a></h2>
<p>Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.</p>
<div class="section" id="ID299">
<h3>String and Character Equality<a class="headerlink" href="StringsAndCharacters.html#ID299" title="Permalink to this headline">¶</a></h3>
<p>String and character equality is checked with the “equal to” operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) and the “not equal to” operator (<code class="docutils literal notranslate"><span class="pre">!=</span></code>), as described in <a class="reference internal" href="BasicOperators.html#ID70"><span class="std std-ref">Comparison Operators</span></a>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">quotation</span> = <span class="s">"We're a lot alike, you and I."</span>
</li><li><span class="k">let</span> <span class="nv">sameQuotation</span> = <span class="s">"We're a lot alike, you and I."</span>
</li><li><span class="k">if</span> <span class="nv">quotation</span> == <span class="nv">sameQuotation</span> {
</li><li> <span class="nv">print</span>(<span class="s">"These two strings are considered equal"</span>)
</li><li>}
</li><li><span class="c">// Prints "These two strings are considered equal"</span>
</li></ol></div></div></div>
<p>Two <code class="docutils literal notranslate"><span class="pre">String</span></code> values (or two <code class="docutils literal notranslate"><span class="pre">Character</span></code> values) are considered equal if their extended grapheme clusters are <em>canonically equivalent</em>. Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they’re composed from different Unicode scalars behind the scenes.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">E</span> <span class="pre">WITH</span> <span class="pre">ACUTE</span></code> (<code class="docutils literal notranslate"><span class="pre">U+00E9</span></code>) is canonically equivalent to <code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">E</span></code> (<code class="docutils literal notranslate"><span class="pre">U+0065</span></code>) followed by <code class="docutils literal notranslate"><span class="pre">COMBINING</span> <span class="pre">ACUTE</span> <span class="pre">ACCENT</span></code> (<code class="docutils literal notranslate"><span class="pre">U+0301</span></code>). Both of these extended grapheme clusters are valid ways to represent the character <code class="docutils literal notranslate"><span class="pre">é</span></code>, and so they’re considered to be canonically equivalent:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE</span>
</li><li><span class="k">let</span> <span class="nv">eAcuteQuestion</span> = <span class="s">"Voulez-vous un caf\u{E9}?"</span>
</li><li>
</li><li><span class="c">// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</span>
</li><li><span class="k">let</span> <span class="nv">combinedEAcuteQuestion</span> = <span class="s">"Voulez-vous un caf\u{65}\u{301}?"</span>
</li><li>
</li><li><span class="k">if</span> <span class="nv">eAcuteQuestion</span> == <span class="nv">combinedEAcuteQuestion</span> {
</li><li> <span class="nv">print</span>(<span class="s">"These two strings are considered equal"</span>)
</li><li>}
</li><li><span class="c">// Prints "These two strings are considered equal"</span>
</li></ol></div></div></div>
<p>Conversely, <code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">CAPITAL</span> <span class="pre">LETTER</span> <span class="pre">A</span></code> (<code class="docutils literal notranslate"><span class="pre">U+0041</span></code>, or <code class="docutils literal notranslate"><span class="pre">"A"</span></code>), as used in English, is <em>not</em> equivalent to <code class="docutils literal notranslate"><span class="pre">CYRILLIC</span> <span class="pre">CAPITAL</span> <span class="pre">LETTER</span> <span class="pre">A</span></code> (<code class="docutils literal notranslate"><span class="pre">U+0410</span></code>, or <code class="docutils literal notranslate"><span class="pre">"А"</span></code>), as used in Russian. The characters are visually similar, but don’t have the same linguistic meaning:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">latinCapitalLetterA</span>: <span class="nc">Character</span> = <span class="s">"\u{41}"</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">cyrillicCapitalLetterA</span>: <span class="nc">Character</span> = <span class="s">"\u{0410}"</span>
</li><li>
</li><li><span class="k">if</span> <span class="nv">latinCapitalLetterA</span> != <span class="nv">cyrillicCapitalLetterA</span> {
</li><li> <span class="nv">print</span>(<span class="s">"These two characters are not equivalent."</span>)
</li><li>}
</li><li><span class="c">// Prints "These two characters are not equivalent."</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">String and character comparisons in Swift are not locale-sensitive.</p>
</div>
</div>
<div class="section" id="ID300">
<h3>Prefix and Suffix Equality<a class="headerlink" href="StringsAndCharacters.html#ID300" title="Permalink to this headline">¶</a></h3>
<p>To check whether a string has a particular string prefix or suffix, call the string’s <code class="docutils literal notranslate"><span class="pre">hasPrefix(_:)</span></code> and <code class="docutils literal notranslate"><span class="pre">hasSuffix(_:)</span></code> methods, both of which take a single argument of type <code class="docutils literal notranslate"><span class="pre">String</span></code> and return a Boolean value.</p>
<p>The examples below consider an array of strings representing the scene locations from the first two acts of Shakespeare’s <em>Romeo and Juliet</em>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">romeoAndJuliet</span> = [
</li><li> <span class="s">"Act 1 Scene 1: Verona, A public place"</span>,
</li><li> <span class="s">"Act 1 Scene 2: Capulet's mansion"</span>,
</li><li> <span class="s">"Act 1 Scene 3: A room in Capulet's mansion"</span>,
</li><li> <span class="s">"Act 1 Scene 4: A street outside Capulet's mansion"</span>,
</li><li> <span class="s">"Act 1 Scene 5: The Great Hall in Capulet's mansion"</span>,
</li><li> <span class="s">"Act 2 Scene 1: Outside Capulet's mansion"</span>,
</li><li> <span class="s">"Act 2 Scene 2: Capulet's orchard"</span>,
</li><li> <span class="s">"Act 2 Scene 3: Outside Friar Lawrence's cell"</span>,
</li><li> <span class="s">"Act 2 Scene 4: A street in Verona"</span>,
</li><li> <span class="s">"Act 2 Scene 5: Capulet's mansion"</span>,
</li><li> <span class="s">"Act 2 Scene 6: Friar Lawrence's cell"</span>
</li><li>]
</li></ol></div></div></div>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">hasPrefix(_:)</span></code> method with the <code class="docutils literal notranslate"><span class="pre">romeoAndJuliet</span></code> array to count the number of scenes in Act 1 of the play:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">act1SceneCount</span> = <span class="m">0</span>
</li><li><span class="k">for</span> <span class="nv">scene</span> <span class="k">in</span> <span class="nv">romeoAndJuliet</span> {
</li><li> <span class="k">if</span> <span class="nv">scene</span>.<span class="nv">hasPrefix</span>(<span class="s">"Act 1 "</span>) {
</li><li> <span class="nv">act1SceneCount</span> += <span class="m">1</span>
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">"There are </span>\<span class="p">(</span><span class="nv">act1SceneCount</span><span class="p">)</span><span class="s"> scenes in Act 1"</span>)
</li><li><span class="c">// Prints "There are 5 scenes in Act 1"</span>
</li></ol></div></div></div>
<p>Similarly, use the <code class="docutils literal notranslate"><span class="pre">hasSuffix(_:)</span></code> method to count the number of scenes that take place in or around Capulet’s mansion and Friar Lawrence’s cell:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">mansionCount</span> = <span class="m">0</span>
</li><li><span class="k">var</span> <span class="nv">cellCount</span> = <span class="m">0</span>
</li><li><span class="k">for</span> <span class="nv">scene</span> <span class="k">in</span> <span class="nv">romeoAndJuliet</span> {
</li><li> <span class="k">if</span> <span class="nv">scene</span>.<span class="nv">hasSuffix</span>(<span class="s">"Capulet's mansion"</span>) {
</li><li> <span class="nv">mansionCount</span> += <span class="m">1</span>
</li><li>    } <span class="k">else</span> <span class="k">if</span> <span class="nv">scene</span>.<span class="nv">hasSuffix</span>(<span class="s">"Friar Lawrence's cell"</span>) {
</li><li> <span class="nv">cellCount</span> += <span class="m">1</span>
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">mansionCount</span><span class="p">)</span><span class="s"> mansion scenes; </span>\<span class="p">(</span><span class="nv">cellCount</span><span class="p">)</span><span class="s"> cell scenes"</span>)
</li><li><span class="c">// Prints "6 mansion scenes; 2 cell scenes"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">hasPrefix(_:)</span></code> and <code class="docutils literal notranslate"><span class="pre">hasSuffix(_:)</span></code> methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string, as described in <a class="reference internal" href="StringsAndCharacters.html#ID299"><span class="std std-ref">String and Character Equality</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="ID301">
<h2>Unicode Representations of Strings<a class="headerlink" href="StringsAndCharacters.html#ID301" title="Permalink to this headline">¶</a></h2>
<p>When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined <em>encoding forms</em>. Each form encodes the string in small chunks known as <em>code units</em>. These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).</p>
<p>Swift provides several different ways to access Unicode representations of strings. You can iterate over the string with a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> statement, to access its individual <code class="docutils literal notranslate"><span class="pre">Character</span></code> values as Unicode extended grapheme clusters. This process is described in <a class="reference internal" href="StringsAndCharacters.html#ID290"><span class="std std-ref">Working with Characters</span></a>.</p>
<p>Alternatively, access a <code class="docutils literal notranslate"><span class="pre">String</span></code> value in one of three other Unicode-compliant representations:</p>
<ul class="simple">
<li>A collection of UTF-8 code units (accessed with the string’s <code class="docutils literal notranslate"><span class="pre">utf8</span></code> property)</li>
<li>A collection of UTF-16 code units (accessed with the string’s <code class="docutils literal notranslate"><span class="pre">utf16</span></code> property)</li>
<li>A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s <code class="docutils literal notranslate"><span class="pre">unicodeScalars</span></code> property)</li>
</ul>
<p>Each example below shows a different representation of the following string, which is made up of the characters <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">o</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">‼</span></code> (<code class="docutils literal notranslate"><span class="pre">DOUBLE</span> <span class="pre">EXCLAMATION</span> <span class="pre">MARK</span></code>, or Unicode scalar <code class="docutils literal notranslate"><span class="pre">U+203C</span></code>), and the 🐶 character (<code class="docutils literal notranslate"><span class="pre">DOG</span> <span class="pre">FACE</span></code>, or Unicode scalar <code class="docutils literal notranslate"><span class="pre">U+1F436</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">dogString</span> = <span class="s">"Dog‼🐶"</span>
</li></ol></div></div></div>
<div class="section" id="ID302">
<h3>UTF-8 Representation<a class="headerlink" href="StringsAndCharacters.html#ID302" title="Permalink to this headline">¶</a></h3>
<p>You can access a UTF-8 representation of a <code class="docutils literal notranslate"><span class="pre">String</span></code> by iterating over its <code class="docutils literal notranslate"><span class="pre">utf8</span></code> property. This property is of type <code class="docutils literal notranslate"><span class="pre">String.UTF8View</span></code>, which is a collection of unsigned 8-bit (<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>) values, one for each byte in the string’s UTF-8 representation:</p>
<img alt="../_images/UTF8_2x.png" class="align-center" src="../_images/UTF8_2x.png" style="width: 476px;"/>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">codeUnit</span> <span class="k">in</span> <span class="nv">dogString</span>.<span class="nv">utf8</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">codeUnit</span><span class="p">)</span><span class="s"> "</span>, <span class="nv">terminator</span>: <span class="s">""</span>)
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">""</span>)
</li><li><span class="c">// Prints "68 111 103 226 128 188 240 159 144 182 "</span>
</li></ol></div></div></div>
<p>In the example above, the first three decimal <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> values (<code class="docutils literal notranslate"><span class="pre">68</span></code>, <code class="docutils literal notranslate"><span class="pre">111</span></code>, <code class="docutils literal notranslate"><span class="pre">103</span></code>) represent the characters <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">o</span></code>, and <code class="docutils literal notranslate"><span class="pre">g</span></code>, whose UTF-8 representation is the same as their ASCII representation. The next three decimal <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> values (<code class="docutils literal notranslate"><span class="pre">226</span></code>, <code class="docutils literal notranslate"><span class="pre">128</span></code>, <code class="docutils literal notranslate"><span class="pre">188</span></code>) are a three-byte UTF-8 representation of the <code class="docutils literal notranslate"><span class="pre">DOUBLE</span> <span class="pre">EXCLAMATION</span> <span class="pre">MARK</span></code> character. The last four <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> values (<code class="docutils literal notranslate"><span class="pre">240</span></code>, <code class="docutils literal notranslate"><span class="pre">159</span></code>, <code class="docutils literal notranslate"><span class="pre">144</span></code>, <code class="docutils literal notranslate"><span class="pre">182</span></code>) are a four-byte UTF-8 representation of the <code class="docutils literal notranslate"><span class="pre">DOG</span> <span class="pre">FACE</span></code> character.</p>
</div>
<div class="section" id="ID303">
<h3>UTF-16 Representation<a class="headerlink" href="StringsAndCharacters.html#ID303" title="Permalink to this headline">¶</a></h3>
<p>You can access a UTF-16 representation of a <code class="docutils literal notranslate"><span class="pre">String</span></code> by iterating over its <code class="docutils literal notranslate"><span class="pre">utf16</span></code> property. This property is of type <code class="docutils literal notranslate"><span class="pre">String.UTF16View</span></code>, which is a collection of unsigned 16-bit (<code class="docutils literal notranslate"><span class="pre">UInt16</span></code>) values, one for each 16-bit code unit in the string’s UTF-16 representation:</p>
<img alt="../_images/UTF16_2x.png" class="align-center" src="../_images/UTF16_2x.png" style="width: 477px;"/>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">codeUnit</span> <span class="k">in</span> <span class="nv">dogString</span>.<span class="nv">utf16</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">codeUnit</span><span class="p">)</span><span class="s"> "</span>, <span class="nv">terminator</span>: <span class="s">""</span>)
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">""</span>)
</li><li><span class="c">// Prints "68 111 103 8252 55357 56374 "</span>
</li></ol></div></div></div>
<p>Again, the first three <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> values (<code class="docutils literal notranslate"><span class="pre">68</span></code>, <code class="docutils literal notranslate"><span class="pre">111</span></code>, <code class="docutils literal notranslate"><span class="pre">103</span></code>) represent the characters <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">o</span></code>, and <code class="docutils literal notranslate"><span class="pre">g</span></code>, whose UTF-16 code units have the same values as in the string’s UTF-8 representation (because these Unicode scalars represent ASCII characters).</p>
<p>The fourth <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> value (<code class="docutils literal notranslate"><span class="pre">8252</span></code>) is a decimal equivalent of the hexadecimal value <code class="docutils literal notranslate"><span class="pre">203C</span></code>, which represents the Unicode scalar <code class="docutils literal notranslate"><span class="pre">U+203C</span></code> for the <code class="docutils literal notranslate"><span class="pre">DOUBLE</span> <span class="pre">EXCLAMATION</span> <span class="pre">MARK</span></code> character. This character can be represented as a single code unit in UTF-16.</p>
<p>The fifth and sixth <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> values (<code class="docutils literal notranslate"><span class="pre">55357</span></code> and <code class="docutils literal notranslate"><span class="pre">56374</span></code>) are a UTF-16 surrogate pair representation of the <code class="docutils literal notranslate"><span class="pre">DOG</span> <span class="pre">FACE</span></code> character. These values are a high-surrogate value of <code class="docutils literal notranslate"><span class="pre">U+D83D</span></code> (decimal value <code class="docutils literal notranslate"><span class="pre">55357</span></code>) and a low-surrogate value of <code class="docutils literal notranslate"><span class="pre">U+DC36</span></code> (decimal value <code class="docutils literal notranslate"><span class="pre">56374</span></code>).</p>
</div>
<div class="section" id="ID304">
<h3>Unicode Scalar Representation<a class="headerlink" href="StringsAndCharacters.html#ID304" title="Permalink to this headline">¶</a></h3>
<p>You can access a Unicode scalar representation of a <code class="docutils literal notranslate"><span class="pre">String</span></code> value by iterating over its <code class="docutils literal notranslate"><span class="pre">unicodeScalars</span></code> property. This property is of type <code class="docutils literal notranslate"><span class="pre">UnicodeScalarView</span></code>, which is a collection of values of type <code class="docutils literal notranslate"><span class="pre">UnicodeScalar</span></code>.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">UnicodeScalar</span></code> has a <code class="docutils literal notranslate"><span class="pre">value</span></code> property that returns the scalar’s 21-bit value, represented within a <code class="docutils literal notranslate"><span class="pre">UInt32</span></code> value:</p>
<img alt="../_images/UnicodeScalar_2x.png" class="align-center" src="../_images/UnicodeScalar_2x.png" style="width: 477px;"/>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">scalar</span> <span class="k">in</span> <span class="nv">dogString</span>.<span class="nv">unicodeScalars</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">scalar</span>.<span class="nv">value</span><span class="p">)</span><span class="s"> "</span>, <span class="nv">terminator</span>: <span class="s">""</span>)
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">""</span>)
</li><li><span class="c">// Prints "68 111 103 8252 128054 "</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">value</span></code> properties for the first three <code class="docutils literal notranslate"><span class="pre">UnicodeScalar</span></code> values (<code class="docutils literal notranslate"><span class="pre">68</span></code>, <code class="docutils literal notranslate"><span class="pre">111</span></code>, <code class="docutils literal notranslate"><span class="pre">103</span></code>) once again represent the characters <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">o</span></code>, and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p>
<p>The fourth <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> value (<code class="docutils literal notranslate"><span class="pre">8252</span></code>) is again a decimal equivalent of the hexadecimal value <code class="docutils literal notranslate"><span class="pre">203C</span></code>, which represents the Unicode scalar <code class="docutils literal notranslate"><span class="pre">U+203C</span></code> for the <code class="docutils literal notranslate"><span class="pre">DOUBLE</span> <span class="pre">EXCLAMATION</span> <span class="pre">MARK</span></code> character.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">value</span></code> property of the fifth and final <code class="docutils literal notranslate"><span class="pre">UnicodeScalar</span></code>, <code class="docutils literal notranslate"><span class="pre">128054</span></code>, is a decimal equivalent of the hexadecimal value <code class="docutils literal notranslate"><span class="pre">1F436</span></code>, which represents the Unicode scalar <code class="docutils literal notranslate"><span class="pre">U+1F436</span></code> for the <code class="docutils literal notranslate"><span class="pre">DOG</span> <span class="pre">FACE</span></code> character.</p>
<p>As an alternative to querying their <code class="docutils literal notranslate"><span class="pre">value</span></code> properties, each <code class="docutils literal notranslate"><span class="pre">UnicodeScalar</span></code> value can also be used to construct a new <code class="docutils literal notranslate"><span class="pre">String</span></code> value, such as with string interpolation:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">scalar</span> <span class="k">in</span> <span class="nv">dogString</span>.<span class="nv">unicodeScalars</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">scalar</span><span class="p">)</span><span class="s"> "</span>)
</li><li>}
</li><li><span class="c">// D</span>
</li><li><span class="c">// o</span>
</li><li><span class="c">// g</span>
</li><li><span class="c">// ‼</span>
</li><li><span class="c">// 🐶</span>
</li></ol></div></div></div>
</div>
</div>
</div><div class="section" id="collection-types">
<h1>Collection Types<a class="headerlink" href="CollectionTypes.html#collection-types" title="Permalink to this headline">¶</a></h1>
<p>Swift provides three primary <em>collection types</em>, known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations.</p>
<img alt="../_images/CollectionTypes_intro_2x.png" class="align-center" src="../_images/CollectionTypes_intro_2x.png" style="width: 670px;"/>
<p>Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store. This means that you cannot insert a value of the wrong type into a collection by mistake. It also means you can be confident about the type of values you will retrieve from a collection.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Swift’s array, set, and dictionary types are implemented as <em>generic collections</em>. For more about generic types and collections, see <a class="reference internal" href="Generics.html"><span class="doc">Generics</span></a>.</p>
</div>
<div class="section" id="ID106">
<h2>Mutability of Collections<a class="headerlink" href="CollectionTypes.html#ID106" title="Permalink to this headline">¶</a></h2>
<p>If you create an array, a set, or a dictionary, and assign it to a variable, the collection that is created will be <em>mutable</em>. This means that you can change (or <em>mutate</em>) the collection after it’s created by adding, removing, or changing items in the collection. If you assign an array, a set, or a dictionary to a constant, that collection is <em>immutable</em>, and its size and contents cannot be changed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is good practice to create immutable collections in all cases where the collection does not need to change. Doing so makes it easier for you to reason about your code and enables the Swift compiler to optimize the performance of the collections you create.</p>
</div>
</div>
<div class="section" id="ID107">
<h2>Arrays<a class="headerlink" href="CollectionTypes.html#ID107" title="Permalink to this headline">¶</a></h2>
<p>An <em>array</em> stores values of the same type in an ordered list. The same value can appear in an array multiple times at different positions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">Array</span></code> type is bridged to Foundation’s <code class="docutils literal notranslate"><span class="pre">NSArray</span></code> class.</p>
<p class="last">For more information about using <code class="docutils literal notranslate"><span class="pre">Array</span></code> with Foundation and Cocoa, see <a class="reference external" href="https://developer.apple.com/documentation/swift/array#2846730">Bridging Between Array and NSArray</a>.</p>
</div>
<div class="section" id="ID108">
<h3>Array Type Shorthand Syntax<a class="headerlink" href="CollectionTypes.html#ID108" title="Permalink to this headline">¶</a></h3>
<p>The type of a Swift array is written in full as <code class="docutils literal notranslate"><span class="pre">Array&lt;Element&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">Element</span></code> is the type of values the array is allowed to store. You can also write the type of an array in shorthand form as <code class="docutils literal notranslate"><span class="pre">[Element]</span></code>. Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array.</p>
</div>
<div class="section" id="ID500">
<h3>Creating an Empty Array<a class="headerlink" href="CollectionTypes.html#ID500" title="Permalink to this headline">¶</a></h3>
<p>You can create an empty array of a certain type using initializer syntax:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">someInts</span> = [<span class="nv">Int</span>]()
</li><li><span class="nv">print</span>(<span class="s">"someInts is of type [Int] with </span>\<span class="p">(</span><span class="nv">someInts</span>.<span class="nv">count</span><span class="p">)</span><span class="s"> items."</span>)
</li><li><span class="c">// Prints "someInts is of type [Int] with 0 items."</span>
</li></ol></div></div></div>
<p>Note that the type of the <code class="docutils literal notranslate"><span class="pre">someInts</span></code> variable is inferred to be <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> from the type of the initializer.</p>
<p>Alternatively, if the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty array with an empty array literal, which is written as <code class="docutils literal notranslate"><span class="pre">[]</span></code> (an empty pair of square brackets):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">someInts</span>.<span class="nv">append</span>(<span class="m">3</span>)
</li><li><span class="c">// someInts now contains 1 value of type Int</span>
</li><li><span class="nv">someInts</span> = []
</li><li><span class="c">// someInts is now an empty array, but is still of type [Int]</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID501">
<h3>Creating an Array with a Default Value<a class="headerlink" href="CollectionTypes.html#ID501" title="Permalink to this headline">¶</a></h3>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">Array</span></code> type also provides an initializer for creating an array of a certain size with all of its values set to the same default value. You pass this initializer a default value of the appropriate type (called <code class="docutils literal notranslate"><span class="pre">repeating</span></code>): and the number of times that value is repeated in the new array (called <code class="docutils literal notranslate"><span class="pre">count</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">threeDoubles</span> = <span class="nv">Array</span>(<span class="nv">repeating</span>: <span class="m">0.0</span>, <span class="nv">count</span>: <span class="m">3</span>)
</li><li><span class="c">// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID502">
<h3>Creating an Array by Adding Two Arrays Together<a class="headerlink" href="CollectionTypes.html#ID502" title="Permalink to this headline">¶</a></h3>
<p>You can create a new array by adding together two existing arrays with compatible types with the addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>). The new array’s type is inferred from the type of the two arrays you add together:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">anotherThreeDoubles</span> = <span class="nv">Array</span>(<span class="nv">repeating</span>: <span class="m">2.5</span>, <span class="nv">count</span>: <span class="m">3</span>)
</li><li><span class="c">// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</span>
</li><li>
</li><li><span class="k">var</span> <span class="nv">sixDoubles</span> = <span class="nv">threeDoubles</span> + <span class="nv">anotherThreeDoubles</span>
</li><li><span class="c">// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID109">
<h3>Creating an Array with an Array Literal<a class="headerlink" href="CollectionTypes.html#ID109" title="Permalink to this headline">¶</a></h3>
<p>You can also initialize an array with an <em>array literal</em>, which is a shorthand way to write one or more values as an array collection. An array literal is written as a list of values, separated by commas, surrounded by a pair of square brackets:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>[<span class="gi">value 1</span>, <span class="gi">value 2</span>, <span class="gi">value 3</span>]
</li></ol></div></div></div>
<p>The example below creates an array called <code class="docutils literal notranslate"><span class="pre">shoppingList</span></code> to store <code class="docutils literal notranslate"><span class="pre">String</span></code> values:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">shoppingList</span>: [<span class="nc">String</span>] = [<span class="s">"Eggs"</span>, <span class="s">"Milk"</span>]
</li><li><span class="c">// shoppingList has been initialized with two initial items</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">shoppingList</span></code> variable is declared as “an array of string values”, written as <code class="docutils literal notranslate"><span class="pre">[String]</span></code>. Because this particular array has specified a value type of <code class="docutils literal notranslate"><span class="pre">String</span></code>, it is allowed to store <code class="docutils literal notranslate"><span class="pre">String</span></code> values only. Here, the <code class="docutils literal notranslate"><span class="pre">shoppingList</span></code> array is initialized with two <code class="docutils literal notranslate"><span class="pre">String</span></code> values (<code class="docutils literal notranslate"><span class="pre">"Eggs"</span></code> and <code class="docutils literal notranslate"><span class="pre">"Milk"</span></code>), written within an array literal.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">shoppingList</span></code> array is declared as a variable (with the <code class="docutils literal notranslate"><span class="pre">var</span></code> introducer) and not a constant (with the <code class="docutils literal notranslate"><span class="pre">let</span></code> introducer) because more items are added to the shopping list in the examples below.</p>
</div>
<p>In this case, the array literal contains two <code class="docutils literal notranslate"><span class="pre">String</span></code> values and nothing else. This matches the type of the <code class="docutils literal notranslate"><span class="pre">shoppingList</span></code> variable’s declaration (an array that can only contain <code class="docutils literal notranslate"><span class="pre">String</span></code> values), and so the assignment of the array literal is permitted as a way to initialize <code class="docutils literal notranslate"><span class="pre">shoppingList</span></code> with two initial items.</p>
<p>Thanks to Swift’s type inference, you don’t have to write the type of the array if you’re initializing it with an array literal containing values of the same type. The initialization of <code class="docutils literal notranslate"><span class="pre">shoppingList</span></code> could have been written in a shorter form instead:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">shoppingList</span> = [<span class="s">"Eggs"</span>, <span class="s">"Milk"</span>]
</li></ol></div></div></div>
<p>Because all values in the array literal are of the same type, Swift can infer that <code class="docutils literal notranslate"><span class="pre">[String]</span></code> is the correct type to use for the <code class="docutils literal notranslate"><span class="pre">shoppingList</span></code> variable.</p>
</div>
<div class="section" id="ID110">
<h3>Accessing and Modifying an Array<a class="headerlink" href="CollectionTypes.html#ID110" title="Permalink to this headline">¶</a></h3>
<p>You access and modify an array through its methods and properties, or by using subscript syntax.</p>
<p>To find out the number of items in an array, check its read-only <code class="docutils literal notranslate"><span class="pre">count</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"The shopping list contains </span>\<span class="p">(</span><span class="nv">shoppingList</span>.<span class="nv">count</span><span class="p">)</span><span class="s"> items."</span>)
</li><li><span class="c">// Prints "The shopping list contains 2 items."</span>
</li></ol></div></div></div>
<p>Use the Boolean <code class="docutils literal notranslate"><span class="pre">isEmpty</span></code> property as a shortcut for checking whether the <code class="docutils literal notranslate"><span class="pre">count</span></code> property is equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">shoppingList</span>.<span class="nv">isEmpty</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The shopping list is empty."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The shopping list is not empty."</span>)
</li><li>}
</li><li><span class="c">// Prints "The shopping list is not empty."</span>
</li></ol></div></div></div>
<p>You can add a new item to the end of an array by calling the array’s <code class="docutils literal notranslate"><span class="pre">append(_:)</span></code> method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">shoppingList</span>.<span class="nv">append</span>(<span class="s">"Flour"</span>)
</li><li><span class="c">// shoppingList now contains 3 items, and someone is making pancakes</span>
</li></ol></div></div></div>
<p>Alternatively, append an array of one or more compatible items with the addition assignment operator (<code class="docutils literal notranslate"><span class="pre">+=</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">shoppingList</span> += [<span class="s">"Baking Powder"</span>]
</li><li><span class="c">// shoppingList now contains 4 items</span>
</li><li><span class="nv">shoppingList</span> += [<span class="s">"Chocolate Spread"</span>, <span class="s">"Cheese"</span>, <span class="s">"Butter"</span>]
</li><li><span class="c">// shoppingList now contains 7 items</span>
</li></ol></div></div></div>
<p>Retrieve a value from the array by using <em>subscript syntax</em>, passing the index of the value you want to retrieve within square brackets immediately after the name of the array:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">firstItem</span> = <span class="nv">shoppingList</span>[<span class="m">0</span>]
</li><li><span class="c">// firstItem is equal to "Eggs"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The first item in the array has an index of <code class="docutils literal notranslate"><span class="pre">0</span></code>, not <code class="docutils literal notranslate"><span class="pre">1</span></code>. Arrays in Swift are always zero-indexed.</p>
</div>
<p>You can use subscript syntax to change an existing value at a given index:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">shoppingList</span>[<span class="m">0</span>] = <span class="s">"Six eggs"</span>
</li><li><span class="c">// the first item in the list is now equal to "Six eggs" rather than "Eggs"</span>
</li></ol></div></div></div>
<p>When you use subscript syntax, the index you specify needs to be valid. For example, writing <code class="docutils literal notranslate"><span class="pre">shoppingList[shoppingList.count]</span> <span class="pre">=</span> <span class="pre">"Salt"</span></code> to try to append an item to the end of the array results in a runtime error.</p>
<p>You can also use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing. The following example replaces <code class="docutils literal notranslate"><span class="pre">"Chocolate</span> <span class="pre">Spread"</span></code>, <code class="docutils literal notranslate"><span class="pre">"Cheese"</span></code>, and <code class="docutils literal notranslate"><span class="pre">"Butter"</span></code> with <code class="docutils literal notranslate"><span class="pre">"Bananas"</span></code> and <code class="docutils literal notranslate"><span class="pre">"Apples"</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">shoppingList</span>[<span class="m">4</span>...<span class="m">6</span>] = [<span class="s">"Bananas"</span>, <span class="s">"Apples"</span>]
</li><li><span class="c">// shoppingList now contains 6 items</span>
</li></ol></div></div></div>
<p>To insert an item into the array at a specified index, call the array’s <code class="docutils literal notranslate"><span class="pre">insert(_:at:)</span></code> method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">shoppingList</span>.<span class="nv">insert</span>(<span class="s">"Maple Syrup"</span>, <span class="nv">at</span>: <span class="m">0</span>)
</li><li><span class="c">// shoppingList now contains 7 items</span>
</li><li><span class="c">// "Maple Syrup" is now the first item in the list</span>
</li></ol></div></div></div>
<p>This call to the <code class="docutils literal notranslate"><span class="pre">insert(_:at:)</span></code> method inserts a new item with a value of <code class="docutils literal notranslate"><span class="pre">"Maple</span> <span class="pre">Syrup"</span></code> at the very beginning of the shopping list, indicated by an index of <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Similarly, you remove an item from the array with the <code class="docutils literal notranslate"><span class="pre">remove(at:)</span></code> method. This method removes the item at the specified index and returns the removed item (although you can ignore the returned value if you do not need it):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">mapleSyrup</span> = <span class="nv">shoppingList</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>)
</li><li><span class="c">// the item that was at index 0 has just been removed</span>
</li><li><span class="c">// shoppingList now contains 6 items, and no Maple Syrup</span>
</li><li><span class="c">// the mapleSyrup constant is now equal to the removed "Maple Syrup" string</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you try to access or modify a value for an index that is outside of an array’s existing bounds, you will trigger a runtime error. You can check that an index is valid before using it by comparing it to the array’s <code class="docutils literal notranslate"><span class="pre">count</span></code> property. The largest valid index in an array is <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">-</span> <span class="pre">1</span></code> because arrays are indexed from zero—however, when <code class="docutils literal notranslate"><span class="pre">count</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code> (meaning the array is empty), there are no valid indexes.</p>
</div>
<p>Any gaps in an array are closed when an item is removed, and so the value at index <code class="docutils literal notranslate"><span class="pre">0</span></code> is once again equal to <code class="docutils literal notranslate"><span class="pre">"Six</span> <span class="pre">eggs"</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">firstItem</span> = <span class="nv">shoppingList</span>[<span class="m">0</span>]
</li><li><span class="c">// firstItem is now equal to "Six eggs"</span>
</li></ol></div></div></div>
<p>If you want to remove the final item from an array, use the <code class="docutils literal notranslate"><span class="pre">removeLast()</span></code> method rather than the <code class="docutils literal notranslate"><span class="pre">remove(at:)</span></code> method to avoid the need to query the array’s <code class="docutils literal notranslate"><span class="pre">count</span></code> property. Like the <code class="docutils literal notranslate"><span class="pre">remove(at:)</span></code> method, <code class="docutils literal notranslate"><span class="pre">removeLast()</span></code> returns the removed item:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">apples</span> = <span class="nv">shoppingList</span>.<span class="nv">removeLast</span>()
</li><li><span class="c">// the last item in the array has just been removed</span>
</li><li><span class="c">// shoppingList now contains 5 items, and no apples</span>
</li><li><span class="c">// the apples constant is now equal to the removed "Apples" string</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID111">
<h3>Iterating Over an Array<a class="headerlink" href="CollectionTypes.html#ID111" title="Permalink to this headline">¶</a></h3>
<p>You can iterate over the entire set of values in an array with the <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">item</span> <span class="k">in</span> <span class="nv">shoppingList</span> {
</li><li> <span class="nv">print</span>(<span class="nv">item</span>)
</li><li>}
</li><li><span class="c">// Six eggs</span>
</li><li><span class="c">// Milk</span>
</li><li><span class="c">// Flour</span>
</li><li><span class="c">// Baking Powder</span>
</li><li><span class="c">// Bananas</span>
</li></ol></div></div></div>
<p>If you need the integer index of each item as well as its value, use the <code class="docutils literal notranslate"><span class="pre">enumerated()</span></code> method to iterate over the array instead. For each item in the array, the <code class="docutils literal notranslate"><span class="pre">enumerated()</span></code> method returns a tuple composed of an integer and the item. The integers start at zero and count up by one for each item; if you enumerate over a whole array, these integers match the items’ indices. You can decompose the tuple into temporary constants or variables as part of the iteration:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> (<span class="nv">index</span>, <span class="nv">value</span>) <span class="k">in</span> <span class="nv">shoppingList</span>.<span class="nv">enumerated</span>() {
</li><li> <span class="nv">print</span>(<span class="s">"Item </span>\<span class="p">(</span><span class="nv">index</span> + <span class="m">1</span><span class="p">)</span><span class="s">: </span>\<span class="p">(</span><span class="nv">value</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Item 1: Six eggs</span>
</li><li><span class="c">// Item 2: Milk</span>
</li><li><span class="c">// Item 3: Flour</span>
</li><li><span class="c">// Item 4: Baking Powder</span>
</li><li><span class="c">// Item 5: Bananas</span>
</li></ol></div></div></div>
<p>For more about the <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop, see <a class="reference internal" href="ControlFlow.html#ID121"><span class="std std-ref">For-In Loops</span></a>.</p>
</div>
</div>
<div class="section" id="ID484">
<h2>Sets<a class="headerlink" href="CollectionTypes.html#ID484" title="Permalink to this headline">¶</a></h2>
<p>A <em>set</em> stores distinct values of the same type in a collection with no defined ordering. You can use a set instead of an array when the order of items is not important, or when you need to ensure that an item only appears once.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">Set</span></code> type is bridged to Foundation’s <code class="docutils literal notranslate"><span class="pre">NSSet</span></code> class.</p>
<p class="last">For more information about using <code class="docutils literal notranslate"><span class="pre">Set</span></code> with Foundation and Cocoa, see <a class="reference external" href="https://developer.apple.com/documentation/swift/set#2845530">Bridging Between Set and NSSet</a>.</p>
</div>
<div class="section" id="ID493">
<h3>Hash Values for Set Types<a class="headerlink" href="CollectionTypes.html#ID493" title="Permalink to this headline">¶</a></h3>
<p>A type must be <em>hashable</em> in order to be stored in a set—that is, the type must provide a way to compute a <em>hash value</em> for itself. A hash value is an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value that is the same for all objects that compare equally, such that if <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code>, it follows that <code class="docutils literal notranslate"><span class="pre">a.hashValue</span> <span class="pre">==</span> <span class="pre">b.hashValue</span></code>.</p>
<p>All of Swift’s basic types (such as <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Double</span></code>, and <code class="docutils literal notranslate"><span class="pre">Bool</span></code>) are hashable by default, and can be used as set value types or dictionary key types. Enumeration case values without associated values (as described in <a class="reference internal" href="Enumerations.html"><span class="doc">Enumerations</span></a>) are also hashable by default.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>You can use your own custom types as set value types or dictionary key types by making them conform to the <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> protocol from Swift’s standard library. Types that conform to the <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> protocol must provide a gettable <code class="docutils literal notranslate"><span class="pre">Int</span></code> property called <code class="docutils literal notranslate"><span class="pre">hashValue</span></code>. The value returned by a type’s <code class="docutils literal notranslate"><span class="pre">hashValue</span></code> property is not required to be the same across different executions of the same program, or in different programs.</p>
<p>Because the <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> protocol conforms to <code class="docutils literal notranslate"><span class="pre">Equatable</span></code>, conforming types must also provide an implementation of the equals operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>). The <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol requires any conforming implementation of <code class="docutils literal notranslate"><span class="pre">==</span></code> to be an equivalence relation. That is, an implementation of <code class="docutils literal notranslate"><span class="pre">==</span></code> must satisfy the following three conditions, for all values <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">a</span></code> (Reflexivity)</li>
<li><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> implies <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">==</span> <span class="pre">a</span></code> (Symmetry)</li>
<li><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span> <span class="pre">==</span> <span class="pre">c</span></code> implies <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">c</span></code> (Transitivity)</li>
</ul>
<p class="last">For more information about conforming to protocols, see <a class="reference internal" href="Protocols.html"><span class="doc">Protocols</span></a>.</p>
</div>
</div>
<div class="section" id="ID485">
<h3>Set Type Syntax<a class="headerlink" href="CollectionTypes.html#ID485" title="Permalink to this headline">¶</a></h3>
<p>The type of a Swift set is written as <code class="docutils literal notranslate"><span class="pre">Set&lt;Element&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">Element</span></code> is the type that the set is allowed to store. Unlike arrays, sets do not have an equivalent shorthand form.</p>
</div>
<div class="section" id="ID503">
<h3>Creating and Initializing an Empty Set<a class="headerlink" href="CollectionTypes.html#ID503" title="Permalink to this headline">¶</a></h3>
<p>You can create an empty set of a certain type using initializer syntax:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">letters</span> = <span class="nv">Set</span>&lt;<span class="nc">Character</span>&gt;()
</li><li><span class="nv">print</span>(<span class="s">"letters is of type Set&lt;Character&gt; with </span>\<span class="p">(</span><span class="nv">letters</span>.<span class="nv">count</span><span class="p">)</span><span class="s"> items."</span>)
</li><li><span class="c">// Prints "letters is of type Set&lt;Character&gt; with 0 items."</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The type of the <code class="docutils literal notranslate"><span class="pre">letters</span></code> variable is inferred to be <code class="docutils literal notranslate"><span class="pre">Set&lt;Character&gt;</span></code>, from the type of the initializer.</p>
</div>
<p>Alternatively, if the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty set with an empty array literal:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">letters</span>.<span class="nv">insert</span>(<span class="s">"a"</span>)
</li><li><span class="c">// letters now contains 1 value of type Character</span>
</li><li><span class="nv">letters</span> = []
</li><li><span class="c">// letters is now an empty set, but is still of type Set&lt;Character&gt;</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID504">
<h3>Creating a Set with an Array Literal<a class="headerlink" href="CollectionTypes.html#ID504" title="Permalink to this headline">¶</a></h3>
<p>You can also initialize a set with an array literal, as a shorthand way to write one or more values as a set collection.</p>
<p>The example below creates a set called <code class="docutils literal notranslate"><span class="pre">favoriteGenres</span></code> to store <code class="docutils literal notranslate"><span class="pre">String</span></code> values:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">favoriteGenres</span>: <span class="nc">Set</span>&lt;<span class="nc">String</span>&gt; = [<span class="s">"Rock"</span>, <span class="s">"Classical"</span>, <span class="s">"Hip hop"</span>]
</li><li><span class="c">// favoriteGenres has been initialized with three initial items</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">favoriteGenres</span></code> variable is declared as “a set of <code class="docutils literal notranslate"><span class="pre">String</span></code> values”, written as <code class="docutils literal notranslate"><span class="pre">Set&lt;String&gt;</span></code>. Because this particular set has specified a value type of <code class="docutils literal notranslate"><span class="pre">String</span></code>, it is <em>only</em> allowed to store <code class="docutils literal notranslate"><span class="pre">String</span></code> values. Here, the <code class="docutils literal notranslate"><span class="pre">favoriteGenres</span></code> set is initialized with three <code class="docutils literal notranslate"><span class="pre">String</span></code> values (<code class="docutils literal notranslate"><span class="pre">"Rock"</span></code>, <code class="docutils literal notranslate"><span class="pre">"Classical"</span></code>, and <code class="docutils literal notranslate"><span class="pre">"Hip</span> <span class="pre">hop"</span></code>), written within an array literal.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">favoriteGenres</span></code> set is declared as a variable (with the <code class="docutils literal notranslate"><span class="pre">var</span></code> introducer) and not a constant (with the <code class="docutils literal notranslate"><span class="pre">let</span></code> introducer) because items are added and removed in the examples below.</p>
</div>
<p>A set type cannot be inferred from an array literal alone, so the type <code class="docutils literal notranslate"><span class="pre">Set</span></code> must be explicitly declared. However, because of Swift’s type inference, you don’t have to write the type of the set’s elements if you’re initializing it with an array literal that contains values of just one type. The initialization of <code class="docutils literal notranslate"><span class="pre">favoriteGenres</span></code> could have been written in a shorter form instead:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">favoriteGenres</span>: <span class="nc">Set</span> = [<span class="s">"Rock"</span>, <span class="s">"Classical"</span>, <span class="s">"Hip hop"</span>]
</li></ol></div></div></div>
<p>Because all values in the array literal are of the same type, Swift can infer that <code class="docutils literal notranslate"><span class="pre">Set&lt;String&gt;</span></code> is the correct type to use for the <code class="docutils literal notranslate"><span class="pre">favoriteGenres</span></code> variable.</p>
</div>
<div class="section" id="ID488">
<h3>Accessing and Modifying a Set<a class="headerlink" href="CollectionTypes.html#ID488" title="Permalink to this headline">¶</a></h3>
<p>You access and modify a set through its methods and properties.</p>
<p>To find out the number of items in a set, check its read-only <code class="docutils literal notranslate"><span class="pre">count</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"I have </span>\<span class="p">(</span><span class="nv">favoriteGenres</span>.<span class="nv">count</span><span class="p">)</span><span class="s"> favorite music genres."</span>)
</li><li><span class="c">// Prints "I have 3 favorite music genres."</span>
</li></ol></div></div></div>
<p>Use the Boolean <code class="docutils literal notranslate"><span class="pre">isEmpty</span></code> property as a shortcut for checking whether the <code class="docutils literal notranslate"><span class="pre">count</span></code> property is equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">favoriteGenres</span>.<span class="nv">isEmpty</span> {
</li><li> <span class="nv">print</span>(<span class="s">"As far as music goes, I'm not picky."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"I have particular music preferences."</span>)
</li><li>}
</li><li><span class="c">// Prints "I have particular music preferences."</span>
</li></ol></div></div></div>
<p>You can add a new item into a set by calling the set’s <code class="docutils literal notranslate"><span class="pre">insert(_:)</span></code> method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">favoriteGenres</span>.<span class="nv">insert</span>(<span class="s">"Jazz"</span>)
</li><li><span class="c">// favoriteGenres now contains 4 items</span>
</li></ol></div></div></div>
<p>You can remove an item from a set by calling the set’s <code class="docutils literal notranslate"><span class="pre">remove(_:)</span></code> method, which removes the item if it’s a member of the set, and returns the removed value, or returns <code class="docutils literal notranslate"><span class="pre">nil</span></code> if the set did not contain it. Alternatively, all items in a set can be removed with its <code class="docutils literal notranslate"><span class="pre">removeAll()</span></code> method.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">removedGenre</span> = <span class="nv">favoriteGenres</span>.<span class="nv">remove</span>(<span class="s">"Rock"</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">removedGenre</span><span class="p">)</span><span class="s">? I'm over it."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"I never much cared for that."</span>)
</li><li>}
</li><li><span class="c">// Prints "Rock? I'm over it."</span>
</li></ol></div></div></div>
<p>To check whether a set contains a particular item, use the <code class="docutils literal notranslate"><span class="pre">contains(_:)</span></code> method.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">favoriteGenres</span>.<span class="nv">contains</span>(<span class="s">"Funk"</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"I get up on the good foot."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It's too funky in here."</span>)
</li><li>}
</li><li><span class="c">// Prints "It's too funky in here."</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID489">
<h3>Iterating Over a Set<a class="headerlink" href="CollectionTypes.html#ID489" title="Permalink to this headline">¶</a></h3>
<p>You can iterate over the values in a set with a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">genre</span> <span class="k">in</span> <span class="nv">favoriteGenres</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">genre</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Classical</span>
</li><li><span class="c">// Jazz</span>
</li><li><span class="c">// Hip hop</span>
</li></ol></div></div></div>
<p>For more about the <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop, see <a class="reference internal" href="ControlFlow.html#ID121"><span class="std std-ref">For-In Loops</span></a>.</p>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">Set</span></code> type does not have a defined ordering. To iterate over the values of a set in a specific order, use the <code class="docutils literal notranslate"><span class="pre">sorted()</span></code> method, which returns the set’s elements as an array sorted using the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">genre</span> <span class="k">in</span> <span class="nv">favoriteGenres</span>.<span class="nv">sorted</span>() {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">genre</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Classical</span>
</li><li><span class="c">// Hip hop</span>
</li><li><span class="c">// Jazz</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID490">
<h2>Performing Set Operations<a class="headerlink" href="CollectionTypes.html#ID490" title="Permalink to this headline">¶</a></h2>
<p>You can efficiently perform fundamental set operations, such as combining two sets together, determining which values two sets have in common, or determining whether two sets contain all, some, or none of the same values.</p>
<div class="section" id="ID505">
<h3>Fundamental Set Operations<a class="headerlink" href="CollectionTypes.html#ID505" title="Permalink to this headline">¶</a></h3>
<p>The illustration below depicts two sets—<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>—with the results of various set operations represented by the shaded regions.</p>
<img alt="../_images/setVennDiagram_2x.png" class="align-center" src="../_images/setVennDiagram_2x.png" style="width: 561px;"/>
<ul class="simple">
<li>Use the <code class="docutils literal notranslate"><span class="pre">intersection(_:)</span></code> method to create a new set with only the values common to both sets.</li>
<li>Use the <code class="docutils literal notranslate"><span class="pre">symmetricDifference(_:)</span></code> method to create a new set with values in either set, but not both.</li>
<li>Use the <code class="docutils literal notranslate"><span class="pre">union(_:)</span></code> method to create a new set with all of the values in both sets.</li>
<li>Use the <code class="docutils literal notranslate"><span class="pre">subtracting(_:)</span></code> method to create a new set with values not in the specified set.</li>
</ul>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">oddDigits</span>: <span class="nc">Set</span> = [<span class="m">1</span>, <span class="m">3</span>, <span class="m">5</span>, <span class="m">7</span>, <span class="m">9</span>]
</li><li><span class="k">let</span> <span class="nv">evenDigits</span>: <span class="nc">Set</span> = [<span class="m">0</span>, <span class="m">2</span>, <span class="m">4</span>, <span class="m">6</span>, <span class="m">8</span>]
</li><li><span class="k">let</span> <span class="nv">singleDigitPrimeNumbers</span>: <span class="nc">Set</span> = [<span class="m">2</span>, <span class="m">3</span>, <span class="m">5</span>, <span class="m">7</span>]
</li><li>
</li><li><span class="nv">oddDigits</span>.<span class="nv">union</span>(<span class="nv">evenDigits</span>).<span class="nv">sorted</span>()
</li><li><span class="c">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</li><li><span class="nv">oddDigits</span>.<span class="nv">intersection</span>(<span class="nv">evenDigits</span>).<span class="nv">sorted</span>()
</li><li><span class="c">// []</span>
</li><li><span class="nv">oddDigits</span>.<span class="nv">subtracting</span>(<span class="nv">singleDigitPrimeNumbers</span>).<span class="nv">sorted</span>()
</li><li><span class="c">// [1, 9]</span>
</li><li><span class="nv">oddDigits</span>.<span class="nv">symmetricDifference</span>(<span class="nv">singleDigitPrimeNumbers</span>).<span class="nv">sorted</span>()
</li><li><span class="c">// [1, 2, 9]</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID506">
<h3>Set Membership and Equality<a class="headerlink" href="CollectionTypes.html#ID506" title="Permalink to this headline">¶</a></h3>
<p>The illustration below depicts three sets—<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>—with overlapping regions representing elements shared among sets. Set <code class="docutils literal notranslate"><span class="pre">a</span></code> is a <em>superset</em> of set <code class="docutils literal notranslate"><span class="pre">b</span></code>, because <code class="docutils literal notranslate"><span class="pre">a</span></code> contains all elements in <code class="docutils literal notranslate"><span class="pre">b</span></code>. Conversely, set <code class="docutils literal notranslate"><span class="pre">b</span></code> is a <em>subset</em> of set <code class="docutils literal notranslate"><span class="pre">a</span></code>, because all elements in <code class="docutils literal notranslate"><span class="pre">b</span></code> are also contained by <code class="docutils literal notranslate"><span class="pre">a</span></code>. Set <code class="docutils literal notranslate"><span class="pre">b</span></code> and set <code class="docutils literal notranslate"><span class="pre">c</span></code> are <em>disjoint</em> with one another, because they share no elements in common.</p>
<img alt="../_images/setEulerDiagram_2x.png" class="align-center" src="../_images/setEulerDiagram_2x.png" style="width: 551px;"/>
<ul class="simple">
<li>Use the “is equal” operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) to determine whether two sets contain all of the same values.</li>
<li>Use the <code class="docutils literal notranslate"><span class="pre">isSubset(of:)</span></code> method to determine whether all of the values of a set are contained in the specified set.</li>
<li>Use the <code class="docutils literal notranslate"><span class="pre">isSuperset(of:)</span></code> method to determine whether a set contains all of the values in a specified set.</li>
<li>Use the <code class="docutils literal notranslate"><span class="pre">isStrictSubset(of:)</span></code> or <code class="docutils literal notranslate"><span class="pre">isStrictSuperset(of:)</span></code> methods to determine whether a set is a subset or superset, but not equal to, a specified set.</li>
<li>Use the <code class="docutils literal notranslate"><span class="pre">isDisjoint(with:)</span></code> method to determine whether two sets have no values in common.</li>
</ul>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">houseAnimals</span>: <span class="nc">Set</span> = [<span class="s">"🐶"</span>, <span class="s">"🐱"</span>]
</li><li><span class="k">let</span> <span class="nv">farmAnimals</span>: <span class="nc">Set</span> = [<span class="s">"🐮"</span>, <span class="s">"🐔"</span>, <span class="s">"🐑"</span>, <span class="s">"🐶"</span>, <span class="s">"🐱"</span>]
</li><li><span class="k">let</span> <span class="nv">cityAnimals</span>: <span class="nc">Set</span> = [<span class="s">"🐦"</span>, <span class="s">"🐭"</span>]
</li><li>
</li><li><span class="nv">houseAnimals</span>.<span class="nv">isSubset</span>(<span class="nv">of</span>: <span class="nv">farmAnimals</span>)
</li><li><span class="c">// true</span>
</li><li><span class="nv">farmAnimals</span>.<span class="nv">isSuperset</span>(<span class="nv">of</span>: <span class="nv">houseAnimals</span>)
</li><li><span class="c">// true</span>
</li><li><span class="nv">farmAnimals</span>.<span class="nv">isDisjoint</span>(<span class="nv">with</span>: <span class="nv">cityAnimals</span>)
</li><li><span class="c">// true</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID113">
<h2>Dictionaries<a class="headerlink" href="CollectionTypes.html#ID113" title="Permalink to this headline">¶</a></h2>
<p>A <em>dictionary</em> stores associations between keys of the same type and values of the same type in a collection with no defined ordering. Each value is associated with a unique <em>key</em>, which acts as an identifier for that value within the dictionary. Unlike items in an array, items in a dictionary do not have a specified order. You use a dictionary when you need to look up values based on their identifier, in much the same way that a real-world dictionary is used to look up the definition for a particular word.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> type is bridged to Foundation’s <code class="docutils literal notranslate"><span class="pre">NSDictionary</span></code> class.</p>
<p class="last">For more information about using <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> with Foundation and Cocoa, see <a class="reference external" href="https://developer.apple.com/documentation/swift/dictionary#2846239">Bridging Between Dictionary and NSDictionary</a>.</p>
</div>
<div class="section" id="ID114">
<h3>Dictionary Type Shorthand Syntax<a class="headerlink" href="CollectionTypes.html#ID114" title="Permalink to this headline">¶</a></h3>
<p>The type of a Swift dictionary is written in full as <code class="docutils literal notranslate"><span class="pre">Dictionary&lt;Key,</span> <span class="pre">Value&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">Key</span></code> is the type of value that can be used as a dictionary key, and <code class="docutils literal notranslate"><span class="pre">Value</span></code> is the type of value that the dictionary stores for those keys.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A dictionary <code class="docutils literal notranslate"><span class="pre">Key</span></code> type must conform to the <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> protocol, like a set’s value type.</p>
</div>
<p>You can also write the type of a dictionary in shorthand form as <code class="docutils literal notranslate"><span class="pre">[Key:</span> <span class="pre">Value]</span></code>. Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of a dictionary.</p>
</div>
<div class="section" id="ID118">
<h3>Creating an Empty Dictionary<a class="headerlink" href="CollectionTypes.html#ID118" title="Permalink to this headline">¶</a></h3>
<p>As with arrays, you can create an empty <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> of a certain type by using initializer syntax:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">namesOfIntegers</span> = [<span class="nv">Int</span>: <span class="nv">String</span>]()
</li><li><span class="c">// namesOfIntegers is an empty [Int: String] dictionary</span>
</li></ol></div></div></div>
<p>This example creates an empty dictionary of type <code class="docutils literal notranslate"><span class="pre">[Int:</span> <span class="pre">String]</span></code> to store human-readable names of integer values. Its keys are of type <code class="docutils literal notranslate"><span class="pre">Int</span></code>, and its values are of type <code class="docutils literal notranslate"><span class="pre">String</span></code>.</p>
<p>If the context already provides type information, you can create an empty dictionary with an empty dictionary literal, which is written as <code class="docutils literal notranslate"><span class="pre">[:]</span></code> (a colon inside a pair of square brackets):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">namesOfIntegers</span>[<span class="m">16</span>] = <span class="s">"sixteen"</span>
</li><li><span class="c">// namesOfIntegers now contains 1 key-value pair</span>
</li><li><span class="nv">namesOfIntegers</span> = [:]
</li><li><span class="c">// namesOfIntegers is once again an empty dictionary of type [Int: String]</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID507">
<h3>Creating a Dictionary with a Dictionary Literal<a class="headerlink" href="CollectionTypes.html#ID507" title="Permalink to this headline">¶</a></h3>
<p>You can also initialize a dictionary with a <em>dictionary literal</em>, which has a similar syntax to the array literal seen earlier. A dictionary literal is a shorthand way to write one or more key-value pairs as a <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> collection.</p>
<p>A <em>key-value pair</em> is a combination of a key and a value. In a dictionary literal, the key and value in each key-value pair are separated by a colon. The key-value pairs are written as a list, separated by commas, surrounded by a pair of square brackets:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>[<span class="gi">key 1</span>: <span class="gi">value 1</span>, <span class="gi">key 2</span>: <span class="gi">value 2</span>, <span class="gi">key 3</span>: <span class="gi">value 3</span>]
</li></ol></div></div></div>
<p>The example below creates a dictionary to store the names of international airports. In this dictionary, the keys are three-letter International Air Transport Association codes, and the values are airport names:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">airports</span>: [<span class="nc">String</span>: <span class="nc">String</span>] = [<span class="s">"YYZ"</span>: <span class="s">"Toronto Pearson"</span>, <span class="s">"DUB"</span>: <span class="s">"Dublin"</span>]
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">airports</span></code> dictionary is declared as having a type of <code class="docutils literal notranslate"><span class="pre">[String:</span> <span class="pre">String]</span></code>, which means “a <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> whose keys are of type <code class="docutils literal notranslate"><span class="pre">String</span></code>, and whose values are also of type <code class="docutils literal notranslate"><span class="pre">String</span></code>”.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">airports</span></code> dictionary is declared as a variable (with the <code class="docutils literal notranslate"><span class="pre">var</span></code> introducer), and not a constant (with the <code class="docutils literal notranslate"><span class="pre">let</span></code> introducer), because more airports are added to the dictionary in the examples below.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">airports</span></code> dictionary is initialized with a dictionary literal containing two key-value pairs. The first pair has a key of <code class="docutils literal notranslate"><span class="pre">"YYZ"</span></code> and a value of <code class="docutils literal notranslate"><span class="pre">"Toronto</span> <span class="pre">Pearson"</span></code>. The second pair has a key of <code class="docutils literal notranslate"><span class="pre">"DUB"</span></code> and a value of <code class="docutils literal notranslate"><span class="pre">"Dublin"</span></code>.</p>
<p>This dictionary literal contains two <code class="docutils literal notranslate"><span class="pre">String:</span> <span class="pre">String</span></code> pairs. This key-value type matches the type of the <code class="docutils literal notranslate"><span class="pre">airports</span></code> variable declaration (a dictionary with only <code class="docutils literal notranslate"><span class="pre">String</span></code> keys, and only <code class="docutils literal notranslate"><span class="pre">String</span></code> values), and so the assignment of the dictionary literal is permitted as a way to initialize the <code class="docutils literal notranslate"><span class="pre">airports</span></code> dictionary with two initial items.</p>
<p>As with arrays, you don’t have to write the type of the dictionary if you’re initializing it with a dictionary literal whose keys and values have consistent types. The initialization of <code class="docutils literal notranslate"><span class="pre">airports</span></code> could have been written in a shorter form instead:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">airports</span> = [<span class="s">"YYZ"</span>: <span class="s">"Toronto Pearson"</span>, <span class="s">"DUB"</span>: <span class="s">"Dublin"</span>]
</li></ol></div></div></div>
<p>Because all keys in the literal are of the same type as each other, and likewise all values are of the same type as each other, Swift can infer that <code class="docutils literal notranslate"><span class="pre">[String:</span> <span class="pre">String]</span></code> is the correct type to use for the <code class="docutils literal notranslate"><span class="pre">airports</span></code> dictionary.</p>
</div>
<div class="section" id="ID116">
<h3>Accessing and Modifying a Dictionary<a class="headerlink" href="CollectionTypes.html#ID116" title="Permalink to this headline">¶</a></h3>
<p>You access and modify a dictionary through its methods and properties, or by using subscript syntax.</p>
<p>As with an array, you find out the number of items in a <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> by checking its read-only <code class="docutils literal notranslate"><span class="pre">count</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"The airports dictionary contains </span>\<span class="p">(</span><span class="nv">airports</span>.<span class="nv">count</span><span class="p">)</span><span class="s"> items."</span>)
</li><li><span class="c">// Prints "The airports dictionary contains 2 items."</span>
</li></ol></div></div></div>
<p>Use the Boolean <code class="docutils literal notranslate"><span class="pre">isEmpty</span></code> property as a shortcut for checking whether the <code class="docutils literal notranslate"><span class="pre">count</span></code> property is equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">airports</span>.<span class="nv">isEmpty</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The airports dictionary is empty."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The airports dictionary is not empty."</span>)
</li><li>}
</li><li><span class="c">// Prints "The airports dictionary is not empty."</span>
</li></ol></div></div></div>
<p>You can add a new item to a dictionary with subscript syntax. Use a new key of the appropriate type as the subscript index, and assign a new value of the appropriate type:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">airports</span>[<span class="s">"LHR"</span>] = <span class="s">"London"</span>
</li><li><span class="c">// the airports dictionary now contains 3 items</span>
</li></ol></div></div></div>
<p>You can also use subscript syntax to change the value associated with a particular key:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">airports</span>[<span class="s">"LHR"</span>] = <span class="s">"London Heathrow"</span>
</li><li><span class="c">// the value for "LHR" has been changed to "London Heathrow"</span>
</li></ol></div></div></div>
<p>As an alternative to subscripting, use a dictionary’s <code class="docutils literal notranslate"><span class="pre">updateValue(_:forKey:)</span></code> method to set or update the value for a particular key. Like the subscript examples above, the <code class="docutils literal notranslate"><span class="pre">updateValue(_:forKey:)</span></code> method sets a value for a key if none exists, or updates the value if that key already exists. Unlike a subscript, however, the <code class="docutils literal notranslate"><span class="pre">updateValue(_:forKey:)</span></code> method returns the <em>old</em> value after performing an update. This enables you to check whether or not an update took place.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">updateValue(_:forKey:)</span></code> method returns an optional value of the dictionary’s value type. For a dictionary that stores <code class="docutils literal notranslate"><span class="pre">String</span></code> values, for example, the method returns a value of type <code class="docutils literal notranslate"><span class="pre">String?</span></code>, or “optional <code class="docutils literal notranslate"><span class="pre">String</span></code>”. This optional value contains the old value for that key if one existed before the update, or <code class="docutils literal notranslate"><span class="pre">nil</span></code> if no value existed:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">oldValue</span> = <span class="nv">airports</span>.<span class="nv">updateValue</span>(<span class="s">"Dublin Airport"</span>, <span class="nv">forKey</span>: <span class="s">"DUB"</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"The old value for DUB was </span>\<span class="p">(</span><span class="nv">oldValue</span><span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li><span class="c">// Prints "The old value for DUB was Dublin."</span>
</li></ol></div></div></div>
<p>You can also use subscript syntax to retrieve a value from the dictionary for a particular key. Because it is possible to request a key for which no value exists, a dictionary’s subscript returns an optional value of the dictionary’s value type. If the dictionary contains a value for the requested key, the subscript returns an optional value containing the existing value for that key. Otherwise, the subscript returns <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">airportName</span> = <span class="nv">airports</span>[<span class="s">"DUB"</span>] {
</li><li> <span class="nv">print</span>(<span class="s">"The name of the airport is </span>\<span class="p">(</span><span class="nv">airportName</span><span class="p">)</span><span class="s">."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"That airport is not in the airports dictionary."</span>)
</li><li>}
</li><li><span class="c">// Prints "The name of the airport is Dublin Airport."</span>
</li></ol></div></div></div>
<p>You can use subscript syntax to remove a key-value pair from a dictionary by assigning a value of <code class="docutils literal notranslate"><span class="pre">nil</span></code> for that key:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">airports</span>[<span class="s">"APL"</span>] = <span class="s">"Apple International"</span>
</li><li><span class="c">// "Apple International" is not the real airport for APL, so delete it</span>
</li><li><span class="nv">airports</span>[<span class="s">"APL"</span>] = <span class="k">nil</span>
</li><li><span class="c">// APL has now been removed from the dictionary</span>
</li></ol></div></div></div>
<p>Alternatively, remove a key-value pair from a dictionary with the <code class="docutils literal notranslate"><span class="pre">removeValue(forKey:)</span></code> method. This method removes the key-value pair if it exists and returns the removed value, or returns <code class="docutils literal notranslate"><span class="pre">nil</span></code> if no value existed:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">removedValue</span> = <span class="nv">airports</span>.<span class="nv">removeValue</span>(<span class="nv">forKey</span>: <span class="s">"DUB"</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"The removed airport's name is </span>\<span class="p">(</span><span class="nv">removedValue</span><span class="p">)</span><span class="s">."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The airports dictionary does not contain a value for DUB."</span>)
</li><li>}
</li><li><span class="c">// Prints "The removed airport's name is Dublin Airport."</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID117">
<h3>Iterating Over a Dictionary<a class="headerlink" href="CollectionTypes.html#ID117" title="Permalink to this headline">¶</a></h3>
<p>You can iterate over the key-value pairs in a dictionary with a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop. Each item in the dictionary is returned as a <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> tuple, and you can decompose the tuple’s members into temporary constants or variables as part of the iteration:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> (<span class="nv">airportCode</span>, <span class="nv">airportName</span>) <span class="k">in</span> <span class="nv">airports</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">airportCode</span><span class="p">)</span><span class="s">: </span>\<span class="p">(</span><span class="nv">airportName</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// YYZ: Toronto Pearson</span>
</li><li><span class="c">// LHR: London Heathrow</span>
</li></ol></div></div></div>
<p>For more about the <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop, see <a class="reference internal" href="ControlFlow.html#ID121"><span class="std std-ref">For-In Loops</span></a>.</p>
<p>You can also retrieve an iterable collection of a dictionary’s keys or values by accessing its <code class="docutils literal notranslate"><span class="pre">keys</span></code> and <code class="docutils literal notranslate"><span class="pre">values</span></code> properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">airportCode</span> <span class="k">in</span> <span class="nv">airports</span>.<span class="nv">keys</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Airport code: </span>\<span class="p">(</span><span class="nv">airportCode</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Airport code: YYZ</span>
</li><li><span class="c">// Airport code: LHR</span>
</li><li>
</li><li><span class="k">for</span> <span class="nv">airportName</span> <span class="k">in</span> <span class="nv">airports</span>.<span class="nv">values</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Airport name: </span>\<span class="p">(</span><span class="nv">airportName</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Airport name: Toronto Pearson</span>
</li><li><span class="c">// Airport name: London Heathrow</span>
</li></ol></div></div></div>
<p>If you need to use a dictionary’s keys or values with an API that takes an <code class="docutils literal notranslate"><span class="pre">Array</span></code> instance, initialize a new array with the <code class="docutils literal notranslate"><span class="pre">keys</span></code> or <code class="docutils literal notranslate"><span class="pre">values</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">airportCodes</span> = [<span class="nv">String</span>](<span class="nv">airports</span>.<span class="nv">keys</span>)
</li><li><span class="c">// airportCodes is ["YYZ", "LHR"]</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">airportNames</span> = [<span class="nv">String</span>](<span class="nv">airports</span>.<span class="nv">values</span>)
</li><li><span class="c">// airportNames is ["Toronto Pearson", "London Heathrow"]</span>
</li></ol></div></div></div>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> type does not have a defined ordering. To iterate over the keys or values of a dictionary in a specific order, use the <code class="docutils literal notranslate"><span class="pre">sorted()</span></code> method on its <code class="docutils literal notranslate"><span class="pre">keys</span></code> or <code class="docutils literal notranslate"><span class="pre">values</span></code> property.</p>
</div>
</div>
</div><div class="section" id="ID462">
<h1>Control Flow<a class="headerlink" href="ControlFlow.html#ID462" title="Permalink to this headline">¶</a></h1>
<p>Swift provides a variety of control flow statements. These include <code class="docutils literal notranslate"><span class="pre">while</span></code> loops to perform a task multiple times; <code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">guard</span></code>, and <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements to execute different branches of code based on certain conditions; and statements such as <code class="docutils literal notranslate"><span class="pre">break</span></code> and <code class="docutils literal notranslate"><span class="pre">continue</span></code> to transfer the flow of execution to another point in your code.</p>
<p>Swift also provides a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop that makes it easy to iterate over arrays, dictionaries, ranges, strings, and other sequences.</p>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement is considerably more powerful than its counterpart in many C-like languages. Cases can match many different patterns, including interval matches, tuples, and casts to a specific type. Matched values in a <code class="docutils literal notranslate"><span class="pre">switch</span></code> case can be bound to temporary constants or variables for use within the case’s body, and complex matching conditions can be expressed with a <code class="docutils literal notranslate"><span class="pre">where</span></code> clause for each case.</p>
<div class="section" id="ID121">
<h2>For-In Loops<a class="headerlink" href="ControlFlow.html#ID121" title="Permalink to this headline">¶</a></h2>
<p>You use the <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string.</p>
<p>This example uses a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop to iterate over the items in an array:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">names</span> = [<span class="s">"Anna"</span>, <span class="s">"Alex"</span>, <span class="s">"Brian"</span>, <span class="s">"Jack"</span>]
</li><li><span class="k">for</span> <span class="nv">name</span> <span class="k">in</span> <span class="nv">names</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Hello, </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">!"</span>)
</li><li>}
</li><li><span class="c">// Hello, Anna!</span>
</li><li><span class="c">// Hello, Alex!</span>
</li><li><span class="c">// Hello, Brian!</span>
</li><li><span class="c">// Hello, Jack!</span>
</li></ol></div></div></div>
<p>You can also iterate over a dictionary to access its key-value pairs. Each item in the dictionary is returned as a <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> tuple when the dictionary is iterated, and you can decompose the <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> tuple’s members as explicitly named constants for use within the body of the <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop. In the code example below, the dictionary’s keys are decomposed into a constant called <code class="docutils literal notranslate"><span class="pre">animalName</span></code>, and the dictionary’s values are decomposed into a constant called <code class="docutils literal notranslate"><span class="pre">legCount</span></code>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">numberOfLegs</span> = [<span class="s">"spider"</span>: <span class="m">8</span>, <span class="s">"ant"</span>: <span class="m">6</span>, <span class="s">"cat"</span>: <span class="m">4</span>]
</li><li><span class="k">for</span> (<span class="nv">animalName</span>, <span class="nv">legCount</span>) <span class="k">in</span> <span class="nv">numberOfLegs</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">animalName</span><span class="p">)</span><span class="s">s have </span>\<span class="p">(</span><span class="nv">legCount</span><span class="p">)</span><span class="s"> legs"</span>)
</li><li>}
</li><li><span class="c">// ants have 6 legs</span>
</li><li><span class="c">// cats have 4 legs</span>
</li><li><span class="c">// spiders have 8 legs</span>
</li></ol></div></div></div>
<p>The contents of a <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> are inherently unordered, and iterating over them does not guarantee the order in which they will be retrieved. In particular, the order you insert items into a <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> doesn’t define the order they are iterated. For more about arrays and dictionaries, see <a class="reference internal" href="CollectionTypes.html"><span class="doc">Collection Types</span></a>.</p>
<p>You can also use <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loops with numeric ranges. This example prints the first few entries in a five-times table:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">5</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">index</span><span class="p">)</span><span class="s"> times 5 is </span>\<span class="p">(</span><span class="nv">index</span> * <span class="m">5</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// 1 times 5 is 5</span>
</li><li><span class="c">// 2 times 5 is 10</span>
</li><li><span class="c">// 3 times 5 is 15</span>
</li><li><span class="c">// 4 times 5 is 20</span>
</li><li><span class="c">// 5 times 5 is 25</span>
</li></ol></div></div></div>
<p>The sequence being iterated over is a range of numbers from <code class="docutils literal notranslate"><span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">5</span></code>, inclusive, as indicated by the use of the closed range operator (<code class="docutils literal notranslate"><span class="pre">...</span></code>). The value of <code class="docutils literal notranslate"><span class="pre">index</span></code> is set to the first number in the range (<code class="docutils literal notranslate"><span class="pre">1</span></code>), and the statements inside the loop are executed. In this case, the loop contains only one statement, which prints an entry from the five-times table for the current value of <code class="docutils literal notranslate"><span class="pre">index</span></code>. After the statement is executed, the value of <code class="docutils literal notranslate"><span class="pre">index</span></code> is updated to contain the second value in the range (<code class="docutils literal notranslate"><span class="pre">2</span></code>), and the <code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code> function is called again. This process continues until the end of the range is reached.</p>
<p>In the example above, <code class="docutils literal notranslate"><span class="pre">index</span></code> is a constant whose value is automatically set at the start of each iteration of the loop. As such, <code class="docutils literal notranslate"><span class="pre">index</span></code> does not have to be declared before it is used. It is implicitly declared simply by its inclusion in the loop declaration, without the need for a <code class="docutils literal notranslate"><span class="pre">let</span></code> declaration keyword.</p>
<p>If you don’t need each value from a sequence, you can ignore the values by using an underscore in place of a variable name.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">base</span> = <span class="m">3</span>
</li><li><span class="k">let</span> <span class="nv">power</span> = <span class="m">10</span>
</li><li><span class="k">var</span> <span class="nv">answer</span> = <span class="m">1</span>
</li><li><span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">1</span>...<span class="nv">power</span> {
</li><li> <span class="nv">answer</span> *= <span class="nv">base</span>
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">base</span><span class="p">)</span><span class="s"> to the power of </span>\<span class="p">(</span><span class="nv">power</span><span class="p">)</span><span class="s"> is </span>\<span class="p">(</span><span class="nv">answer</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "3 to the power of 10 is 59049"</span>
</li></ol></div></div></div>
<p>The example above calculates the value of one number to the power of another (in this case, <code class="docutils literal notranslate"><span class="pre">3</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">10</span></code>). It multiplies a starting value of <code class="docutils literal notranslate"><span class="pre">1</span></code> (that is, <code class="docutils literal notranslate"><span class="pre">3</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">0</span></code>) by <code class="docutils literal notranslate"><span class="pre">3</span></code>, ten times, using a closed range that starts with <code class="docutils literal notranslate"><span class="pre">1</span></code> and ends with <code class="docutils literal notranslate"><span class="pre">10</span></code>. For this calculation, the individual counter values each time through the loop are unnecessary—the code simply executes the loop the correct number of times. The underscore character (<code class="docutils literal notranslate"><span class="pre">_</span></code>) used in place of a loop variable causes the individual values to be ignored and does not provide access to the current value during each iteration of the loop.</p>
<p>In some situations, you might not want to use closed ranges, which include both endpoints. Consider drawing the tick marks for every minute on a watch face. You want to draw <code class="docutils literal notranslate"><span class="pre">60</span></code> tick marks, starting with the <code class="docutils literal notranslate"><span class="pre">0</span></code> minute. Use the half-open range operator (<code class="docutils literal notranslate"><span class="pre">..&lt;</span></code>) to include the lower bound but not the upper bound. For more about ranges, see <a class="reference internal" href="BasicOperators.html#ID73"><span class="std std-ref">Range Operators</span></a>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">minutes</span> = <span class="m">60</span>
</li><li><span class="k">for</span> <span class="nv">tickMark</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="nv">minutes</span> {
</li><li> <span class="c">// render the tick mark each minute (60 times)</span>
</li><li>}
</li></ol></div></div></div>
<p>Some users might want fewer tick marks in their UI. They could prefer one mark every <code class="docutils literal notranslate"><span class="pre">5</span></code> minutes instead. Use the <code class="docutils literal notranslate"><span class="pre">stride(from:to:by:)</span></code> function to skip the unwanted marks.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">minuteInterval</span> = <span class="m">5</span>
</li><li><span class="k">for</span> <span class="nv">tickMark</span> <span class="k">in</span> <span class="nv">stride</span>(<span class="nv">from</span>: <span class="m">0</span>, <span class="nv">to</span>: <span class="nv">minutes</span>, <span class="nv">by</span>: <span class="nv">minuteInterval</span>) {
</li><li> <span class="c">// render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)</span>
</li><li>}
</li></ol></div></div></div>
<p>Closed ranges are also available, by using <code class="docutils literal notranslate"><span class="pre">stride(from:through:by:)</span></code> instead:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">hours</span> = <span class="m">12</span>
</li><li><span class="k">let</span> <span class="nv">hourInterval</span> = <span class="m">3</span>
</li><li><span class="k">for</span> <span class="nv">tickMark</span> <span class="k">in</span> <span class="nv">stride</span>(<span class="nv">from</span>: <span class="m">3</span>, <span class="nv">through</span>: <span class="nv">hours</span>, <span class="nv">by</span>: <span class="nv">hourInterval</span>) {
</li><li> <span class="c">// render the tick mark every 3 hours (3, 6, 9, 12)</span>
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID124">
<h2>While Loops<a class="headerlink" href="ControlFlow.html#ID124" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">while</span></code> loop performs a set of statements until a condition becomes <code class="docutils literal notranslate"><span class="pre">false</span></code>. These kinds of loops are best used when the number of iterations is not known before the first iteration begins. Swift provides two kinds of <code class="docutils literal notranslate"><span class="pre">while</span></code> loops:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">while</span></code> evaluates its condition at the start of each pass through the loop.</li>
<li><code class="docutils literal notranslate"><span class="pre">repeat</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code> evaluates its condition at the end of each pass through the loop.</li>
</ul>
<div class="section" id="ID125">
<h3>While<a class="headerlink" href="ControlFlow.html#ID125" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">while</span></code> loop starts by evaluating a single condition. If the condition is <code class="docutils literal notranslate"><span class="pre">true</span></code>, a set of statements is repeated until the condition becomes <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>Here’s the general form of a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">while</span> <span class="gi">condition</span> {
</li><li> <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>This example plays a simple game of <em>Snakes and Ladders</em> (also known as <em>Chutes and Ladders</em>):</p>
<img alt="../_images/snakesAndLadders_2x.png" class="align-center" src="../_images/snakesAndLadders_2x.png" style="width: 623px;"/>
<p>The rules of the game are as follows:</p>
<ul class="simple">
<li>The board has 25 squares, and the aim is to land on or beyond square 25.</li>
<li>The player’s starting square is “square zero”, which is just off the bottom-left corner of the board.</li>
<li>Each turn, you roll a six-sided dice and move by that number of squares, following the horizontal path indicated by the dotted arrow above.</li>
<li>If your turn ends at the bottom of a ladder, you move up that ladder.</li>
<li>If your turn ends at the head of a snake, you move down that snake.</li>
</ul>
<p>The game board is represented by an array of <code class="docutils literal notranslate"><span class="pre">Int</span></code> values. Its size is based on a constant called <code class="docutils literal notranslate"><span class="pre">finalSquare</span></code>, which is used to initialize the array and also to check for a win condition later in the example. Because the players start off the board, on “square zero”, the board is initialized with 26 zero <code class="docutils literal notranslate"><span class="pre">Int</span></code> values, not 25.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">finalSquare</span> = <span class="m">25</span>
</li><li><span class="k">var</span> <span class="nv">board</span> = [<span class="nv">Int</span>](<span class="nv">repeating</span>: <span class="m">0</span>, <span class="nv">count</span>: <span class="nv">finalSquare</span> + <span class="m">1</span>)
</li></ol></div></div></div>
<p>Some squares are then set to have more specific values for the snakes and ladders. Squares with a ladder base have a positive number to move you up the board, whereas squares with a snake head have a negative number to move you back down the board.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">board</span>[<span class="m">03</span>] = +<span class="m">08</span>; <span class="nv">board</span>[<span class="m">06</span>] = +<span class="m">11</span>; <span class="nv">board</span>[<span class="m">09</span>] = +<span class="m">09</span>; <span class="nv">board</span>[<span class="m">10</span>] = +<span class="m">02</span>
</li><li><span class="nv">board</span>[<span class="m">14</span>] = <span class="m">-10</span>; <span class="nv">board</span>[<span class="m">19</span>] = <span class="m">-11</span>; <span class="nv">board</span>[<span class="m">22</span>] = <span class="m">-02</span>; <span class="nv">board</span>[<span class="m">24</span>] = <span class="m">-08</span>
</li></ol></div></div></div>
<p>Square 3 contains the bottom of a ladder that moves you up to square 11. To represent this, <code class="docutils literal notranslate"><span class="pre">board[03]</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">+08</span></code>, which is equivalent to an integer value of <code class="docutils literal notranslate"><span class="pre">8</span></code> (the difference between <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">11</span></code>). To align the values and statements, the unary plus operator (<code class="docutils literal notranslate"><span class="pre">+i</span></code>) is explicitly used with the unary minus operator (<code class="docutils literal notranslate"><span class="pre">-i</span></code>) and numbers lower than <code class="docutils literal notranslate"><span class="pre">10</span></code> are padded with zeros. (Neither stylistic technique is strictly necessary, but they lead to neater code.)</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">square</span> = <span class="m">0</span>
</li><li><span class="k">var</span> <span class="nv">diceRoll</span> = <span class="m">0</span>
</li><li><span class="k">while</span> <span class="nv">square</span> &lt; <span class="nv">finalSquare</span> {
</li><li> <span class="c">// roll the dice</span>
</li><li> <span class="nv">diceRoll</span> += <span class="m">1</span>
</li><li> <span class="k">if</span> <span class="nv">diceRoll</span> == <span class="m">7</span> { <span class="nv">diceRoll</span> = <span class="m">1</span> }
</li><li> <span class="c">// move by the rolled amount</span>
</li><li> <span class="nv">square</span> += <span class="nv">diceRoll</span>
</li><li> <span class="k">if</span> <span class="nv">square</span> &lt; <span class="nv">board</span>.<span class="nv">count</span> {
</li><li> <span class="c">// if we're still on the board, move up or down for a snake or a ladder</span>
</li><li> <span class="nv">square</span> += <span class="nv">board</span>[<span class="nv">square</span>]
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">"Game over!"</span>)
</li></ol></div></div></div>
<p>The example above uses a very simple approach to dice rolling. Instead of generating a random number, it starts with a <code class="docutils literal notranslate"><span class="pre">diceRoll</span></code> value of <code class="docutils literal notranslate"><span class="pre">0</span></code>. Each time through the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, <code class="docutils literal notranslate"><span class="pre">diceRoll</span></code> is incremented by one and is then checked to see whether it has become too large. Whenever this return value equals <code class="docutils literal notranslate"><span class="pre">7</span></code>, the dice roll has become too large and is reset to a value of <code class="docutils literal notranslate"><span class="pre">1</span></code>. The result is a sequence of <code class="docutils literal notranslate"><span class="pre">diceRoll</span></code> values that is always <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">4</span></code>, <code class="docutils literal notranslate"><span class="pre">5</span></code>, <code class="docutils literal notranslate"><span class="pre">6</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code> and so on.</p>
<p>After rolling the dice, the player moves forward by <code class="docutils literal notranslate"><span class="pre">diceRoll</span></code> squares. It’s possible that the dice roll may have moved the player beyond square 25, in which case the game is over. To cope with this scenario, the code checks that <code class="docutils literal notranslate"><span class="pre">square</span></code> is less than the <code class="docutils literal notranslate"><span class="pre">board</span></code> array’s <code class="docutils literal notranslate"><span class="pre">count</span></code> property. If <code class="docutils literal notranslate"><span class="pre">square</span></code> is valid, the value stored in <code class="docutils literal notranslate"><span class="pre">board[square]</span></code> is added to the current <code class="docutils literal notranslate"><span class="pre">square</span></code> value to move the player up or down any ladders or snakes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this check is not performed, <code class="docutils literal notranslate"><span class="pre">board[square]</span></code> might try to access a value outside the bounds of the <code class="docutils literal notranslate"><span class="pre">board</span></code> array, which would trigger a runtime error.</p>
</div>
<p>The current <code class="docutils literal notranslate"><span class="pre">while</span></code> loop execution then ends, and the loop’s condition is checked to see if the loop should be executed again. If the player has moved on or beyond square number <code class="docutils literal notranslate"><span class="pre">25</span></code>, the loop’s condition evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code> and the game ends.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">while</span></code> loop is appropriate in this case, because the length of the game is not clear at the start of the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop. Instead, the loop is executed until a particular condition is satisfied.</p>
</div>
<div class="section" id="ID126">
<h3>Repeat-While<a class="headerlink" href="ControlFlow.html#ID126" title="Permalink to this headline">¶</a></h3>
<p>The other variation of the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, known as the <code class="docutils literal notranslate"><span class="pre">repeat</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code> loop, performs a single pass through the loop block first, <em>before</em> considering the loop’s condition. It then continues to repeat the loop until the condition is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">repeat</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code> loop in Swift is analogous to a <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code> loop in other languages.</p>
</div>
<p>Here’s the general form of a <code class="docutils literal notranslate"><span class="pre">repeat</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code> loop:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">repeat</span> {
</li><li> <span class="gi">statements</span>
</li><li>} <span class="k">while</span> <span class="gi">condition</span>
</li></ol></div></div></div>
<p>Here’s the <em>Snakes and Ladders</em> example again, written as a <code class="docutils literal notranslate"><span class="pre">repeat</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code> loop rather than a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop. The values of <code class="docutils literal notranslate"><span class="pre">finalSquare</span></code>, <code class="docutils literal notranslate"><span class="pre">board</span></code>, <code class="docutils literal notranslate"><span class="pre">square</span></code>, and <code class="docutils literal notranslate"><span class="pre">diceRoll</span></code> are initialized in exactly the same way as with a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">finalSquare</span> = <span class="m">25</span>
</li><li><span class="k">var</span> <span class="nv">board</span> = [<span class="nv">Int</span>](<span class="nv">repeating</span>: <span class="m">0</span>, <span class="nv">count</span>: <span class="nv">finalSquare</span> + <span class="m">1</span>)
</li><li><span class="nv">board</span>[<span class="m">03</span>] = +<span class="m">08</span>; <span class="nv">board</span>[<span class="m">06</span>] = +<span class="m">11</span>; <span class="nv">board</span>[<span class="m">09</span>] = +<span class="m">09</span>; <span class="nv">board</span>[<span class="m">10</span>] = +<span class="m">02</span>
</li><li><span class="nv">board</span>[<span class="m">14</span>] = <span class="m">-10</span>; <span class="nv">board</span>[<span class="m">19</span>] = <span class="m">-11</span>; <span class="nv">board</span>[<span class="m">22</span>] = <span class="m">-02</span>; <span class="nv">board</span>[<span class="m">24</span>] = <span class="m">-08</span>
</li><li><span class="k">var</span> <span class="nv">square</span> = <span class="m">0</span>
</li><li><span class="k">var</span> <span class="nv">diceRoll</span> = <span class="m">0</span>
</li></ol></div></div></div>
<p>In this version of the game, the <em>first</em> action in the loop is to check for a ladder or a snake. No ladder on the board takes the player straight to square 25, and so it isn’t possible to win the game by moving up a ladder. Therefore, it’s safe to check for a snake or a ladder as the first action in the loop.</p>
<p>At the start of the game, the player is on “square zero”. <code class="docutils literal notranslate"><span class="pre">board[0]</span></code> always equals <code class="docutils literal notranslate"><span class="pre">0</span></code> and has no effect.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">repeat</span> {
</li><li> <span class="c">// move up or down for a snake or ladder</span>
</li><li> <span class="nv">square</span> += <span class="nv">board</span>[<span class="nv">square</span>]
</li><li> <span class="c">// roll the dice</span>
</li><li> <span class="nv">diceRoll</span> += <span class="m">1</span>
</li><li> <span class="k">if</span> <span class="nv">diceRoll</span> == <span class="m">7</span> { <span class="nv">diceRoll</span> = <span class="m">1</span> }
</li><li> <span class="c">// move by the rolled amount</span>
</li><li> <span class="nv">square</span> += <span class="nv">diceRoll</span>
</li><li>} <span class="k">while</span> <span class="nv">square</span> &lt; <span class="nv">finalSquare</span>
</li><li><span class="nv">print</span>(<span class="s">"Game over!"</span>)
</li></ol></div></div></div>
<p>After the code checks for snakes and ladders, the dice is rolled and the player is moved forward by <code class="docutils literal notranslate"><span class="pre">diceRoll</span></code> squares. The current loop execution then ends.</p>
<p>The loop’s condition (<code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">square</span> <span class="pre">&lt;</span> <span class="pre">finalSquare</span></code>) is the same as before, but this time it’s not evaluated until the <em>end</em> of the first run through the loop. The structure of the <code class="docutils literal notranslate"><span class="pre">repeat</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code> loop is better suited to this game than the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop in the previous example. In the <code class="docutils literal notranslate"><span class="pre">repeat</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code> loop above, <code class="docutils literal notranslate"><span class="pre">square</span> <span class="pre">+=</span> <span class="pre">board[square]</span></code> is always executed <em>immediately after</em> the loop’s <code class="docutils literal notranslate"><span class="pre">while</span></code> condition confirms that <code class="docutils literal notranslate"><span class="pre">square</span></code> is still on the board. This behavior removes the need for the array bounds check seen in the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop version of the game described earlier.</p>
</div>
</div>
<div class="section" id="ID127">
<h2>Conditional Statements<a class="headerlink" href="ControlFlow.html#ID127" title="Permalink to this headline">¶</a></h2>
<p>It is often useful to execute different pieces of code based on certain conditions. You might want to run an extra piece of code when an error occurs, or to display a message when a value becomes too high or too low. To do this, you make parts of your code <em>conditional</em>.</p>
<p>Swift provides two ways to add conditional branches to your code: the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement and the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement. Typically, you use the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement to evaluate simple conditions with only a few possible outcomes. The <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute.</p>
<div class="section" id="ID128">
<h3>If<a class="headerlink" href="ControlFlow.html#ID128" title="Permalink to this headline">¶</a></h3>
<p>In its simplest form, the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement has a single <code class="docutils literal notranslate"><span class="pre">if</span></code> condition. It executes a set of statements only if that condition is <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">temperatureInFahrenheit</span> = <span class="m">30</span>
</li><li><span class="k">if</span> <span class="nv">temperatureInFahrenheit</span> &lt;= <span class="m">32</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It's very cold. Consider wearing a scarf."</span>)
</li><li>}
</li><li><span class="c">// Prints "It's very cold. Consider wearing a scarf."</span>
</li></ol></div></div></div>
<p>The example above checks whether the temperature is less than or equal to 32 degrees Fahrenheit (the freezing point of water). If it is, a message is printed. Otherwise, no message is printed, and code execution continues after the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement’s closing brace.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">if</span></code> statement can provide an alternative set of statements, known as an <em>else clause</em>, for situations when the <code class="docutils literal notranslate"><span class="pre">if</span></code> condition is <code class="docutils literal notranslate"><span class="pre">false</span></code>. These statements are indicated by the <code class="docutils literal notranslate"><span class="pre">else</span></code> keyword.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">temperatureInFahrenheit</span> = <span class="m">40</span>
</li><li><span class="k">if</span> <span class="nv">temperatureInFahrenheit</span> &lt;= <span class="m">32</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It's very cold. Consider wearing a scarf."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It's not that cold. Wear a t-shirt."</span>)
</li><li>}
</li><li><span class="c">// Prints "It's not that cold. Wear a t-shirt."</span>
</li></ol></div></div></div>
<p>One of these two branches is always executed. Because the temperature has increased to <code class="docutils literal notranslate"><span class="pre">40</span></code> degrees Fahrenheit, it is no longer cold enough to advise wearing a scarf and so the <code class="docutils literal notranslate"><span class="pre">else</span></code> branch is triggered instead.</p>
<p>You can chain multiple <code class="docutils literal notranslate"><span class="pre">if</span></code> statements together to consider additional clauses.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">temperatureInFahrenheit</span> = <span class="m">90</span>
</li><li><span class="k">if</span> <span class="nv">temperatureInFahrenheit</span> &lt;= <span class="m">32</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It's very cold. Consider wearing a scarf."</span>)
</li><li>} <span class="k">else</span> <span class="k">if</span> <span class="nv">temperatureInFahrenheit</span> &gt;= <span class="m">86</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It's really warm. Don't forget to wear sunscreen."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It's not that cold. Wear a t-shirt."</span>)
</li><li>}
</li><li><span class="c">// Prints "It's really warm. Don't forget to wear sunscreen."</span>
</li></ol></div></div></div>
<p>Here, an additional <code class="docutils literal notranslate"><span class="pre">if</span></code> statement was added to respond to particularly warm temperatures. The final <code class="docutils literal notranslate"><span class="pre">else</span></code> clause remains, and it prints a response for any temperatures that are neither too warm nor too cold.</p>
<p>The final <code class="docutils literal notranslate"><span class="pre">else</span></code> clause is optional, however, and can be excluded if the set of conditions does not need to be complete.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">temperatureInFahrenheit</span> = <span class="m">72</span>
</li><li><span class="k">if</span> <span class="nv">temperatureInFahrenheit</span> &lt;= <span class="m">32</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It's very cold. Consider wearing a scarf."</span>)
</li><li>} <span class="k">else</span> <span class="k">if</span> <span class="nv">temperatureInFahrenheit</span> &gt;= <span class="m">86</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It's really warm. Don't forget to wear sunscreen."</span>)
</li><li>}
</li></ol></div></div></div>
<p>Because the temperature is neither too cold nor too warm to trigger the <code class="docutils literal notranslate"><span class="pre">if</span></code> or <code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code> conditions, no message is printed.</p>
</div>
<div class="section" id="ID129">
<h3>Switch<a class="headerlink" href="ControlFlow.html#ID129" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement considers a value and compares it against several possible matching patterns. It then executes an appropriate block of code, based on the first pattern that matches successfully. A <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement provides an alternative to the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement for responding to multiple potential states.</p>
<p>In its simplest form, a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement compares a value against one or more values of the same type.</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">switch</span> <span class="gi">some value to consider</span> {
</li><li><span class="k">case</span> <span class="gi">value 1</span>:
</li><li> <span class="gi">respond to value 1</span>
</li><li><span class="k">case</span> <span class="gi">value 2</span>,
</li><li> <span class="gi">value 3</span>:
</li><li> <span class="gi">respond to value 2 or 3</span>
</li><li><span class="k">default</span>:
</li><li> <span class="gi">otherwise, do something else</span>
</li><li>}
</li></ol></div></div></div>
<p>Every <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement consists of multiple possible <em>cases</em>, each of which begins with the <code class="docutils literal notranslate"><span class="pre">case</span></code> keyword. In addition to comparing against specific values, Swift provides several ways for each case to specify more complex matching patterns. These options are described later in this chapter.</p>
<p>Like the body of an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, each <code class="docutils literal notranslate"><span class="pre">case</span></code> is a separate branch of code execution. The <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement determines which branch should be selected. This procedure is known as <em>switching</em> on the value that is being considered.</p>
<p>Every <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement must be <em>exhaustive</em>. That is, every possible value of the type being considered must be matched by one of the <code class="docutils literal notranslate"><span class="pre">switch</span></code> cases. If it’s not appropriate to provide a case for every possible value, you can define a default case to cover any values that are not addressed explicitly. This default case is indicated by the <code class="docutils literal notranslate"><span class="pre">default</span></code> keyword, and must always appear last.</p>
<p>This example uses a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement to consider a single lowercase character called <code class="docutils literal notranslate"><span class="pre">someCharacter</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someCharacter</span>: <span class="nc">Character</span> = <span class="s">"z"</span>
</li><li><span class="k">switch</span> <span class="nv">someCharacter</span> {
</li><li><span class="k">case</span> <span class="s">"a"</span>:
</li><li> <span class="nv">print</span>(<span class="s">"The first letter of the alphabet"</span>)
</li><li><span class="k">case</span> <span class="s">"z"</span>:
</li><li> <span class="nv">print</span>(<span class="s">"The last letter of the alphabet"</span>)
</li><li><span class="k">default</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Some other character"</span>)
</li><li>}
</li><li><span class="c">// Prints "The last letter of the alphabet"</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement’s first case matches the first letter of the English alphabet, <code class="docutils literal notranslate"><span class="pre">a</span></code>, and its second case matches the last letter, <code class="docutils literal notranslate"><span class="pre">z</span></code>. Because the <code class="docutils literal notranslate"><span class="pre">switch</span></code> must have a case for every possible character, not just every alphabetic character, this <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement uses a <code class="docutils literal notranslate"><span class="pre">default</span></code> case to match all characters other than <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code>. This provision ensures that the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement is exhaustive.</p>
<div class="section" id="ID130">
<h4>No Implicit Fallthrough<a class="headerlink" href="ControlFlow.html#ID130" title="Permalink to this headline">¶</a></h4>
<p>In contrast with <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements in C and Objective-C, <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements in Swift do not fall through the bottom of each case and into the next one by default. Instead, the entire <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement finishes its execution as soon as the first matching <code class="docutils literal notranslate"><span class="pre">switch</span></code> case is completed, without requiring an explicit <code class="docutils literal notranslate"><span class="pre">break</span></code> statement. This makes the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement safer and easier to use than the one in C and avoids executing more than one <code class="docutils literal notranslate"><span class="pre">switch</span></code> case by mistake.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although <code class="docutils literal notranslate"><span class="pre">break</span></code> is not required in Swift, you can use a <code class="docutils literal notranslate"><span class="pre">break</span></code> statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution. For details, see <a class="reference internal" href="ControlFlow.html#ID139"><span class="std std-ref">Break in a Switch Statement</span></a>.</p>
</div>
<p>The body of each case <em>must</em> contain at least one executable statement. It is not valid to write the following code, because the first case is empty:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">anotherCharacter</span>: <span class="nc">Character</span> = <span class="s">"a"</span>
</li><li><span class="k">switch</span> <span class="nv">anotherCharacter</span> {
</li><li><span class="k">case</span> <span class="s">"a"</span>: <span class="c">// Invalid, the case has an empty body</span>
</li><li><span class="k">case</span> <span class="s">"A"</span>:
</li><li> <span class="nv">print</span>(<span class="s">"The letter A"</span>)
</li><li><span class="k">default</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Not the letter A"</span>)
</li><li>}
</li><li><span class="c">// This will report a compile-time error.</span>
</li></ol></div></div></div>
<p>Unlike a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement in C, this <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement does not match both <code class="docutils literal notranslate"><span class="pre">"a"</span></code> and <code class="docutils literal notranslate"><span class="pre">"A"</span></code>. Rather, it reports a compile-time error that <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">"a":</span></code> does not contain any executable statements. This approach avoids accidental fallthrough from one case to another and makes for safer code that is clearer in its intent.</p>
<p>To make a <code class="docutils literal notranslate"><span class="pre">switch</span></code> with a single case that matches both <code class="docutils literal notranslate"><span class="pre">"a"</span></code> and <code class="docutils literal notranslate"><span class="pre">"A"</span></code>, combine the two values into a compound case, separating the values with commas.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">anotherCharacter</span>: <span class="nc">Character</span> = <span class="s">"a"</span>
</li><li><span class="k">switch</span> <span class="nv">anotherCharacter</span> {
</li><li><span class="k">case</span> <span class="s">"a"</span>, <span class="s">"A"</span>:
</li><li> <span class="nv">print</span>(<span class="s">"The letter A"</span>)
</li><li><span class="k">default</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Not the letter A"</span>)
</li><li>}
</li><li><span class="c">// Prints "The letter A"</span>
</li></ol></div></div></div>
<p>For readability, a compound case can also be written over multiple lines. For more information about compound cases, see <a class="reference internal" href="ControlFlow.html#ID548"><span class="std std-ref">Compound Cases</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To explicitly fall through at the end of a particular <code class="docutils literal notranslate"><span class="pre">switch</span></code> case, use the <code class="docutils literal notranslate"><span class="pre">fallthrough</span></code> keyword, as described in <a class="reference internal" href="ControlFlow.html#ID140"><span class="std std-ref">Fallthrough</span></a>.</p>
</div>
</div>
<div class="section" id="ID131">
<h4>Interval Matching<a class="headerlink" href="ControlFlow.html#ID131" title="Permalink to this headline">¶</a></h4>
<p>Values in <code class="docutils literal notranslate"><span class="pre">switch</span></code> cases can be checked for their inclusion in an interval. This example uses number intervals to provide a natural-language count for numbers of any size:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">approximateCount</span> = <span class="m">62</span>
</li><li><span class="k">let</span> <span class="nv">countedThings</span> = <span class="s">"moons orbiting Saturn"</span>
</li><li><span class="k">let</span> <span class="nv">naturalCount</span>: <span class="nc">String</span>
</li><li><span class="k">switch</span> <span class="nv">approximateCount</span> {
</li><li><span class="k">case</span> <span class="m">0</span>:
</li><li> <span class="nv">naturalCount</span> = <span class="s">"no"</span>
</li><li><span class="k">case</span> <span class="m">1</span>..&lt;<span class="m">5</span>:
</li><li> <span class="nv">naturalCount</span> = <span class="s">"a few"</span>
</li><li><span class="k">case</span> <span class="m">5</span>..&lt;<span class="m">12</span>:
</li><li> <span class="nv">naturalCount</span> = <span class="s">"several"</span>
</li><li><span class="k">case</span> <span class="m">12</span>..&lt;<span class="m">100</span>:
</li><li> <span class="nv">naturalCount</span> = <span class="s">"dozens of"</span>
</li><li><span class="k">case</span> <span class="m">100</span>..&lt;<span class="m">1000</span>:
</li><li> <span class="nv">naturalCount</span> = <span class="s">"hundreds of"</span>
</li><li><span class="k">default</span>:
</li><li> <span class="nv">naturalCount</span> = <span class="s">"many"</span>
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">"There are </span>\<span class="p">(</span><span class="nv">naturalCount</span><span class="p">)</span><span class="s"> </span>\<span class="p">(</span><span class="nv">countedThings</span><span class="p">)</span><span class="s">."</span>)
</li><li><span class="c">// Prints "There are dozens of moons orbiting Saturn."</span>
</li></ol></div></div></div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">approximateCount</span></code> is evaluated in a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement. Each <code class="docutils literal notranslate"><span class="pre">case</span></code> compares that value to a number or interval. Because the value of <code class="docutils literal notranslate"><span class="pre">approximateCount</span></code> falls between 12 and 100, <code class="docutils literal notranslate"><span class="pre">naturalCount</span></code> is assigned the value <code class="docutils literal notranslate"><span class="pre">"dozens</span> <span class="pre">of"</span></code>, and execution is transferred out of the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement.</p>
</div>
<div class="section" id="ID132">
<h4>Tuples<a class="headerlink" href="ControlFlow.html#ID132" title="Permalink to this headline">¶</a></h4>
<p>You can use tuples to test multiple values in the same <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement. Each element of the tuple can be tested against a different value or interval of values. Alternatively, use the underscore character (<code class="docutils literal notranslate"><span class="pre">_</span></code>), also known as the wildcard pattern, to match any possible value.</p>
<p>The example below takes an (x, y) point, expressed as a simple tuple of type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span></code>, and categorizes it on the graph that follows the example.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">somePoint</span> = (<span class="m">1</span>, <span class="m">1</span>)
</li><li><span class="k">switch</span> <span class="nv">somePoint</span> {
</li><li><span class="k">case</span> (<span class="m">0</span>, <span class="m">0</span>):
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">somePoint</span><span class="p">)</span><span class="s"> is at the origin"</span>)
</li><li><span class="k">case</span> (<span class="k">_</span>, <span class="m">0</span>):
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">somePoint</span><span class="p">)</span><span class="s"> is on the x-axis"</span>)
</li><li><span class="k">case</span> (<span class="m">0</span>, <span class="k">_</span>):
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">somePoint</span><span class="p">)</span><span class="s"> is on the y-axis"</span>)
</li><li><span class="k">case</span> (<span class="m">-2</span>...<span class="m">2</span>, <span class="m">-2</span>...<span class="m">2</span>):
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">somePoint</span><span class="p">)</span><span class="s"> is inside the box"</span>)
</li><li><span class="k">default</span>:
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">somePoint</span><span class="p">)</span><span class="s"> is outside of the box"</span>)
</li><li>}
</li><li><span class="c">// Prints "(1, 1) is inside the box"</span>
</li></ol></div></div></div>
<img alt="../_images/coordinateGraphSimple_2x.png" class="align-center" src="../_images/coordinateGraphSimple_2x.png" style="width: 288px;"/>
<p>The <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement determines whether the point is at the origin (0, 0), on the red x-axis, on the orange y-axis, inside the blue 4-by-4 box centered on the origin, or outside of the box.</p>
<p>Unlike C, Swift allows multiple <code class="docutils literal notranslate"><span class="pre">switch</span></code> cases to consider the same value or values. In fact, the point (0, 0) could match all <em>four</em> of the cases in this example. However, if multiple matches are possible, the first matching case is always used. The point (0, 0) would match <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">(0,</span> <span class="pre">0)</span></code> first, and so all other matching cases would be ignored.</p>
</div>
<div class="section" id="ID133">
<h4>Value Bindings<a class="headerlink" href="ControlFlow.html#ID133" title="Permalink to this headline">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">switch</span></code> case can name the value or values it matches to temporary constants or variables, for use in the body of the case. This behavior is known as <em>value binding</em>, because the values are bound to temporary constants or variables within the case’s body.</p>
<p>The example below takes an (x, y) point, expressed as a tuple of type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span></code>, and categorizes it on the graph that follows:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">anotherPoint</span> = (<span class="m">2</span>, <span class="m">0</span>)
</li><li><span class="k">switch</span> <span class="nv">anotherPoint</span> {
</li><li><span class="k">case</span> (<span class="k">let</span> <span class="nv">x</span>, <span class="m">0</span>):
</li><li> <span class="nv">print</span>(<span class="s">"on the x-axis with an x value of </span>\<span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="k">case</span> (<span class="m">0</span>, <span class="k">let</span> <span class="nv">y</span>):
</li><li> <span class="nv">print</span>(<span class="s">"on the y-axis with a y value of </span>\<span class="p">(</span><span class="nv">y</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="k">case</span> <span class="k">let</span> (<span class="nv">x</span>, <span class="nv">y</span>):
</li><li> <span class="nv">print</span>(<span class="s">"somewhere else at (</span>\<span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">y</span><span class="p">)</span><span class="s">)"</span>)
</li><li>}
</li><li><span class="c">// Prints "on the x-axis with an x value of 2"</span>
</li></ol></div></div></div>
<img alt="../_images/coordinateGraphMedium_2x.png" class="align-center" src="../_images/coordinateGraphMedium_2x.png" style="width: 288px;"/>
<p>The <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement determines whether the point is on the red x-axis, on the orange y-axis, or elsewhere (on neither axis).</p>
<p>The three <code class="docutils literal notranslate"><span class="pre">switch</span></code> cases declare placeholder constants <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, which temporarily take on one or both tuple values from <code class="docutils literal notranslate"><span class="pre">anotherPoint</span></code>. The first case, <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">(let</span> <span class="pre">x,</span> <span class="pre">0)</span></code>, matches any point with a <code class="docutils literal notranslate"><span class="pre">y</span></code> value of <code class="docutils literal notranslate"><span class="pre">0</span></code> and assigns the point’s <code class="docutils literal notranslate"><span class="pre">x</span></code> value to the temporary constant <code class="docutils literal notranslate"><span class="pre">x</span></code>. Similarly, the second case, <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">(0,</span> <span class="pre">let</span> <span class="pre">y)</span></code>, matches any point with an <code class="docutils literal notranslate"><span class="pre">x</span></code> value of <code class="docutils literal notranslate"><span class="pre">0</span></code> and assigns the point’s <code class="docutils literal notranslate"><span class="pre">y</span></code> value to the temporary constant <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>After the temporary constants are declared, they can be used within the case’s code block. Here, they are used to print the categorization of the point.</p>
<p>This <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement does not have a <code class="docutils literal notranslate"><span class="pre">default</span></code> case. The final case, <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">let</span> <span class="pre">(x,</span> <span class="pre">y)</span></code>, declares a tuple of two placeholder constants that can match any value. Because <code class="docutils literal notranslate"><span class="pre">anotherPoint</span></code> is always a tuple of two values, this case matches all possible remaining values, and a <code class="docutils literal notranslate"><span class="pre">default</span></code> case is not needed to make the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement exhaustive.</p>
</div>
<div class="section" id="ID134">
<h4>Where<a class="headerlink" href="ControlFlow.html#ID134" title="Permalink to this headline">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">switch</span></code> case can use a <code class="docutils literal notranslate"><span class="pre">where</span></code> clause to check for additional conditions.</p>
<p>The example below categorizes an (x, y) point on the following graph:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">yetAnotherPoint</span> = (<span class="m">1</span>, <span class="m">-1</span>)
</li><li><span class="k">switch</span> <span class="nv">yetAnotherPoint</span> {
</li><li><span class="k">case</span> <span class="k">let</span> (<span class="nv">x</span>, <span class="nv">y</span>) <span class="k">where</span> <span class="nv">x</span> == <span class="nv">y</span>:
</li><li> <span class="nv">print</span>(<span class="s">"(</span>\<span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">y</span><span class="p">)</span><span class="s">) is on the line x == y"</span>)
</li><li><span class="k">case</span> <span class="k">let</span> (<span class="nv">x</span>, <span class="nv">y</span>) <span class="k">where</span> <span class="nv">x</span> == -<span class="nv">y</span>:
</li><li> <span class="nv">print</span>(<span class="s">"(</span>\<span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">y</span><span class="p">)</span><span class="s">) is on the line x == -y"</span>)
</li><li><span class="k">case</span> <span class="k">let</span> (<span class="nv">x</span>, <span class="nv">y</span>):
</li><li> <span class="nv">print</span>(<span class="s">"(</span>\<span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">y</span><span class="p">)</span><span class="s">) is just some arbitrary point"</span>)
</li><li>}
</li><li><span class="c">// Prints "(1, -1) is on the line x == -y"</span>
</li></ol></div></div></div>
<img alt="../_images/coordinateGraphComplex_2x.png" class="align-center" src="../_images/coordinateGraphComplex_2x.png" style="width: 289px;"/>
<p>The <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement determines whether the point is on the green diagonal line where <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>, on the purple diagonal line where <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">-y</span></code>, or neither.</p>
<p>The three <code class="docutils literal notranslate"><span class="pre">switch</span></code> cases declare placeholder constants <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, which temporarily take on the two tuple values from <code class="docutils literal notranslate"><span class="pre">yetAnotherPoint</span></code>. These constants are used as part of a <code class="docutils literal notranslate"><span class="pre">where</span></code> clause, to create a dynamic filter. The <code class="docutils literal notranslate"><span class="pre">switch</span></code> case matches the current value of <code class="docutils literal notranslate"><span class="pre">point</span></code> only if the <code class="docutils literal notranslate"><span class="pre">where</span></code> clause’s condition evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code> for that value.</p>
<p>As in the previous example, the final case matches all possible remaining values, and so a <code class="docutils literal notranslate"><span class="pre">default</span></code> case is not needed to make the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement exhaustive.</p>
</div>
<div class="section" id="ID548">
<h4>Compound Cases<a class="headerlink" href="ControlFlow.html#ID548" title="Permalink to this headline">¶</a></h4>
<p>Multiple switch cases that share the same body can be combined by writing several patterns after <code class="docutils literal notranslate"><span class="pre">case</span></code>, with a comma between each of the patterns. If any of the patterns match, then the case is considered to match. The patterns can be written over multiple lines if the list is long. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someCharacter</span>: <span class="nc">Character</span> = <span class="s">"e"</span>
</li><li><span class="k">switch</span> <span class="nv">someCharacter</span> {
</li><li><span class="k">case</span> <span class="s">"a"</span>, <span class="s">"e"</span>, <span class="s">"i"</span>, <span class="s">"o"</span>, <span class="s">"u"</span>:
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">someCharacter</span><span class="p">)</span><span class="s"> is a vowel"</span>)
</li><li><span class="k">case</span> <span class="s">"b"</span>, <span class="s">"c"</span>, <span class="s">"d"</span>, <span class="s">"f"</span>, <span class="s">"g"</span>, <span class="s">"h"</span>, <span class="s">"j"</span>, <span class="s">"k"</span>, <span class="s">"l"</span>, <span class="s">"m"</span>,
</li><li> <span class="s">"n"</span>, <span class="s">"p"</span>, <span class="s">"q"</span>, <span class="s">"r"</span>, <span class="s">"s"</span>, <span class="s">"t"</span>, <span class="s">"v"</span>, <span class="s">"w"</span>, <span class="s">"x"</span>, <span class="s">"y"</span>, <span class="s">"z"</span>:
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">someCharacter</span><span class="p">)</span><span class="s"> is a consonant"</span>)
</li><li><span class="k">default</span>:
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">someCharacter</span><span class="p">)</span><span class="s"> is not a vowel or a consonant"</span>)
</li><li>}
</li><li><span class="c">// Prints "e is a vowel"</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement’s first case matches all five lowercase vowels in the English language. Similarly, its second case matches all lowercase English consonants. Finally, the <code class="docutils literal notranslate"><span class="pre">default</span></code> case matches any other character.</p>
<p>Compound cases can also include value bindings. All of the patterns of a compound case have to include the same set of value bindings, and each binding has to get a value of the same type from all of the patterns in the compound case. This ensures that, no matter which part of the compound case matched, the code in the body of the case can always access a value for the bindings and that the value always has the same type.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">stillAnotherPoint</span> = (<span class="m">9</span>, <span class="m">0</span>)
</li><li><span class="k">switch</span> <span class="nv">stillAnotherPoint</span> {
</li><li><span class="k">case</span> (<span class="k">let</span> <span class="nv">distance</span>, <span class="m">0</span>), (<span class="m">0</span>, <span class="k">let</span> <span class="nv">distance</span>):
</li><li> <span class="nv">print</span>(<span class="s">"On an axis, </span>\<span class="p">(</span><span class="nv">distance</span><span class="p">)</span><span class="s"> from the origin"</span>)
</li><li><span class="k">default</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Not on an axis"</span>)
</li><li>}
</li><li><span class="c">// Prints "On an axis, 9 from the origin"</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">case</span></code> above has two patterns: <code class="docutils literal notranslate"><span class="pre">(let</span> <span class="pre">distance,</span> <span class="pre">0)</span></code> matches points on the x-axis and <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">let</span> <span class="pre">distance)</span></code> matches points on the y-axis. Both patterns include a binding for <code class="docutils literal notranslate"><span class="pre">distance</span></code> and <code class="docutils literal notranslate"><span class="pre">distance</span></code> is an integer in both patterns—which means that the code in the body of the <code class="docutils literal notranslate"><span class="pre">case</span></code> can always access a value for <code class="docutils literal notranslate"><span class="pre">distance</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="ID135">
<h2>Control Transfer Statements<a class="headerlink" href="ControlFlow.html#ID135" title="Permalink to this headline">¶</a></h2>
<p><em>Control transfer statements</em> change the order in which your code is executed, by transferring control from one piece of code to another. Swift has five control transfer statements:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">continue</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">break</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">fallthrough</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">return</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">throw</span></code></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">continue</span></code>, <code class="docutils literal notranslate"><span class="pre">break</span></code>, and <code class="docutils literal notranslate"><span class="pre">fallthrough</span></code> statements are described below. The <code class="docutils literal notranslate"><span class="pre">return</span></code> statement is described in <a class="reference internal" href="Functions.html"><span class="doc">Functions</span></a>, and the <code class="docutils literal notranslate"><span class="pre">throw</span></code> statement is described in <a class="reference internal" href="ErrorHandling.html#ID510"><span class="std std-ref">Propagating Errors Using Throwing Functions</span></a>.</p>
<div class="section" id="ID136">
<h3>Continue<a class="headerlink" href="ControlFlow.html#ID136" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop. It says “I am done with the current loop iteration” without leaving the loop altogether.</p>
<p>The following example removes all vowels and spaces from a lowercase string to create a cryptic puzzle phrase:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">puzzleInput</span> = <span class="s">"great minds think alike"</span>
</li><li><span class="k">var</span> <span class="nv">puzzleOutput</span> = <span class="s">""</span>
</li><li><span class="k">let</span> <span class="nv">charactersToRemove</span>: [<span class="nc">Character</span>] = [<span class="s">"a"</span>, <span class="s">"e"</span>, <span class="s">"i"</span>, <span class="s">"o"</span>, <span class="s">"u"</span>, <span class="s">" "</span>]
</li><li><span class="k">for</span> <span class="nv">character</span> <span class="k">in</span> <span class="nv">puzzleInput</span> {
</li><li> <span class="k">if</span> <span class="nv">charactersToRemove</span>.<span class="nv">contains</span>(<span class="nv">character</span>) {
</li><li> <span class="k">continue</span>
</li><li>    }
</li><li> <span class="nv">puzzleOutput</span>.<span class="nv">append</span>(<span class="nv">character</span>)
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">puzzleOutput</span>)
</li><li><span class="c">// Prints "grtmndsthnklk"</span>
</li></ol></div></div></div>
<p>The code above calls the <code class="docutils literal notranslate"><span class="pre">continue</span></code> keyword whenever it matches a vowel or a space, causing the current iteration of the loop to end immediately and to jump straight to the start of the next iteration.</p>
</div>
<div class="section" id="ID137">
<h3>Break<a class="headerlink" href="ControlFlow.html#ID137" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">break</span></code> statement ends execution of an entire control flow statement immediately. The <code class="docutils literal notranslate"><span class="pre">break</span></code> statement can be used inside a <code class="docutils literal notranslate"><span class="pre">switch</span></code> or loop statement when you want to terminate the execution of the <code class="docutils literal notranslate"><span class="pre">switch</span></code> or loop statement earlier than would otherwise be the case.</p>
<div class="section" id="ID138">
<h4>Break in a Loop Statement<a class="headerlink" href="ControlFlow.html#ID138" title="Permalink to this headline">¶</a></h4>
<p>When used inside a loop statement, <code class="docutils literal notranslate"><span class="pre">break</span></code> ends the loop’s execution immediately and transfers control to the code after the loop’s closing brace (<code class="docutils literal notranslate"><span class="pre">}</span></code>). No further code from the current iteration of the loop is executed, and no further iterations of the loop are started.</p>
</div>
<div class="section" id="ID139">
<h4>Break in a Switch Statement<a class="headerlink" href="ControlFlow.html#ID139" title="Permalink to this headline">¶</a></h4>
<p>When used inside a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement, <code class="docutils literal notranslate"><span class="pre">break</span></code> causes the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement to end its execution immediately and to transfer control to the code after the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement’s closing brace (<code class="docutils literal notranslate"><span class="pre">}</span></code>).</p>
<p>This behavior can be used to match and ignore one or more cases in a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement. Because Swift’s <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement is exhaustive and does not allow empty cases, it is sometimes necessary to deliberately match and ignore a case in order to make your intentions explicit. You do this by writing the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement as the entire body of the case you want to ignore. When that case is matched by the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement, the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement inside the case ends the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement’s execution immediately.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A <code class="docutils literal notranslate"><span class="pre">switch</span></code> case that contains only a comment is reported as a compile-time error. Comments are not statements and do not cause a <code class="docutils literal notranslate"><span class="pre">switch</span></code> case to be ignored. Always use a <code class="docutils literal notranslate"><span class="pre">break</span></code> statement to ignore a <code class="docutils literal notranslate"><span class="pre">switch</span></code> case.</p>
</div>
<p>The following example switches on a <code class="docutils literal notranslate"><span class="pre">Character</span></code> value and determines whether it represents a number symbol in one of four languages. For brevity, multiple values are covered in a single <code class="docutils literal notranslate"><span class="pre">switch</span></code> case.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">numberSymbol</span>: <span class="nc">Character</span> = <span class="s">"三"</span> <span class="c">// Chinese symbol for the number 3</span>
</li><li><span class="k">var</span> <span class="nv">possibleIntegerValue</span>: <span class="nc">Int</span>?
</li><li><span class="k">switch</span> <span class="nv">numberSymbol</span> {
</li><li><span class="k">case</span> <span class="s">"1"</span>, <span class="s">"١"</span>, <span class="s">"一"</span>, <span class="s">"๑"</span>:
</li><li> <span class="nv">possibleIntegerValue</span> = <span class="m">1</span>
</li><li><span class="k">case</span> <span class="s">"2"</span>, <span class="s">"٢"</span>, <span class="s">"二"</span>, <span class="s">"๒"</span>:
</li><li> <span class="nv">possibleIntegerValue</span> = <span class="m">2</span>
</li><li><span class="k">case</span> <span class="s">"3"</span>, <span class="s">"٣"</span>, <span class="s">"三"</span>, <span class="s">"๓"</span>:
</li><li> <span class="nv">possibleIntegerValue</span> = <span class="m">3</span>
</li><li><span class="k">case</span> <span class="s">"4"</span>, <span class="s">"٤"</span>, <span class="s">"四"</span>, <span class="s">"๔"</span>:
</li><li> <span class="nv">possibleIntegerValue</span> = <span class="m">4</span>
</li><li><span class="k">default</span>:
</li><li> <span class="k">break</span>
</li><li>}
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">integerValue</span> = <span class="nv">possibleIntegerValue</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The integer value of </span>\<span class="p">(</span><span class="nv">numberSymbol</span><span class="p">)</span><span class="s"> is </span>\<span class="p">(</span><span class="nv">integerValue</span><span class="p">)</span><span class="s">."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"An integer value could not be found for </span>\<span class="p">(</span><span class="nv">numberSymbol</span><span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li><span class="c">// Prints "The integer value of 三 is 3."</span>
</li></ol></div></div></div>
<p>This example checks <code class="docutils literal notranslate"><span class="pre">numberSymbol</span></code> to determine whether it is a Latin, Arabic, Chinese, or Thai symbol for the numbers <code class="docutils literal notranslate"><span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">4</span></code>. If a match is found, one of the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement’s cases sets an optional <code class="docutils literal notranslate"><span class="pre">Int?</span></code> variable called <code class="docutils literal notranslate"><span class="pre">possibleIntegerValue</span></code> to an appropriate integer value.</p>
<p>After the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement completes its execution, the example uses optional binding to determine whether a value was found. The <code class="docutils literal notranslate"><span class="pre">possibleIntegerValue</span></code> variable has an implicit initial value of <code class="docutils literal notranslate"><span class="pre">nil</span></code> by virtue of being an optional type, and so the optional binding will succeed only if <code class="docutils literal notranslate"><span class="pre">possibleIntegerValue</span></code> was set to an actual value by one of the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement’s first four cases.</p>
<p>Because it’s not practical to list every possible <code class="docutils literal notranslate"><span class="pre">Character</span></code> value in the example above, a <code class="docutils literal notranslate"><span class="pre">default</span></code> case handles any characters that are not matched. This <code class="docutils literal notranslate"><span class="pre">default</span></code> case does not need to perform any action, and so it is written with a single <code class="docutils literal notranslate"><span class="pre">break</span></code> statement as its body. As soon as the <code class="docutils literal notranslate"><span class="pre">default</span></code> case is matched, the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement ends the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement’s execution, and code execution continues from the <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">let</span></code> statement.</p>
</div>
</div>
<div class="section" id="ID140">
<h3>Fallthrough<a class="headerlink" href="ControlFlow.html#ID140" title="Permalink to this headline">¶</a></h3>
<p>In Swift, <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements don’t fall through the bottom of each case and into the next one. That is, the entire <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement completes its execution as soon as the first matching case is completed. By contrast, C requires you to insert an explicit <code class="docutils literal notranslate"><span class="pre">break</span></code> statement at the end of every <code class="docutils literal notranslate"><span class="pre">switch</span></code> case to prevent fallthrough. Avoiding default fallthrough means that Swift <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements are much more concise and predictable than their counterparts in C, and thus they avoid executing multiple <code class="docutils literal notranslate"><span class="pre">switch</span></code> cases by mistake.</p>
<p>If you need C-style fallthrough behavior, you can opt in to this behavior on a case-by-case basis with the <code class="docutils literal notranslate"><span class="pre">fallthrough</span></code> keyword. The example below uses <code class="docutils literal notranslate"><span class="pre">fallthrough</span></code> to create a textual description of a number.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">integerToDescribe</span> = <span class="m">5</span>
</li><li><span class="k">var</span> <span class="nv">description</span> = <span class="s">"The number </span>\<span class="p">(</span><span class="nv">integerToDescribe</span><span class="p">)</span><span class="s"> is"</span>
</li><li><span class="k">switch</span> <span class="nv">integerToDescribe</span> {
</li><li><span class="k">case</span> <span class="m">2</span>, <span class="m">3</span>, <span class="m">5</span>, <span class="m">7</span>, <span class="m">11</span>, <span class="m">13</span>, <span class="m">17</span>, <span class="m">19</span>:
</li><li> <span class="nv">description</span> += <span class="s">" a prime number, and also"</span>
</li><li> <span class="k">fallthrough</span>
</li><li><span class="k">default</span>:
</li><li> <span class="nv">description</span> += <span class="s">" an integer."</span>
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">description</span>)
</li><li><span class="c">// Prints "The number 5 is a prime number, and also an integer."</span>
</li></ol></div></div></div>
<p>This example declares a new <code class="docutils literal notranslate"><span class="pre">String</span></code> variable called <code class="docutils literal notranslate"><span class="pre">description</span></code> and assigns it an initial value. The function then considers the value of <code class="docutils literal notranslate"><span class="pre">integerToDescribe</span></code> using a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement. If the value of <code class="docutils literal notranslate"><span class="pre">integerToDescribe</span></code> is one of the prime numbers in the list, the function appends text to the end of <code class="docutils literal notranslate"><span class="pre">description</span></code>, to note that the number is prime. It then uses the <code class="docutils literal notranslate"><span class="pre">fallthrough</span></code> keyword to “fall into” the <code class="docutils literal notranslate"><span class="pre">default</span></code> case as well. The <code class="docutils literal notranslate"><span class="pre">default</span></code> case adds some extra text to the end of the description, and the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement is complete.</p>
<p>Unless the value of <code class="docutils literal notranslate"><span class="pre">integerToDescribe</span></code> is in the list of known prime numbers, it is not matched by the first <code class="docutils literal notranslate"><span class="pre">switch</span></code> case at all. Because there are no other specific cases, <code class="docutils literal notranslate"><span class="pre">integerToDescribe</span></code> is matched by the <code class="docutils literal notranslate"><span class="pre">default</span></code> case.</p>
<p>After the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement has finished executing, the number’s description is printed using the <code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code> function. In this example, the number <code class="docutils literal notranslate"><span class="pre">5</span></code> is correctly identified as a prime number.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">fallthrough</span></code> keyword does not check the case conditions for the <code class="docutils literal notranslate"><span class="pre">switch</span></code> case that it causes execution to fall into. The <code class="docutils literal notranslate"><span class="pre">fallthrough</span></code> keyword simply causes code execution to move directly to the statements inside the next case (or <code class="docutils literal notranslate"><span class="pre">default</span></code> case) block, as in C’s standard <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement behavior.</p>
</div>
</div>
<div class="section" id="ID141">
<h3>Labeled Statements<a class="headerlink" href="ControlFlow.html#ID141" title="Permalink to this headline">¶</a></h3>
<p>In Swift, you can nest loops and conditional statements inside other loops and conditional statements to create complex control flow structures. However, loops and conditional statements can both use the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement to end their execution prematurely. Therefore, it is sometimes useful to be explicit about which loop or conditional statement you want a <code class="docutils literal notranslate"><span class="pre">break</span></code> statement to terminate. Similarly, if you have multiple nested loops, it can be useful to be explicit about which loop the <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement should affect.</p>
<p>To achieve these aims, you can mark a loop statement or conditional statement with a <em>statement label</em>. With a conditional statement, you can use a statement label with the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement to end the execution of the labeled statement. With a loop statement, you can use a statement label with the <code class="docutils literal notranslate"><span class="pre">break</span></code> or <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement to end or continue the execution of the labeled statement.</p>
<p>A labeled statement is indicated by placing a label on the same line as the statement’s introducer keyword, followed by a colon. Here’s an example of this syntax for a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, although the principle is the same for all loops and <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">label name</span>: <span class="k">while</span> <span class="gi">condition</span> {
</li><li> <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>The following example uses the <code class="docutils literal notranslate"><span class="pre">break</span></code> and <code class="docutils literal notranslate"><span class="pre">continue</span></code> statements with a labeled <code class="docutils literal notranslate"><span class="pre">while</span></code> loop for an adapted version of the <em>Snakes and Ladders</em> game that you saw earlier in this chapter. This time around, the game has an extra rule:</p>
<ul class="simple">
<li>To win, you must land <em>exactly</em> on square 25.</li>
</ul>
<p>If a particular dice roll would take you beyond square 25, you must roll again until you roll the exact number needed to land on square 25.</p>
<p>The game board is the same as before.</p>
<img alt="../_images/snakesAndLadders_2x.png" class="align-center" src="../_images/snakesAndLadders_2x.png" style="width: 623px;"/>
<p>The values of <code class="docutils literal notranslate"><span class="pre">finalSquare</span></code>, <code class="docutils literal notranslate"><span class="pre">board</span></code>, <code class="docutils literal notranslate"><span class="pre">square</span></code>, and <code class="docutils literal notranslate"><span class="pre">diceRoll</span></code> are initialized in the same way as before:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">finalSquare</span> = <span class="m">25</span>
</li><li><span class="k">var</span> <span class="nv">board</span> = [<span class="nv">Int</span>](<span class="nv">repeating</span>: <span class="m">0</span>, <span class="nv">count</span>: <span class="nv">finalSquare</span> + <span class="m">1</span>)
</li><li><span class="nv">board</span>[<span class="m">03</span>] = +<span class="m">08</span>; <span class="nv">board</span>[<span class="m">06</span>] = +<span class="m">11</span>; <span class="nv">board</span>[<span class="m">09</span>] = +<span class="m">09</span>; <span class="nv">board</span>[<span class="m">10</span>] = +<span class="m">02</span>
</li><li><span class="nv">board</span>[<span class="m">14</span>] = <span class="m">-10</span>; <span class="nv">board</span>[<span class="m">19</span>] = <span class="m">-11</span>; <span class="nv">board</span>[<span class="m">22</span>] = <span class="m">-02</span>; <span class="nv">board</span>[<span class="m">24</span>] = <span class="m">-08</span>
</li><li><span class="k">var</span> <span class="nv">square</span> = <span class="m">0</span>
</li><li><span class="k">var</span> <span class="nv">diceRoll</span> = <span class="m">0</span>
</li></ol></div></div></div>
<p>This version of the game uses a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop and a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement to implement the game’s logic. The <code class="docutils literal notranslate"><span class="pre">while</span></code> loop has a statement label called <code class="docutils literal notranslate"><span class="pre">gameLoop</span></code> to indicate that it is the main game loop for the Snakes and Ladders game.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">while</span></code> loop’s condition is <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">square</span> <span class="pre">!=</span> <span class="pre">finalSquare</span></code>, to reflect that you must land exactly on square 25.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">gameLoop</span>: <span class="k">while</span> <span class="nv">square</span> != <span class="nv">finalSquare</span> {
</li><li> <span class="nv">diceRoll</span> += <span class="m">1</span>
</li><li> <span class="k">if</span> <span class="nv">diceRoll</span> == <span class="m">7</span> { <span class="nv">diceRoll</span> = <span class="m">1</span> }
</li><li> <span class="k">switch</span> <span class="nv">square</span> + <span class="nv">diceRoll</span> {
</li><li> <span class="k">case</span> <span class="nv">finalSquare</span>:
</li><li> <span class="c">// diceRoll will move us to the final square, so the game is over</span>
</li><li> <span class="k">break</span> <span class="nv">gameLoop</span>
</li><li> <span class="k">case</span> <span class="k">let</span> <span class="nv">newSquare</span> <span class="k">where</span> <span class="nv">newSquare</span> &gt; <span class="nv">finalSquare</span>:
</li><li> <span class="c">// diceRoll will move us beyond the final square, so roll again</span>
</li><li> <span class="k">continue</span> <span class="nv">gameLoop</span>
</li><li> <span class="k">default</span>:
</li><li> <span class="c">// this is a valid move, so find out its effect</span>
</li><li> <span class="nv">square</span> += <span class="nv">diceRoll</span>
</li><li> <span class="nv">square</span> += <span class="nv">board</span>[<span class="nv">square</span>]
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">"Game over!"</span>)
</li></ol></div></div></div>
<p>The dice is rolled at the start of each loop. Rather than moving the player immediately, the loop uses a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement to consider the result of the move and to determine whether the move is allowed:</p>
<ul class="simple">
<li>If the dice roll will move the player onto the final square, the game is over. The <code class="docutils literal notranslate"><span class="pre">break</span> <span class="pre">gameLoop</span></code> statement transfers control to the first line of code outside of the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, which ends the game.</li>
<li>If the dice roll will move the player <em>beyond</em> the final square, the move is invalid and the player needs to roll again. The <code class="docutils literal notranslate"><span class="pre">continue</span> <span class="pre">gameLoop</span></code> statement ends the current <code class="docutils literal notranslate"><span class="pre">while</span></code> loop iteration and begins the next iteration of the loop.</li>
<li>In all other cases, the dice roll is a valid move. The player moves forward by <code class="docutils literal notranslate"><span class="pre">diceRoll</span></code> squares, and the game logic checks for any snakes and ladders. The loop then ends, and control returns to the <code class="docutils literal notranslate"><span class="pre">while</span></code> condition to decide whether another turn is required.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement above did not use the <code class="docutils literal notranslate"><span class="pre">gameLoop</span></code> label, it would break out of the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement, not the <code class="docutils literal notranslate"><span class="pre">while</span></code> statement. Using the <code class="docutils literal notranslate"><span class="pre">gameLoop</span></code> label makes it clear which control statement should be terminated.</p>
<p class="last">It is not strictly necessary to use the <code class="docutils literal notranslate"><span class="pre">gameLoop</span></code> label when calling <code class="docutils literal notranslate"><span class="pre">continue</span> <span class="pre">gameLoop</span></code> to jump to the next iteration of the loop. There is only one loop in the game, and therefore no ambiguity as to which loop the <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement will affect. However, there is no harm in using the <code class="docutils literal notranslate"><span class="pre">gameLoop</span></code> label with the <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement. Doing so is consistent with the label’s use alongside the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement and helps make the game’s logic clearer to read and understand.</p>
</div>
</div>
</div>
<div class="section" id="ID525">
<h2>Early Exit<a class="headerlink" href="ControlFlow.html#ID525" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement, like an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, executes statements depending on the Boolean value of an expression. You use a <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement to require that a condition must be true in order for the code after the <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement to be executed. Unlike an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, a <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement always has an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause—the code inside the <code class="docutils literal notranslate"><span class="pre">else</span></code> clause is executed if the condition is not true.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">greet</span>(<span class="nv">person</span>: [<span class="nc">String</span>: <span class="nc">String</span>]) {
</li><li> <span class="k">guard</span> <span class="k">let</span> <span class="nv">name</span> = <span class="nv">person</span>[<span class="s">"name"</span>] <span class="k">else</span> {
</li><li> <span class="k">return</span>
</li><li>    }
</li><li>
</li><li> <span class="nv">print</span>(<span class="s">"Hello </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">!"</span>)
</li><li>
</li><li> <span class="k">guard</span> <span class="k">let</span> <span class="nv">location</span> = <span class="nv">person</span>[<span class="s">"location"</span>] <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"I hope the weather is nice near you."</span>)
</li><li> <span class="k">return</span>
</li><li>    }
</li><li>
</li><li> <span class="nv">print</span>(<span class="s">"I hope the weather is nice in </span>\<span class="p">(</span><span class="nv">location</span><span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li>
</li><li><span class="nv">greet</span>(<span class="nv">person</span>: [<span class="s">"name"</span>: <span class="s">"John"</span>])
</li><li><span class="c">// Prints "Hello John!"</span>
</li><li><span class="c">// Prints "I hope the weather is nice near you."</span>
</li><li><span class="nv">greet</span>(<span class="nv">person</span>: [<span class="s">"name"</span>: <span class="s">"Jane"</span>, <span class="s">"location"</span>: <span class="s">"Cupertino"</span>])
</li><li><span class="c">// Prints "Hello Jane!"</span>
</li><li><span class="c">// Prints "I hope the weather is nice in Cupertino."</span>
</li></ol></div></div></div>
<p>If the <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement’s condition is met, code execution continues after the <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement’s closing brace. Any variables or constants that were assigned values using an optional binding as part of the condition are available for the rest of the code block that the <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement appears in.</p>
<p>If that condition is not met, the code inside the <code class="docutils literal notranslate"><span class="pre">else</span></code> branch is executed. That branch must transfer control to exit the code block in which the <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement appears. It can do this with a control transfer statement such as <code class="docutils literal notranslate"><span class="pre">return</span></code>, <code class="docutils literal notranslate"><span class="pre">break</span></code>, <code class="docutils literal notranslate"><span class="pre">continue</span></code>, or <code class="docutils literal notranslate"><span class="pre">throw</span></code>, or it can call a function or method that doesn’t return, such as <code class="docutils literal notranslate"><span class="pre">fatalError(_:file:line:)</span></code>.</p>
<p>Using a <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement for requirements improves the readability of your code, compared to doing the same check with an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement. It lets you write the code that’s typically executed without wrapping it in an <code class="docutils literal notranslate"><span class="pre">else</span></code> block, and it lets you keep the code that handles a violated requirement next to the requirement.</p>
</div>
<div class="section" id="ID523">
<h2>Checking API Availability<a class="headerlink" href="ControlFlow.html#ID523" title="Permalink to this headline">¶</a></h2>
<p>Swift has built-in support for checking API availability, which ensures that you don’t accidentally use APIs that are unavailable on a given deployment target.</p>
<p>The compiler uses availability information in the SDK to verify that all of the APIs used in your code are available on the deployment target specified by your project. Swift reports an error at compile time if you try to use an API that isn’t available.</p>
<p>You use an <em>availability condition</em> in an <code class="docutils literal notranslate"><span class="pre">if</span></code> or <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement to conditionally execute a block of code, depending on whether the APIs you want to use are available at runtime. The compiler uses the information from the availability condition when it verifies that the APIs in that block of code are available.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">#available</span>(<span class="k">iOS</span> <span class="m">10</span>, <span class="k">macOS</span> <span class="m">10.12</span>, *) {
</li><li> <span class="c">// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS</span>
</li><li>} <span class="k">else</span> {
</li><li> <span class="c">// Fall back to earlier iOS and macOS APIs</span>
</li><li>}
</li></ol></div></div></div>
<p>The availability condition above specifies that in iOS, the body of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement executes only in iOS 10 and later; in macOS, only in macOS 10.12 and later. The last argument, <code class="docutils literal notranslate"><span class="pre">*</span></code>, is required and specifies that on any other platform, the body of the <code class="docutils literal notranslate"><span class="pre">if</span></code> executes on the minimum deployment target specified by your target.</p>
<p>In its general form, the availability condition takes a list of platform names and versions. You use platform names such as <code class="docutils literal notranslate"><span class="pre">iOS</span></code>, <code class="docutils literal notranslate"><span class="pre">macOS</span></code>, <code class="docutils literal notranslate"><span class="pre">watchOS</span></code>, and <code class="docutils literal notranslate"><span class="pre">tvOS</span></code>—for the full list, see <a class="reference internal" href="../ReferenceManual/Attributes.html#ID348"><span class="std std-ref">Declaration Attributes</span></a>. In addition to specifying major version numbers like iOS 8 or macOS 10.10, you can specify minor versions numbers like iOS 11.2.6 and macOS 10.13.3.</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">#available</span>(<span class="gi">platform name</span> <span class="gi">version</span>, <span class="gi">...</span>, *) {
</li><li> <span class="gi">statements to execute if the APIs are available</span>
</li><li>} <span class="k">else</span> {
</li><li> <span class="gi">fallback statements to execute if the APIs are unavailable</span>
</li><li>}
</li></ol></div></div></div>
</div>
</div><div class="section" id="functions">
<h1>Functions<a class="headerlink" href="Functions.html#functions" title="Permalink to this headline">¶</a></h1>
<p><em>Functions</em> are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.</p>
<p>Swift’s unified function syntax is flexible enough to express anything from a simple C-style function with no parameter names to a complex Objective-C-style method with names and argument labels for each parameter. Parameters can provide default values to simplify function calls and can be passed as in-out parameters, which modify a passed variable once the function has completed its execution.</p>
<p>Every function in Swift has a type, consisting of the function’s parameter types and return type. You can use this type like any other type in Swift, which makes it easy to pass functions as parameters to other functions, and to return functions from functions. Functions can also be written within other functions to encapsulate useful functionality within a nested function scope.</p>
<div class="section" id="ID159">
<h2>Defining and Calling Functions<a class="headerlink" href="Functions.html#ID159" title="Permalink to this headline">¶</a></h2>
<p>When you define a function, you can optionally define one or more named, typed values that the function takes as input, known as <em>parameters</em>. You can also optionally define a type of value that the function will pass back as output when it is done, known as its <em>return type</em>.</p>
<p>Every function has a <em>function name</em>, which describes the task that the function performs. To use a function, you “call” that function with its name and pass it input values (known as <em>arguments</em>) that match the types of the function’s parameters. A function’s arguments must always be provided in the same order as the function’s parameter list.</p>
<p>The function in the example below is called <code class="docutils literal notranslate"><span class="pre">greet(person:)</span></code>, because that’s what it does—it takes a person’s name as input and returns a greeting for that person. To accomplish this, you define one input parameter—a <code class="docutils literal notranslate"><span class="pre">String</span></code> value called <code class="docutils literal notranslate"><span class="pre">person</span></code>—and a return type of <code class="docutils literal notranslate"><span class="pre">String</span></code>, which will contain a greeting for that person:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">greet</span>(<span class="nv">person</span>: <span class="nc">String</span>) -&gt; <span class="nc">String</span> {
</li><li> <span class="k">let</span> <span class="nv">greeting</span> = <span class="s">"Hello, "</span> + <span class="nv">person</span> + <span class="s">"!"</span>
</li><li> <span class="k">return</span> <span class="nv">greeting</span>
</li><li>}
</li></ol></div></div></div>
<p>All of this information is rolled up into the function’s <em>definition</em>, which is prefixed with the <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword. You indicate the function’s return type with the <em>return arrow</em> <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> (a hyphen followed by a right angle bracket), which is followed by the name of the type to return.</p>
<p>The definition describes what the function does, what it expects to receive, and what it returns when it is done. The definition makes it easy for the function to be called unambiguously from elsewhere in your code:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="nv">greet</span>(<span class="nv">person</span>: <span class="s">"Anna"</span>))
</li><li><span class="c">// Prints "Hello, Anna!"</span>
</li><li><span class="nv">print</span>(<span class="nv">greet</span>(<span class="nv">person</span>: <span class="s">"Brian"</span>))
</li><li><span class="c">// Prints "Hello, Brian!"</span>
</li></ol></div></div></div>
<p>You call the <code class="docutils literal notranslate"><span class="pre">greet(person:)</span></code> function by passing it a <code class="docutils literal notranslate"><span class="pre">String</span></code> value after the <code class="docutils literal notranslate"><span class="pre">person</span></code> argument label, such as <code class="docutils literal notranslate"><span class="pre">greet(person:</span> <span class="pre">"Anna")</span></code>. Because the function returns a <code class="docutils literal notranslate"><span class="pre">String</span></code> value, <code class="docutils literal notranslate"><span class="pre">greet(person:)</span></code> can be wrapped in a call to the <code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code> function to print that string and see its return value, as shown above.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code> function doesn’t have a label for its first argument, and its other arguments are optional because they have a default value. These variations on function syntax are discussed below in <a class="reference internal" href="Functions.html#ID166"><span class="std std-ref">Function Argument Labels and Parameter Names</span></a> and <a class="reference internal" href="Functions.html#ID169"><span class="std std-ref">Default Parameter Values</span></a>.</p>
</div>
<p>The body of the <code class="docutils literal notranslate"><span class="pre">greet(person:)</span></code> function starts by defining a new <code class="docutils literal notranslate"><span class="pre">String</span></code> constant called <code class="docutils literal notranslate"><span class="pre">greeting</span></code> and setting it to a simple greeting message. This greeting is then passed back out of the function using the <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword. In the line of code that says <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">greeting</span></code>, the function finishes its execution and returns the current value of <code class="docutils literal notranslate"><span class="pre">greeting</span></code>.</p>
<p>You can call the <code class="docutils literal notranslate"><span class="pre">greet(person:)</span></code> function multiple times with different input values. The example above shows what happens if it is called with an input value of <code class="docutils literal notranslate"><span class="pre">"Anna"</span></code>, and an input value of <code class="docutils literal notranslate"><span class="pre">"Brian"</span></code>. The function returns a tailored greeting in each case.</p>
<p>To make the body of this function shorter, you can combine the message creation and the return statement into one line:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">greetAgain</span>(<span class="nv">person</span>: <span class="nc">String</span>) -&gt; <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="s">"Hello again, "</span> + <span class="nv">person</span> + <span class="s">"!"</span>
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">greetAgain</span>(<span class="nv">person</span>: <span class="s">"Anna"</span>))
</li><li><span class="c">// Prints "Hello again, Anna!"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID160">
<h2>Function Parameters and Return Values<a class="headerlink" href="Functions.html#ID160" title="Permalink to this headline">¶</a></h2>
<p>Function parameters and return values are extremely flexible in Swift. You can define anything from a simple utility function with a single unnamed parameter to a complex function with expressive parameter names and different parameter options.</p>
<div class="section" id="ID162">
<h3>Functions Without Parameters<a class="headerlink" href="Functions.html#ID162" title="Permalink to this headline">¶</a></h3>
<p>Functions are not required to define input parameters. Here’s a function with no input parameters, which always returns the same <code class="docutils literal notranslate"><span class="pre">String</span></code> message whenever it is called:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">sayHelloWorld</span>() -&gt; <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="s">"hello, world"</span>
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">sayHelloWorld</span>())
</li><li><span class="c">// Prints "hello, world"</span>
</li></ol></div></div></div>
<p>The function definition still needs parentheses after the function’s name, even though it does not take any parameters. The function name is also followed by an empty pair of parentheses when the function is called.</p>
</div>
<div class="section" id="ID528">
<h3>Functions With Multiple Parameters<a class="headerlink" href="Functions.html#ID528" title="Permalink to this headline">¶</a></h3>
<p>Functions can have multiple input parameters, which are written within the function’s parentheses, separated by commas.</p>
<p>This function takes a person’s name and whether they have already been greeted as input, and returns an appropriate greeting for that person:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">greet</span>(<span class="nv">person</span>: <span class="nc">String</span>, <span class="nv">alreadyGreeted</span>: <span class="nc">Bool</span>) -&gt; <span class="nc">String</span> {
</li><li> <span class="k">if</span> <span class="nv">alreadyGreeted</span> {
</li><li> <span class="k">return</span> <span class="nv">greetAgain</span>(<span class="nv">person</span>: <span class="nv">person</span>)
</li><li>    } <span class="k">else</span> {
</li><li> <span class="k">return</span> <span class="nv">greet</span>(<span class="nv">person</span>: <span class="nv">person</span>)
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">greet</span>(<span class="nv">person</span>: <span class="s">"Tim"</span>, <span class="nv">alreadyGreeted</span>: <span class="k">true</span>))
</li><li><span class="c">// Prints "Hello again, Tim!"</span>
</li></ol></div></div></div>
<p>You call the <code class="docutils literal notranslate"><span class="pre">greet(person:alreadyGreeted:)</span></code> function by passing it both a <code class="docutils literal notranslate"><span class="pre">String</span></code> argument value labeled <code class="docutils literal notranslate"><span class="pre">person</span></code> and a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> argument value labeled <code class="docutils literal notranslate"><span class="pre">alreadyGreeted</span></code> in parentheses, separated by commas. Note that this function is distinct from the <code class="docutils literal notranslate"><span class="pre">greet(person:)</span></code> function shown in an earlier section. Although both functions have names that begin with <code class="docutils literal notranslate"><span class="pre">greet</span></code>, the <code class="docutils literal notranslate"><span class="pre">greet(person:alreadyGreeted:)</span></code> function takes two arguments but the <code class="docutils literal notranslate"><span class="pre">greet(person:)</span></code> function takes only one.</p>
</div>
<div class="section" id="ID163">
<h3>Functions Without Return Values<a class="headerlink" href="Functions.html#ID163" title="Permalink to this headline">¶</a></h3>
<p>Functions are not required to define a return type. Here’s a version of the <code class="docutils literal notranslate"><span class="pre">greet(person:)</span></code> function, which prints its own <code class="docutils literal notranslate"><span class="pre">String</span></code> value rather than returning it:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">greet</span>(<span class="nv">person</span>: <span class="nc">String</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Hello, </span>\<span class="p">(</span><span class="nv">person</span><span class="p">)</span><span class="s">!"</span>)
</li><li>}
</li><li><span class="nv">greet</span>(<span class="nv">person</span>: <span class="s">"Dave"</span>)
</li><li><span class="c">// Prints "Hello, Dave!"</span>
</li></ol></div></div></div>
<p>Because it does not need to return a value, the function’s definition does not include the return arrow (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>) or a return type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Strictly speaking, this version of the <code class="docutils literal notranslate"><span class="pre">greet(person:)</span></code> function <em>does</em> still return a value, even though no return value is defined. Functions without a defined return type return a special value of type <code class="docutils literal notranslate"><span class="pre">Void</span></code>. This is simply an empty tuple, which is written as <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</div>
<p>The return value of a function can be ignored when it is called:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">printAndCount</span>(<span class="nv">string</span>: <span class="nc">String</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="nv">print</span>(<span class="nv">string</span>)
</li><li> <span class="k">return</span> <span class="nv">string</span>.<span class="nv">count</span>
</li><li>}
</li><li><span class="k">func</span> <span class="nv">printWithoutCounting</span>(<span class="nv">string</span>: <span class="nc">String</span>) {
</li><li> <span class="k">let</span> <span class="k">_</span> = <span class="nv">printAndCount</span>(<span class="nv">string</span>: <span class="nv">string</span>)
</li><li>}
</li><li><span class="nv">printAndCount</span>(<span class="nv">string</span>: <span class="s">"hello, world"</span>)
</li><li><span class="c">// prints "hello, world" and returns a value of 12</span>
</li><li><span class="nv">printWithoutCounting</span>(<span class="nv">string</span>: <span class="s">"hello, world"</span>)
</li><li><span class="c">// prints "hello, world" but does not return a value</span>
</li></ol></div></div></div>
<p>The first function, <code class="docutils literal notranslate"><span class="pre">printAndCount(string:)</span></code>, prints a string, and then returns its character count as an <code class="docutils literal notranslate"><span class="pre">Int</span></code>. The second function, <code class="docutils literal notranslate"><span class="pre">printWithoutCounting(string:)</span></code>, calls the first function, but ignores its return value. When the second function is called, the message is still printed by the first function, but the returned value is not used.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Return values can be ignored, but a function that says it will return a value must always do so. A function with a defined return type cannot allow control to fall out of the bottom of the function without returning a value, and attempting to do so will result in a compile-time error.</p>
</div>
</div>
<div class="section" id="ID164">
<h3>Functions with Multiple Return Values<a class="headerlink" href="Functions.html#ID164" title="Permalink to this headline">¶</a></h3>
<p>You can use a tuple type as the return type for a function to return multiple values as part of one compound return value.</p>
<p>The example below defines a function called <code class="docutils literal notranslate"><span class="pre">minMax(array:)</span></code>, which finds the smallest and largest numbers in an array of <code class="docutils literal notranslate"><span class="pre">Int</span></code> values:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">minMax</span>(<span class="nv">array</span>: [<span class="nc">Int</span>]) -&gt; (<span class="nv">min</span>: <span class="nc">Int</span>, <span class="nv">max</span>: <span class="nc">Int</span>) {
</li><li> <span class="k">var</span> <span class="nv">currentMin</span> = <span class="nv">array</span>[<span class="m">0</span>]
</li><li> <span class="k">var</span> <span class="nv">currentMax</span> = <span class="nv">array</span>[<span class="m">0</span>]
</li><li> <span class="k">for</span> <span class="nv">value</span> <span class="k">in</span> <span class="nv">array</span>[<span class="m">1</span>..&lt;<span class="nv">array</span>.<span class="nv">count</span>] {
</li><li> <span class="k">if</span> <span class="nv">value</span> &lt; <span class="nv">currentMin</span> {
</li><li> <span class="nv">currentMin</span> = <span class="nv">value</span>
</li><li>        } <span class="k">else</span> <span class="k">if</span> <span class="nv">value</span> &gt; <span class="nv">currentMax</span> {
</li><li> <span class="nv">currentMax</span> = <span class="nv">value</span>
</li><li>        }
</li><li>    }
</li><li> <span class="k">return</span> (<span class="nv">currentMin</span>, <span class="nv">currentMax</span>)
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">minMax(array:)</span></code> function returns a tuple containing two <code class="docutils literal notranslate"><span class="pre">Int</span></code> values. These values are labeled <code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code> so that they can be accessed by name when querying the function’s return value.</p>
<p>The body of the <code class="docutils literal notranslate"><span class="pre">minMax(array:)</span></code> function starts by setting two working variables called <code class="docutils literal notranslate"><span class="pre">currentMin</span></code> and <code class="docutils literal notranslate"><span class="pre">currentMax</span></code> to the value of the first integer in the array. The function then iterates over the remaining values in the array and checks each value to see if it is smaller or larger than the values of <code class="docutils literal notranslate"><span class="pre">currentMin</span></code> and <code class="docutils literal notranslate"><span class="pre">currentMax</span></code> respectively. Finally, the overall minimum and maximum values are returned as a tuple of two <code class="docutils literal notranslate"><span class="pre">Int</span></code> values.</p>
<p>Because the tuple’s member values are named as part of the function’s return type, they can be accessed with dot syntax to retrieve the minimum and maximum found values:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">bounds</span> = <span class="nv">minMax</span>(<span class="nv">array</span>: [<span class="m">8</span>, <span class="m">-6</span>, <span class="m">2</span>, <span class="m">109</span>, <span class="m">3</span>, <span class="m">71</span>])
</li><li><span class="nv">print</span>(<span class="s">"min is </span>\<span class="p">(</span><span class="nv">bounds</span>.<span class="nv">min</span><span class="p">)</span><span class="s"> and max is </span>\<span class="p">(</span><span class="nv">bounds</span>.<span class="nv">max</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "min is -6 and max is 109"</span>
</li></ol></div></div></div>
<p>Note that the tuple’s members do not need to be named at the point that the tuple is returned from the function, because their names are already specified as part of the function’s return type.</p>
<div class="section" id="ID165">
<h4>Optional Tuple Return Types<a class="headerlink" href="Functions.html#ID165" title="Permalink to this headline">¶</a></h4>
<p>If the tuple type to be returned from a function has the potential to have “no value” for the entire tuple, you can use an <em>optional</em> tuple return type to reflect the fact that the entire tuple can be <code class="docutils literal notranslate"><span class="pre">nil</span></code>. You write an optional tuple return type by placing a question mark after the tuple type’s closing parenthesis, such as <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)?</span></code> or <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">Int,</span> <span class="pre">Bool)?</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An optional tuple type such as <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)?</span></code> is different from a tuple that contains optional types such as <code class="docutils literal notranslate"><span class="pre">(Int?,</span> <span class="pre">Int?)</span></code>. With an optional tuple type, the entire tuple is optional, not just each individual value within the tuple.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">minMax(array:)</span></code> function above returns a tuple containing two <code class="docutils literal notranslate"><span class="pre">Int</span></code> values. However, the function does not perform any safety checks on the array it is passed. If the <code class="docutils literal notranslate"><span class="pre">array</span></code> argument contains an empty array, the <code class="docutils literal notranslate"><span class="pre">minMax(array:)</span></code> function, as defined above, will trigger a runtime error when attempting to access <code class="docutils literal notranslate"><span class="pre">array[0]</span></code>.</p>
<p>To handle an empty array safely, write the <code class="docutils literal notranslate"><span class="pre">minMax(array:)</span></code> function with an optional tuple return type and return a value of <code class="docutils literal notranslate"><span class="pre">nil</span></code> when the array is empty:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">minMax</span>(<span class="nv">array</span>: [<span class="nc">Int</span>]) -&gt; (<span class="nv">min</span>: <span class="nc">Int</span>, <span class="nv">max</span>: <span class="nc">Int</span>)? {
</li><li> <span class="k">if</span> <span class="nv">array</span>.<span class="nv">isEmpty</span> { <span class="k">return</span> <span class="k">nil</span> }
</li><li> <span class="k">var</span> <span class="nv">currentMin</span> = <span class="nv">array</span>[<span class="m">0</span>]
</li><li> <span class="k">var</span> <span class="nv">currentMax</span> = <span class="nv">array</span>[<span class="m">0</span>]
</li><li> <span class="k">for</span> <span class="nv">value</span> <span class="k">in</span> <span class="nv">array</span>[<span class="m">1</span>..&lt;<span class="nv">array</span>.<span class="nv">count</span>] {
</li><li> <span class="k">if</span> <span class="nv">value</span> &lt; <span class="nv">currentMin</span> {
</li><li> <span class="nv">currentMin</span> = <span class="nv">value</span>
</li><li>        } <span class="k">else</span> <span class="k">if</span> <span class="nv">value</span> &gt; <span class="nv">currentMax</span> {
</li><li> <span class="nv">currentMax</span> = <span class="nv">value</span>
</li><li>        }
</li><li>    }
</li><li> <span class="k">return</span> (<span class="nv">currentMin</span>, <span class="nv">currentMax</span>)
</li><li>}
</li></ol></div></div></div>
<p>You can use optional binding to check whether this version of the <code class="docutils literal notranslate"><span class="pre">minMax(array:)</span></code> function returns an actual tuple value or <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">bounds</span> = <span class="nv">minMax</span>(<span class="nv">array</span>: [<span class="m">8</span>, <span class="m">-6</span>, <span class="m">2</span>, <span class="m">109</span>, <span class="m">3</span>, <span class="m">71</span>]) {
</li><li> <span class="nv">print</span>(<span class="s">"min is </span>\<span class="p">(</span><span class="nv">bounds</span>.<span class="nv">min</span><span class="p">)</span><span class="s"> and max is </span>\<span class="p">(</span><span class="nv">bounds</span>.<span class="nv">max</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Prints "min is -6 and max is 109"</span>
</li></ol></div></div></div>
</div>
</div>
</div>
<div class="section" id="ID166">
<h2>Function Argument Labels and Parameter Names<a class="headerlink" href="Functions.html#ID166" title="Permalink to this headline">¶</a></h2>
<p>Each function parameter has both an <em>argument label</em> and a <em>parameter name</em>. The argument label is used when calling the function; each argument is written in the function call with its argument label before it. The parameter name is used in the implementation of the function. By default, parameters use their parameter name as their argument label.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>(<span class="nv">firstParameterName</span>: <span class="nc">Int</span>, <span class="nv">secondParameterName</span>: <span class="nc">Int</span>) {
</li><li> <span class="c">// In the function body, firstParameterName and secondParameterName</span>
</li><li> <span class="c">// refer to the argument values for the first and second parameters.</span>
</li><li>}
</li><li><span class="nv">someFunction</span>(<span class="nv">firstParameterName</span>: <span class="m">1</span>, <span class="nv">secondParameterName</span>: <span class="m">2</span>)
</li></ol></div></div></div>
<p>All parameters must have unique names. Although it’s possible for multiple parameters to have the same argument label, unique argument labels help make your code more readable.</p>
<div class="section" id="ID167">
<h3>Specifying Argument Labels<a class="headerlink" href="Functions.html#ID167" title="Permalink to this headline">¶</a></h3>
<p>You write an argument label before the parameter name, separated by a space:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>(<span class="nv">argumentLabel</span> <span class="nv">parameterName</span>: <span class="nc">Int</span>) {
</li><li> <span class="c">// In the function body, parameterName refers to the argument value</span>
</li><li> <span class="c">// for that parameter.</span>
</li><li>}
</li></ol></div></div></div>
<p>Here’s a variation of the <code class="docutils literal notranslate"><span class="pre">greet(person:)</span></code> function that takes a person’s name and hometown and returns a greeting:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">greet</span>(<span class="nv">person</span>: <span class="nc">String</span>, <span class="nv">from</span> <span class="nv">hometown</span>: <span class="nc">String</span>) -&gt; <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="s">"Hello </span>\<span class="p">(</span><span class="nv">person</span><span class="p">)</span><span class="s">!  Glad you could visit from </span>\<span class="p">(</span><span class="nv">hometown</span><span class="p">)</span><span class="s">."</span>
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">greet</span>(<span class="nv">person</span>: <span class="s">"Bill"</span>, <span class="nv">from</span>: <span class="s">"Cupertino"</span>))
</li><li><span class="c">// Prints "Hello Bill!  Glad you could visit from Cupertino."</span>
</li></ol></div></div></div>
<p>The use of argument labels can allow a function to be called in an expressive, sentence-like manner, while still providing a function body that is readable and clear in intent.</p>
</div>
<div class="section" id="ID526">
<h3>Omitting Argument Labels<a class="headerlink" href="Functions.html#ID526" title="Permalink to this headline">¶</a></h3>
<p>If you don’t want an argument label for a parameter, write an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) instead of an explicit argument label for that parameter.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>(<span class="k">_</span> <span class="nv">firstParameterName</span>: <span class="nc">Int</span>, <span class="nv">secondParameterName</span>: <span class="nc">Int</span>) {
</li><li> <span class="c">// In the function body, firstParameterName and secondParameterName</span>
</li><li> <span class="c">// refer to the argument values for the first and second parameters.</span>
</li><li>}
</li><li><span class="nv">someFunction</span>(<span class="m">1</span>, <span class="nv">secondParameterName</span>: <span class="m">2</span>)
</li></ol></div></div></div>
<p>If a parameter has an argument label, the argument <em>must</em> be labeled when you call the function.</p>
</div>
<div class="section" id="ID169">
<h3>Default Parameter Values<a class="headerlink" href="Functions.html#ID169" title="Permalink to this headline">¶</a></h3>
<p>You can define a <em>default value</em> for any parameter in a function by assigning a value to the parameter after that parameter’s type. If a default value is defined, you can omit that parameter when calling the function.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>(<span class="nv">parameterWithoutDefault</span>: <span class="nc">Int</span>, <span class="nv">parameterWithDefault</span>: <span class="nc">Int</span> = <span class="m">12</span>) {
</li><li> <span class="c">// If you omit the second argument when calling this function, then</span>
</li><li> <span class="c">// the value of parameterWithDefault is 12 inside the function body.</span>
</li><li>}
</li><li><span class="nv">someFunction</span>(<span class="nv">parameterWithoutDefault</span>: <span class="m">3</span>, <span class="nv">parameterWithDefault</span>: <span class="m">6</span>) <span class="c">// parameterWithDefault is 6</span>
</li><li><span class="nv">someFunction</span>(<span class="nv">parameterWithoutDefault</span>: <span class="m">4</span>) <span class="c">// parameterWithDefault is 12</span>
</li></ol></div></div></div>
<p>Place parameters that don’t have default values at the beginning of a function’s parameter list, before the parameters that have default values. Parameters that don’t have default values are usually more important to the function’s meaning—writing them first makes it easier to recognize that the same function is being called, regardless of whether any default parameters are omitted.</p>
</div>
<div class="section" id="ID171">
<h3>Variadic Parameters<a class="headerlink" href="Functions.html#ID171" title="Permalink to this headline">¶</a></h3>
<p>A <em>variadic parameter</em> accepts zero or more values of a specified type. You use a variadic parameter to specify that the parameter can be passed a varying number of input values when the function is called. Write variadic parameters by inserting three period characters (<code class="docutils literal notranslate"><span class="pre">...</span></code>) after the parameter’s type name.</p>
<p>The values passed to a variadic parameter are made available within the function’s body as an array of the appropriate type. For example, a variadic parameter with a name of <code class="docutils literal notranslate"><span class="pre">numbers</span></code> and a type of <code class="docutils literal notranslate"><span class="pre">Double...</span></code> is made available within the function’s body as a constant array called <code class="docutils literal notranslate"><span class="pre">numbers</span></code> of type <code class="docutils literal notranslate"><span class="pre">[Double]</span></code>.</p>
<p>The example below calculates the <em>arithmetic mean</em> (also known as the <em>average</em>) for a list of numbers of any length:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">arithmeticMean</span>(<span class="k">_</span> <span class="nv">numbers</span>: <span class="nc">Double</span>...) -&gt; <span class="nc">Double</span> {
</li><li> <span class="k">var</span> <span class="nv">total</span>: <span class="nc">Double</span> = <span class="m">0</span>
</li><li> <span class="k">for</span> <span class="nv">number</span> <span class="k">in</span> <span class="nv">numbers</span> {
</li><li> <span class="nv">total</span> += <span class="nv">number</span>
</li><li>    }
</li><li> <span class="k">return</span> <span class="nv">total</span> / <span class="nv">Double</span>(<span class="nv">numbers</span>.<span class="nv">count</span>)
</li><li>}
</li><li><span class="nv">arithmeticMean</span>(<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>, <span class="m">4</span>, <span class="m">5</span>)
</li><li><span class="c">// returns 3.0, which is the arithmetic mean of these five numbers</span>
</li><li><span class="nv">arithmeticMean</span>(<span class="m">3</span>, <span class="m">8.25</span>, <span class="m">18.75</span>)
</li><li><span class="c">// returns 10.0, which is the arithmetic mean of these three numbers</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A function may have at most one variadic parameter.</p>
</div>
</div>
<div class="section" id="ID173">
<h3>In-Out Parameters<a class="headerlink" href="Functions.html#ID173" title="Permalink to this headline">¶</a></h3>
<p>Function parameters are constants by default. Trying to change the value of a function parameter from within the body of that function results in a compile-time error. This means that you can’t change the value of a parameter by mistake. If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an <em>in-out parameter</em> instead.</p>
<p>You write an in-out parameter by placing the <code class="docutils literal notranslate"><span class="pre">inout</span></code> keyword right before a parameter’s type. An in-out parameter has a value that is passed <em>in</em> to the function, is modified by the function, and is passed back <em>out</em> of the function to replace the original value. For a detailed discussion of the behavior of in-out parameters and associated compiler optimizations, see <a class="reference internal" href="../ReferenceManual/Declarations.html#ID545"><span class="std std-ref">In-Out Parameters</span></a>.</p>
<p>You can only pass a variable as the argument for an in-out parameter. You cannot pass a constant or a literal value as the argument, because constants and literals cannot be modified. You place an ampersand (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) directly before a variable’s name when you pass it as an argument to an in-out parameter, to indicate that it can be modified by the function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In-out parameters cannot have default values, and variadic parameters cannot be marked as <code class="docutils literal notranslate"><span class="pre">inout</span></code>.</p>
</div>
<p>Here’s an example of a function called <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code>, which has two in-out integer parameters called <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">swapTwoInts</span>(<span class="k">_</span> <span class="nv">a</span>: <span class="k">inout</span> <span class="nc">Int</span>, <span class="k">_</span> <span class="nv">b</span>: <span class="k">inout</span> <span class="nc">Int</span>) {
</li><li> <span class="k">let</span> <span class="nv">temporaryA</span> = <span class="nv">a</span>
</li><li> <span class="nv">a</span> = <span class="nv">b</span>
</li><li> <span class="nv">b</span> = <span class="nv">temporaryA</span>
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code> function simply swaps the value of <code class="docutils literal notranslate"><span class="pre">b</span></code> into <code class="docutils literal notranslate"><span class="pre">a</span></code>, and the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> into <code class="docutils literal notranslate"><span class="pre">b</span></code>. The function performs this swap by storing the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> in a temporary constant called <code class="docutils literal notranslate"><span class="pre">temporaryA</span></code>, assigning the value of <code class="docutils literal notranslate"><span class="pre">b</span></code> to <code class="docutils literal notranslate"><span class="pre">a</span></code>, and then assigning <code class="docutils literal notranslate"><span class="pre">temporaryA</span></code> to <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>You can call the <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code> function with two variables of type <code class="docutils literal notranslate"><span class="pre">Int</span></code> to swap their values. Note that the names of <code class="docutils literal notranslate"><span class="pre">someInt</span></code> and <code class="docutils literal notranslate"><span class="pre">anotherInt</span></code> are prefixed with an ampersand when they are passed to the <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code> function:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">someInt</span> = <span class="m">3</span>
</li><li><span class="k">var</span> <span class="nv">anotherInt</span> = <span class="m">107</span>
</li><li><span class="nv">swapTwoInts</span>(&amp;<span class="nv">someInt</span>, &amp;<span class="nv">anotherInt</span>)
</li><li><span class="nv">print</span>(<span class="s">"someInt is now </span>\<span class="p">(</span><span class="nv">someInt</span><span class="p">)</span><span class="s">, and anotherInt is now </span>\<span class="p">(</span><span class="nv">anotherInt</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "someInt is now 107, and anotherInt is now 3"</span>
</li></ol></div></div></div>
<p>The example above shows that the original values of <code class="docutils literal notranslate"><span class="pre">someInt</span></code> and <code class="docutils literal notranslate"><span class="pre">anotherInt</span></code> are modified by the <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code> function, even though they were originally defined outside of the function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In-out parameters are not the same as returning a value from a function. The <code class="docutils literal notranslate"><span class="pre">swapTwoInts</span></code> example above does not define a return type or return a value, but it still modifies the values of <code class="docutils literal notranslate"><span class="pre">someInt</span></code> and <code class="docutils literal notranslate"><span class="pre">anotherInt</span></code>. In-out parameters are an alternative way for a function to have an effect outside of the scope of its function body.</p>
</div>
</div>
</div>
<div class="section" id="ID174">
<h2>Function Types<a class="headerlink" href="Functions.html#ID174" title="Permalink to this headline">¶</a></h2>
<p>Every function has a specific <em>function type</em>, made up of the parameter types and the return type of the function.</p>
<p>For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">addTwoInts</span>(<span class="k">_</span> <span class="nv">a</span>: <span class="nc">Int</span>, <span class="k">_</span> <span class="nv">b</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">a</span> + <span class="nv">b</span>
</li><li>}
</li><li><span class="k">func</span> <span class="nv">multiplyTwoInts</span>(<span class="k">_</span> <span class="nv">a</span>: <span class="nc">Int</span>, <span class="k">_</span> <span class="nv">b</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">a</span> * <span class="nv">b</span>
</li><li>}
</li></ol></div></div></div>
<p>This example defines two simple mathematical functions called <code class="docutils literal notranslate"><span class="pre">addTwoInts</span></code> and <code class="docutils literal notranslate"><span class="pre">multiplyTwoInts</span></code>. These functions each take two <code class="docutils literal notranslate"><span class="pre">Int</span></code> values, and return an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value, which is the result of performing an appropriate mathematical operation.</p>
<p>The type of both of these functions is <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>. This can be read as:</p>
<p>“A function that has two parameters, both of type <code class="docutils literal notranslate"><span class="pre">Int</span></code>, and that returns a value of type <code class="docutils literal notranslate"><span class="pre">Int</span></code>.”</p>
<p>Here’s another example, for a function with no parameters or return value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">printHelloWorld</span>() {
</li><li> <span class="nv">print</span>(<span class="s">"hello, world"</span>)
</li><li>}
</li></ol></div></div></div>
<p>The type of this function is <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code>, or “a function that has no parameters, and returns <code class="docutils literal notranslate"><span class="pre">Void</span></code>.”</p>
<div class="section" id="ID175">
<h3>Using Function Types<a class="headerlink" href="Functions.html#ID175" title="Permalink to this headline">¶</a></h3>
<p>You use function types just like any other types in Swift. For example, you can define a constant or variable to be of a function type and assign an appropriate function to that variable:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">mathFunction</span>: (<span class="nc">Int</span>, <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> = <span class="nv">addTwoInts</span>
</li></ol></div></div></div>
<p>This can be read as:</p>
<p>“Define a variable called <code class="docutils literal notranslate"><span class="pre">mathFunction</span></code>, which has a type of ‘a function that takes two <code class="docutils literal notranslate"><span class="pre">Int</span></code> values, and returns an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value.’ Set this new variable to refer to the function called <code class="docutils literal notranslate"><span class="pre">addTwoInts</span></code>.”</p>
<p>The <code class="docutils literal notranslate"><span class="pre">addTwoInts(_:_:)</span></code> function has the same type as the <code class="docutils literal notranslate"><span class="pre">mathFunction</span></code> variable, and so this assignment is allowed by Swift’s type-checker.</p>
<p>You can now call the assigned function with the name <code class="docutils literal notranslate"><span class="pre">mathFunction</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"Result: </span>\<span class="p">(</span><span class="nv">mathFunction</span>(<span class="m">2</span>, <span class="m">3</span>)<span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "Result: 5"</span>
</li></ol></div></div></div>
<p>A different function with the same matching type can be assigned to the same variable, in the same way as for nonfunction types:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">mathFunction</span> = <span class="nv">multiplyTwoInts</span>
</li><li><span class="nv">print</span>(<span class="s">"Result: </span>\<span class="p">(</span><span class="nv">mathFunction</span>(<span class="m">2</span>, <span class="m">3</span>)<span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "Result: 6"</span>
</li></ol></div></div></div>
<p>As with any other type, you can leave it to Swift to infer the function type when you assign a function to a constant or variable:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">anotherMathFunction</span> = <span class="nv">addTwoInts</span>
</li><li><span class="c">// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID176">
<h3>Function Types as Parameter Types<a class="headerlink" href="Functions.html#ID176" title="Permalink to this headline">¶</a></h3>
<p>You can use a function type such as <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> as a parameter type for another function. This enables you to leave some aspects of a function’s implementation for the function’s caller to provide when the function is called.</p>
<p>Here’s an example to print the results of the math functions from above:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">printMathResult</span>(<span class="k">_</span> <span class="nv">mathFunction</span>: (<span class="nc">Int</span>, <span class="nc">Int</span>) -&gt; <span class="nc">Int</span>, <span class="k">_</span> <span class="nv">a</span>: <span class="nc">Int</span>, <span class="k">_</span> <span class="nv">b</span>: <span class="nc">Int</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Result: </span>\<span class="p">(</span><span class="nv">mathFunction</span>(<span class="nv">a</span>, <span class="nv">b</span>)<span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="nv">printMathResult</span>(<span class="nv">addTwoInts</span>, <span class="m">3</span>, <span class="m">5</span>)
</li><li><span class="c">// Prints "Result: 8"</span>
</li></ol></div></div></div>
<p>This example defines a function called <code class="docutils literal notranslate"><span class="pre">printMathResult(_:_:_:)</span></code>, which has three parameters. The first parameter is called <code class="docutils literal notranslate"><span class="pre">mathFunction</span></code>, and is of type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>. You can pass any function of that type as the argument for this first parameter. The second and third parameters are called <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, and are both of type <code class="docutils literal notranslate"><span class="pre">Int</span></code>. These are used as the two input values for the provided math function.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">printMathResult(_:_:_:)</span></code> is called, it is passed the <code class="docutils literal notranslate"><span class="pre">addTwoInts(_:_:)</span></code> function, and the integer values <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code>. It calls the provided function with the values <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code>, and prints the result of <code class="docutils literal notranslate"><span class="pre">8</span></code>.</p>
<p>The role of <code class="docutils literal notranslate"><span class="pre">printMathResult(_:_:_:)</span></code> is to print the result of a call to a math function of an appropriate type. It doesn’t matter what that function’s implementation actually does—it matters only that the function is of the correct type. This enables <code class="docutils literal notranslate"><span class="pre">printMathResult(_:_:_:)</span></code> to hand off some of its functionality to the caller of the function in a type-safe way.</p>
</div>
<div class="section" id="ID177">
<h3>Function Types as Return Types<a class="headerlink" href="Functions.html#ID177" title="Permalink to this headline">¶</a></h3>
<p>You can use a function type as the return type of another function. You do this by writing a complete function type immediately after the return arrow (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>) of the returning function.</p>
<p>The next example defines two simple functions called <code class="docutils literal notranslate"><span class="pre">stepForward(_:)</span></code> and <code class="docutils literal notranslate"><span class="pre">stepBackward(_:)</span></code>. The <code class="docutils literal notranslate"><span class="pre">stepForward(_:)</span></code> function returns a value one more than its input value, and the <code class="docutils literal notranslate"><span class="pre">stepBackward(_:)</span></code> function returns a value one less than its input value. Both functions have a type of <code class="docutils literal notranslate"><span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">stepForward</span>(<span class="k">_</span> <span class="nv">input</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">input</span> + <span class="m">1</span>
</li><li>}
</li><li><span class="k">func</span> <span class="nv">stepBackward</span>(<span class="k">_</span> <span class="nv">input</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">input</span> - <span class="m">1</span>
</li><li>}
</li></ol></div></div></div>
<p>Here’s a function called <code class="docutils literal notranslate"><span class="pre">chooseStepFunction(backward:)</span></code>, whose return type is <code class="docutils literal notranslate"><span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>. The <code class="docutils literal notranslate"><span class="pre">chooseStepFunction(backward:)</span></code> function returns the <code class="docutils literal notranslate"><span class="pre">stepForward(_:)</span></code> function or the <code class="docutils literal notranslate"><span class="pre">stepBackward(_:)</span></code> function based on a Boolean parameter called <code class="docutils literal notranslate"><span class="pre">backward</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">chooseStepFunction</span>(<span class="nv">backward</span>: <span class="nc">Bool</span>) -&gt; (<span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">backward</span> ? <span class="nv">stepBackward</span> : <span class="nv">stepForward</span>
</li><li>}
</li></ol></div></div></div>
<p>You can now use <code class="docutils literal notranslate"><span class="pre">chooseStepFunction(backward:)</span></code> to obtain a function that will step in one direction or the other:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">currentValue</span> = <span class="m">3</span>
</li><li><span class="k">let</span> <span class="nv">moveNearerToZero</span> = <span class="nv">chooseStepFunction</span>(<span class="nv">backward</span>: <span class="nv">currentValue</span> &gt; <span class="m">0</span>)
</li><li><span class="c">// moveNearerToZero now refers to the stepBackward() function</span>
</li></ol></div></div></div>
<p>The example above determines whether a positive or negative step is needed to move a variable called <code class="docutils literal notranslate"><span class="pre">currentValue</span></code> progressively closer to zero. <code class="docutils literal notranslate"><span class="pre">currentValue</span></code> has an initial value of <code class="docutils literal notranslate"><span class="pre">3</span></code>, which means that <code class="docutils literal notranslate"><span class="pre">currentValue</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code>, causing <code class="docutils literal notranslate"><span class="pre">chooseStepFunction(backward:)</span></code> to return the <code class="docutils literal notranslate"><span class="pre">stepBackward(_:)</span></code> function. A reference to the returned function is stored in a constant called <code class="docutils literal notranslate"><span class="pre">moveNearerToZero</span></code>.</p>
<p>Now that <code class="docutils literal notranslate"><span class="pre">moveNearerToZero</span></code> refers to the correct function, it can be used to count to zero:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"Counting to zero:"</span>)
</li><li><span class="c">// Counting to zero:</span>
</li><li><span class="k">while</span> <span class="nv">currentValue</span> != <span class="m">0</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">currentValue</span><span class="p">)</span><span class="s">... "</span>)
</li><li> <span class="nv">currentValue</span> = <span class="nv">moveNearerToZero</span>(<span class="nv">currentValue</span>)
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">"zero!"</span>)
</li><li><span class="c">// 3...</span>
</li><li><span class="c">// 2...</span>
</li><li><span class="c">// 1...</span>
</li><li><span class="c">// zero!</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID178">
<h2>Nested Functions<a class="headerlink" href="Functions.html#ID178" title="Permalink to this headline">¶</a></h2>
<p>All of the functions you have encountered so far in this chapter have been examples of <em>global functions</em>, which are defined at a global scope. You can also define functions inside the bodies of other functions, known as <em>nested functions</em>.</p>
<p>Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function. An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope.</p>
<p>You can rewrite the <code class="docutils literal notranslate"><span class="pre">chooseStepFunction(backward:)</span></code> example above to use and return nested functions:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">chooseStepFunction</span>(<span class="nv">backward</span>: <span class="nc">Bool</span>) -&gt; (<span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">func</span> <span class="nv">stepForward</span>(<span class="nv">input</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> { <span class="k">return</span> <span class="nv">input</span> + <span class="m">1</span> }
</li><li> <span class="k">func</span> <span class="nv">stepBackward</span>(<span class="nv">input</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> { <span class="k">return</span> <span class="nv">input</span> - <span class="m">1</span> }
</li><li> <span class="k">return</span> <span class="nv">backward</span> ? <span class="nv">stepBackward</span> : <span class="nv">stepForward</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">currentValue</span> = <span class="m">-4</span>
</li><li><span class="k">let</span> <span class="nv">moveNearerToZero</span> = <span class="nv">chooseStepFunction</span>(<span class="nv">backward</span>: <span class="nv">currentValue</span> &gt; <span class="m">0</span>)
</li><li><span class="c">// moveNearerToZero now refers to the nested stepForward() function</span>
</li><li><span class="k">while</span> <span class="nv">currentValue</span> != <span class="m">0</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">currentValue</span><span class="p">)</span><span class="s">... "</span>)
</li><li> <span class="nv">currentValue</span> = <span class="nv">moveNearerToZero</span>(<span class="nv">currentValue</span>)
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">"zero!"</span>)
</li><li><span class="c">// -4...</span>
</li><li><span class="c">// -3...</span>
</li><li><span class="c">// -2...</span>
</li><li><span class="c">// -1...</span>
</li><li><span class="c">// zero!</span>
</li></ol></div></div></div>
</div>
</div><div class="section" id="closures">
<h1>Closures<a class="headerlink" href="Closures.html#closures" title="Permalink to this headline">¶</a></h1>
<p><em>Closures</em> are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.</p>
<p>Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as <em>closing over</em> those constants and variables. Swift handles all of the memory management of capturing for you.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Don’t worry if you are not familiar with the concept of capturing. It is explained in detail below in <a class="reference internal" href="Closures.html#ID103"><span class="std std-ref">Capturing Values</span></a>.</p>
</div>
<p>Global and nested functions, as introduced in <a class="reference internal" href="Functions.html"><span class="doc">Functions</span></a>, are actually special cases of closures. Closures take one of three forms:</p>
<ul class="simple">
<li>Global functions are closures that have a name and do not capture any values.</li>
<li>Nested functions are closures that have a name and can capture values from their enclosing function.</li>
<li>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</li>
</ul>
<p>Swift’s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios. These optimizations include:</p>
<ul class="simple">
<li>Inferring parameter and return value types from context</li>
<li>Implicit returns from single-expression closures</li>
<li>Shorthand argument names</li>
<li>Trailing closure syntax</li>
</ul>
<div class="section" id="ID95">
<h2>Closure Expressions<a class="headerlink" href="Closures.html#ID95" title="Permalink to this headline">¶</a></h2>
<p>Nested functions, as introduced in <a class="reference internal" href="Functions.html#ID178"><span class="std std-ref">Nested Functions</span></a>, are a convenient means of naming and defining self-contained blocks of code as part of a larger function. However, it is sometimes useful to write shorter versions of function-like constructs without a full declaration and name. This is particularly true when you work with functions or methods that take functions as one or more of their arguments.</p>
<p><em>Closure expressions</em> are a way to write inline closures in a brief, focused syntax. Closure expressions provide several syntax optimizations for writing closures in a shortened form without loss of clarity or intent. The closure expression examples below illustrate these optimizations by refining a single example of the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method over several iterations, each of which expresses the same functionality in a more succinct way.</p>
<div class="section" id="ID96">
<h3>The Sorted Method<a class="headerlink" href="Closures.html#ID96" title="Permalink to this headline">¶</a></h3>
<p>Swift’s standard library provides a method called <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>, which sorts an array of values of a known type, based on the output of a sorting closure that you provide. Once it completes the sorting process, the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method returns a new array of the same type and size as the old one, with its elements in the correct sorted order. The original array is not modified by the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method.</p>
<p>The closure expression examples below use the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method to sort an array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values in reverse alphabetical order. Here’s the initial array to be sorted:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">names</span> = [<span class="s">"Chris"</span>, <span class="s">"Alex"</span>, <span class="s">"Ewa"</span>, <span class="s">"Barry"</span>, <span class="s">"Daniella"</span>]
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method accepts a closure that takes two arguments of the same type as the array’s contents, and returns a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value to say whether the first value should appear before or after the second value once the values are sorted. The sorting closure needs to return <code class="docutils literal notranslate"><span class="pre">true</span></code> if the first value should appear <em>before</em> the second value, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<p>This example is sorting an array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values, and so the sorting closure needs to be a function of type <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>.</p>
<p>One way to provide the sorting closure is to write a normal function of the correct type, and to pass it in as an argument to the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">backward</span>(<span class="k">_</span> <span class="nv">s1</span>: <span class="nc">String</span>, <span class="k">_</span> <span class="nv">s2</span>: <span class="nc">String</span>) -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">return</span> <span class="nv">s1</span> &gt; <span class="nv">s2</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: <span class="nv">backward</span>)
</li><li><span class="c">// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span>
</li></ol></div></div></div>
<p>If the first string (<code class="docutils literal notranslate"><span class="pre">s1</span></code>) is greater than the second string (<code class="docutils literal notranslate"><span class="pre">s2</span></code>), the <code class="docutils literal notranslate"><span class="pre">backward(_:_:)</span></code> function will return <code class="docutils literal notranslate"><span class="pre">true</span></code>, indicating that <code class="docutils literal notranslate"><span class="pre">s1</span></code> should appear before <code class="docutils literal notranslate"><span class="pre">s2</span></code> in the sorted array. For characters in strings, “greater than” means “appears later in the alphabet than”. This means that the letter <code class="docutils literal notranslate"><span class="pre">"B"</span></code> is “greater than” the letter <code class="docutils literal notranslate"><span class="pre">"A"</span></code>, and the string <code class="docutils literal notranslate"><span class="pre">"Tom"</span></code> is greater than the string <code class="docutils literal notranslate"><span class="pre">"Tim"</span></code>. This gives a reverse alphabetical sort, with <code class="docutils literal notranslate"><span class="pre">"Barry"</span></code> being placed before <code class="docutils literal notranslate"><span class="pre">"Alex"</span></code>, and so on.</p>
<p>However, this is a rather long-winded way to write what is essentially a single-expression function (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code>). In this example, it would be preferable to write the sorting closure inline, using closure expression syntax.</p>
</div>
<div class="section" id="ID97">
<h3>Closure Expression Syntax<a class="headerlink" href="Closures.html#ID97" title="Permalink to this headline">¶</a></h3>
<p>Closure expression syntax has the following general form:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>{ (<span class="gi">parameters</span>) -&gt; <span class="gi">return type</span> <span class="k">in</span>
</li><li> <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>The <em>parameters</em> in closure expression syntax can be in-out parameters, but they can’t have a default value. Variadic parameters can be used if you name the variadic parameter. Tuples can also be used as parameter types and return types.</p>
<p>The example below shows a closure expression version of the <code class="docutils literal notranslate"><span class="pre">backward(_:_:)</span></code> function from above:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: { (<span class="nv">s1</span>: <span class="nc">String</span>, <span class="nv">s2</span>: <span class="nc">String</span>) -&gt; <span class="nc">Bool</span> <span class="k">in</span>
</li><li> <span class="k">return</span> <span class="nv">s1</span> &gt; <span class="nv">s2</span>
</li><li>})
</li></ol></div></div></div>
<p>Note that the declaration of parameters and return type for this inline closure is identical to the declaration from the <code class="docutils literal notranslate"><span class="pre">backward(_:_:)</span></code> function. In both cases, it is written as <code class="docutils literal notranslate"><span class="pre">(s1:</span> <span class="pre">String,</span> <span class="pre">s2:</span> <span class="pre">String)</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>. However, for the inline closure expression, the parameters and return type are written <em>inside</em> the curly braces, not outside of them.</p>
<p>The start of the closure’s body is introduced by the <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword. This keyword indicates that the definition of the closure’s parameters and return type has finished, and the body of the closure is about to begin.</p>
<p>Because the body of the closure is so short, it can even be written on a single line:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: { (<span class="nv">s1</span>: <span class="nc">String</span>, <span class="nv">s2</span>: <span class="nc">String</span>) -&gt; <span class="nc">Bool</span> <span class="k">in</span> <span class="k">return</span> <span class="nv">s1</span> &gt; <span class="nv">s2</span> } )
</li></ol></div></div></div>
<p>This illustrates that the overall call to the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method has remained the same. A pair of parentheses still wrap the entire argument for the method. However, that argument is now an inline closure.</p>
</div>
<div class="section" id="ID98">
<h3>Inferring Type From Context<a class="headerlink" href="Closures.html#ID98" title="Permalink to this headline">¶</a></h3>
<p>Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns. The <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method is being called on an array of strings, so its argument must be a function of type <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>. This means that the <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span></code> and <code class="docutils literal notranslate"><span class="pre">Bool</span></code> types do not need to be written as part of the closure expression’s definition. Because all of the types can be inferred, the return arrow (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>) and the parentheses around the names of the parameters can also be omitted:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: { <span class="nv">s1</span>, <span class="nv">s2</span> <span class="k">in</span> <span class="k">return</span> <span class="nv">s1</span> &gt; <span class="nv">s2</span> } )
</li></ol></div></div></div>
<p>It is always possible to infer the parameter types and return type when passing a closure to a function or method as an inline closure expression. As a result, you never need to write an inline closure in its fullest form when the closure is used as a function or method argument.</p>
<p>Nonetheless, you can still make the types explicit if you wish, and doing so is encouraged if it avoids ambiguity for readers of your code. In the case of the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method, the purpose of the closure is clear from the fact that sorting is taking place, and it is safe for a reader to assume that the closure is likely to be working with <code class="docutils literal notranslate"><span class="pre">String</span></code> values, because it is assisting with the sorting of an array of strings.</p>
</div>
<div class="section" id="ID99">
<h3>Implicit Returns from Single-Expression Closures<a class="headerlink" href="Closures.html#ID99" title="Permalink to this headline">¶</a></h3>
<p>Single-expression closures can implicitly return the result of their single expression by omitting the <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword from their declaration, as in this version of the previous example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: { <span class="nv">s1</span>, <span class="nv">s2</span> <span class="k">in</span> <span class="nv">s1</span> &gt; <span class="nv">s2</span> } )
</li></ol></div></div></div>
<p>Here, the function type of the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method’s argument makes it clear that a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value must be returned by the closure. Because the closure’s body contains a single expression (<code class="docutils literal notranslate"><span class="pre">s1</span> <span class="pre">&gt;</span> <span class="pre">s2</span></code>) that returns a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value, there is no ambiguity, and the <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword can be omitted.</p>
</div>
<div class="section" id="ID100">
<h3>Shorthand Argument Names<a class="headerlink" href="Closures.html#ID100" title="Permalink to this headline">¶</a></h3>
<p>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names <code class="docutils literal notranslate"><span class="pre">$0</span></code>, <code class="docutils literal notranslate"><span class="pre">$1</span></code>, <code class="docutils literal notranslate"><span class="pre">$2</span></code>, and so on.</p>
<p>If you use these shorthand argument names within your closure expression, you can omit the closure’s argument list from its definition, and the number and type of the shorthand argument names will be inferred from the expected function type. The <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword can also be omitted, because the closure expression is made up entirely of its body:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: { <span class="nv">$0</span> &gt; <span class="nv">$1</span> } )
</li></ol></div></div></div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">$0</span></code> and <code class="docutils literal notranslate"><span class="pre">$1</span></code> refer to the closure’s first and second <code class="docutils literal notranslate"><span class="pre">String</span></code> arguments.</p>
</div>
<div class="section" id="ID101">
<h3>Operator Methods<a class="headerlink" href="Closures.html#ID101" title="Permalink to this headline">¶</a></h3>
<p>There’s actually an even <em>shorter</em> way to write the closure expression above. Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> type defines its string-specific implementation of the greater-than operator (<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>) as a method that has two parameters of type <code class="docutils literal notranslate"><span class="pre">String</span></code>, and returns a value of type <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. This exactly matches the method type needed by the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method. Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: &gt;)
</li></ol></div></div></div>
<p>For more about operator method, see <a class="reference internal" href="AdvancedOperators.html#ID42"><span class="std std-ref">Operator Methods</span></a>.</p>
</div>
</div>
<div class="section" id="ID102">
<h2>Trailing Closures<a class="headerlink" href="Closures.html#ID102" title="Permalink to this headline">¶</a></h2>
<p>If you need to pass a closure expression to a function as the function’s final argument and the closure expression is long, it can be useful to write it as a <em>trailing closure</em> instead. A trailing closure is written after the function call’s parentheses, even though it is still an argument to the function. When you use the trailing closure syntax, you don’t write the argument label for the closure as part of the function call.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunctionThatTakesAClosure</span>(<span class="nv">closure</span>: () -&gt; <span class="nc">Void</span>) {
</li><li> <span class="c">// function body goes here</span>
</li><li>}
</li><li>
</li><li><span class="c">// Here's how you call this function without using a trailing closure:</span>
</li><li>
</li><li><span class="nv">someFunctionThatTakesAClosure</span>(<span class="nv">closure</span>: {
</li><li> <span class="c">// closure's body goes here</span>
</li><li>})
</li><li>
</li><li><span class="c">// Here's how you call this function with a trailing closure instead:</span>
</li><li>
</li><li><span class="nv">someFunctionThatTakesAClosure</span>() {
</li><li> <span class="c">// trailing closure's body goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>The string-sorting closure from the <a class="reference internal" href="Closures.html#ID97"><span class="std std-ref">Closure Expression Syntax</span></a> section above can be written outside of the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method’s parentheses as a trailing closure:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>() { <span class="nv">$0</span> &gt; <span class="nv">$1</span> }
</li></ol></div></div></div>
<p>If a closure expression is provided as the function or method’s only argument and you provide that expression as a trailing closure, you do not need to write a pair of parentheses <code class="docutils literal notranslate"><span class="pre">()</span></code> after the function or method’s name when you call the function:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span> { <span class="nv">$0</span> &gt; <span class="nv">$1</span> }
</li></ol></div></div></div>
<p>Trailing closures are most useful when the closure is sufficiently long that it is not possible to write it inline on a single line. As an example, Swift’s <code class="docutils literal notranslate"><span class="pre">Array</span></code> type has a <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method which takes a closure expression as its single argument. The closure is called once for each item in the array, and returns an alternative mapped value (possibly of some other type) for that item. The nature of the mapping and the type of the returned value is left up to the closure to specify.</p>
<p>After applying the provided closure to each array element, the <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method returns a new array containing all of the new mapped values, in the same order as their corresponding values in the original array.</p>
<p>Here’s how you can use the <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method with a trailing closure to convert an array of <code class="docutils literal notranslate"><span class="pre">Int</span></code> values into an array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values. The array <code class="docutils literal notranslate"><span class="pre">[16,</span> <span class="pre">58,</span> <span class="pre">510]</span></code> is used to create the new array <code class="docutils literal notranslate"><span class="pre">["OneSix",</span> <span class="pre">"FiveEight",</span> <span class="pre">"FiveOneZero"]</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">digitNames</span> = [
</li><li> <span class="m">0</span>: <span class="s">"Zero"</span>, <span class="m">1</span>: <span class="s">"One"</span>, <span class="m">2</span>: <span class="s">"Two"</span>,   <span class="m">3</span>: <span class="s">"Three"</span>, <span class="m">4</span>: <span class="s">"Four"</span>,
</li><li> <span class="m">5</span>: <span class="s">"Five"</span>, <span class="m">6</span>: <span class="s">"Six"</span>, <span class="m">7</span>: <span class="s">"Seven"</span>, <span class="m">8</span>: <span class="s">"Eight"</span>, <span class="m">9</span>: <span class="s">"Nine"</span>
</li><li>]
</li><li><span class="k">let</span> <span class="nv">numbers</span> = [<span class="m">16</span>, <span class="m">58</span>, <span class="m">510</span>]
</li></ol></div></div></div>
<p>The code above creates a dictionary of mappings between the integer digits and English-language versions of their names. It also defines an array of integers, ready to be converted into strings.</p>
<p>You can now use the <code class="docutils literal notranslate"><span class="pre">numbers</span></code> array to create an array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values, by passing a closure expression to the array’s <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method as a trailing closure:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">strings</span> = <span class="nv">numbers</span>.<span class="nv">map</span> { (<span class="nv">number</span>) -&gt; <span class="nc">String</span> <span class="k">in</span>
</li><li> <span class="k">var</span> <span class="nv">number</span> = <span class="nv">number</span>
</li><li> <span class="k">var</span> <span class="nv">output</span> = <span class="s">""</span>
</li><li> <span class="k">repeat</span> {
</li><li> <span class="nv">output</span> = <span class="nv">digitNames</span>[<span class="nv">number</span> % <span class="m">10</span>]! + <span class="nv">output</span>
</li><li> <span class="nv">number</span> /= <span class="m">10</span>
</li><li>    } <span class="k">while</span> <span class="nv">number</span> &gt; <span class="m">0</span>
</li><li> <span class="k">return</span> <span class="nv">output</span>
</li><li>}
</li><li><span class="c">// strings is inferred to be of type [String]</span>
</li><li><span class="c">// its value is ["OneSix", "FiveEight", "FiveOneZero"]</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method calls the closure expression once for each item in the array. You do not need to specify the type of the closure’s input parameter, <code class="docutils literal notranslate"><span class="pre">number</span></code>, because the type can be inferred from the values in the array to be mapped.</p>
<p>In this example, the variable <code class="docutils literal notranslate"><span class="pre">number</span></code> is initialized with the value of the closure’s <code class="docutils literal notranslate"><span class="pre">number</span></code> parameter, so that the value can be modified within the closure body. (The parameters to functions and closures are always constants.) The closure expression also specifies a return type of <code class="docutils literal notranslate"><span class="pre">String</span></code>, to indicate the type that will be stored in the mapped output array.</p>
<p>The closure expression builds a string called <code class="docutils literal notranslate"><span class="pre">output</span></code> each time it is called. It calculates the last digit of <code class="docutils literal notranslate"><span class="pre">number</span></code> by using the remainder operator (<code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">%</span> <span class="pre">10</span></code>), and uses this digit to look up an appropriate string in the <code class="docutils literal notranslate"><span class="pre">digitNames</span></code> dictionary. The closure can be used to create a string representation of any integer greater than zero.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The call to the <code class="docutils literal notranslate"><span class="pre">digitNames</span></code> dictionary’s subscript is followed by an exclamation mark (<code class="docutils literal notranslate"><span class="pre">!</span></code>), because dictionary subscripts return an optional value to indicate that the dictionary lookup can fail if the key does not exist. In the example above, it is guaranteed that <code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">%</span> <span class="pre">10</span></code> will always be a valid subscript key for the <code class="docutils literal notranslate"><span class="pre">digitNames</span></code> dictionary, and so an exclamation mark is used to force-unwrap the <code class="docutils literal notranslate"><span class="pre">String</span></code> value stored in the subscript’s optional return value.</p>
</div>
<p>The string retrieved from the <code class="docutils literal notranslate"><span class="pre">digitNames</span></code> dictionary is added to the <em>front</em> of <code class="docutils literal notranslate"><span class="pre">output</span></code>, effectively building a string version of the number in reverse. (The expression <code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">%</span> <span class="pre">10</span></code> gives a value of <code class="docutils literal notranslate"><span class="pre">6</span></code> for <code class="docutils literal notranslate"><span class="pre">16</span></code>, <code class="docutils literal notranslate"><span class="pre">8</span></code> for <code class="docutils literal notranslate"><span class="pre">58</span></code>, and <code class="docutils literal notranslate"><span class="pre">0</span></code> for <code class="docutils literal notranslate"><span class="pre">510</span></code>.)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">number</span></code> variable is then divided by <code class="docutils literal notranslate"><span class="pre">10</span></code>. Because it is an integer, it is rounded down during the division, so <code class="docutils literal notranslate"><span class="pre">16</span></code> becomes <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">58</span></code> becomes <code class="docutils literal notranslate"><span class="pre">5</span></code>, and <code class="docutils literal notranslate"><span class="pre">510</span></code> becomes <code class="docutils literal notranslate"><span class="pre">51</span></code>.</p>
<p>The process is repeated until <code class="docutils literal notranslate"><span class="pre">number</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>, at which point the <code class="docutils literal notranslate"><span class="pre">output</span></code> string is returned by the closure, and is added to the output array by the <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method.</p>
<p>The use of trailing closure syntax in the example above neatly encapsulates the closure’s functionality immediately after the function that closure supports, without needing to wrap the entire closure within the <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method’s outer parentheses.</p>
</div>
<div class="section" id="ID103">
<h2>Capturing Values<a class="headerlink" href="Closures.html#ID103" title="Permalink to this headline">¶</a></h2>
<p>A closure can <em>capture</em> constants and variables from the surrounding context in which it is defined. The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.</p>
<p>In Swift, the simplest form of a closure that can capture values is a nested function, written within the body of another function. A nested function can capture any of its outer function’s arguments and can also capture any constants and variables defined within the outer function.</p>
<p>Here’s an example of a function called <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code>, which contains a nested function called <code class="docutils literal notranslate"><span class="pre">incrementer</span></code>. The nested <code class="docutils literal notranslate"><span class="pre">incrementer()</span></code> function captures two values, <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> and <code class="docutils literal notranslate"><span class="pre">amount</span></code>, from its surrounding context. After capturing these values, <code class="docutils literal notranslate"><span class="pre">incrementer</span></code> is returned by <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code> as a closure that increments <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> by <code class="docutils literal notranslate"><span class="pre">amount</span></code> each time it is called.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">makeIncrementer</span>(<span class="nv">forIncrement</span> <span class="nv">amount</span>: <span class="nc">Int</span>) -&gt; () -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">var</span> <span class="nv">runningTotal</span> = <span class="m">0</span>
</li><li> <span class="k">func</span> <span class="nv">incrementer</span>() -&gt; <span class="nc">Int</span> {
</li><li> <span class="nv">runningTotal</span> += <span class="nv">amount</span>
</li><li> <span class="k">return</span> <span class="nv">runningTotal</span>
</li><li>    }
</li><li> <span class="k">return</span> <span class="nv">incrementer</span>
</li><li>}
</li></ol></div></div></div>
<p>The return type of <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code> is <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>. This means that it returns a <em>function</em>, rather than a simple value. The function it returns has no parameters, and returns an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value each time it is called. To learn how functions can return other functions, see <a class="reference internal" href="Functions.html#ID177"><span class="std std-ref">Function Types as Return Types</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">makeIncrementer(forIncrement:)</span></code> function defines an integer variable called <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>, to store the current running total of the incrementer that will be returned. This variable is initialized with a value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">makeIncrementer(forIncrement:)</span></code> function has a single <code class="docutils literal notranslate"><span class="pre">Int</span></code> parameter with an argument label of <code class="docutils literal notranslate"><span class="pre">forIncrement</span></code>, and a parameter name of <code class="docutils literal notranslate"><span class="pre">amount</span></code>. The argument value passed to this parameter specifies how much <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> should be incremented by each time the returned incrementer function is called. The <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code> function defines a nested function called <code class="docutils literal notranslate"><span class="pre">incrementer</span></code>, which performs the actual incrementing. This function simply adds <code class="docutils literal notranslate"><span class="pre">amount</span></code> to <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>, and returns the result.</p>
<p>When considered in isolation, the nested <code class="docutils literal notranslate"><span class="pre">incrementer()</span></code> function might seem unusual:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">incrementer</span>() -&gt; <span class="nc">Int</span> {
</li><li> <span class="nv">runningTotal</span> += <span class="nv">amount</span>
</li><li> <span class="k">return</span> <span class="nv">runningTotal</span>
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">incrementer()</span></code> function doesn’t have any parameters, and yet it refers to <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> and <code class="docutils literal notranslate"><span class="pre">amount</span></code> from within its function body. It does this by capturing a <em>reference</em> to <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> and <code class="docutils literal notranslate"><span class="pre">amount</span></code> from the surrounding function and using them within its own function body. Capturing by reference ensures that <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> and <code class="docutils literal notranslate"><span class="pre">amount</span></code> do not disappear when the call to <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code> ends, and also ensures that <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> is available the next time the <code class="docutils literal notranslate"><span class="pre">incrementer</span></code> function is called.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>As an optimization, Swift may instead capture and store a <em>copy</em> of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.</p>
<p class="last">Swift also handles all memory management involved in disposing of variables when they are no longer needed.</p>
</div>
<p>Here’s an example of <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code> in action:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">incrementByTen</span> = <span class="nv">makeIncrementer</span>(<span class="nv">forIncrement</span>: <span class="m">10</span>)
</li></ol></div></div></div>
<p>This example sets a constant called <code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code> to refer to an incrementer function that adds <code class="docutils literal notranslate"><span class="pre">10</span></code> to its <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> variable each time it is called. Calling the function multiple times shows this behavior in action:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">incrementByTen</span>()
</li><li><span class="c">// returns a value of 10</span>
</li><li><span class="nv">incrementByTen</span>()
</li><li><span class="c">// returns a value of 20</span>
</li><li><span class="nv">incrementByTen</span>()
</li><li><span class="c">// returns a value of 30</span>
</li></ol></div></div></div>
<p>If you create a second incrementer, it will have its own stored reference to a new, separate <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> variable:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">incrementBySeven</span> = <span class="nv">makeIncrementer</span>(<span class="nv">forIncrement</span>: <span class="m">7</span>)
</li><li><span class="nv">incrementBySeven</span>()
</li><li><span class="c">// returns a value of 7</span>
</li></ol></div></div></div>
<p>Calling the original incrementer (<code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code>) again continues to increment its own <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> variable, and does not affect the variable captured by <code class="docutils literal notranslate"><span class="pre">incrementBySeven</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">incrementByTen</span>()
</li><li><span class="c">// returns a value of 40</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you assign a closure to a property of a class instance, and the closure captures that instance by referring to the instance or its members, you will create a strong reference cycle between the closure and the instance. Swift uses <em>capture lists</em> to break these strong reference cycles. For more information, see <a class="reference internal" href="AutomaticReferenceCounting.html#ID56"><span class="std std-ref">Strong Reference Cycles for Closures</span></a>.</p>
</div>
</div>
<div class="section" id="ID104">
<h2>Closures Are Reference Types<a class="headerlink" href="Closures.html#ID104" title="Permalink to this headline">¶</a></h2>
<p>In the example above, <code class="docutils literal notranslate"><span class="pre">incrementBySeven</span></code> and <code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code> are constants, but the closures these constants refer to are still able to increment the <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> variables that they have captured. This is because functions and closures are <em>reference types</em>.</p>
<p>Whenever you assign a function or a closure to a constant or a variable, you are actually setting that constant or variable to be a <em>reference</em> to the function or closure. In the example above, it is the choice of closure that <code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code> <em>refers to</em> that is constant, and not the contents of the closure itself.</p>
<p>This also means that if you assign a closure to two different constants or variables, both of those constants or variables refer to the same closure.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">alsoIncrementByTen</span> = <span class="nv">incrementByTen</span>
</li><li><span class="nv">alsoIncrementByTen</span>()
</li><li><span class="c">// returns a value of 50</span>
</li><li>
</li><li><span class="nv">incrementByTen</span>()
</li><li><span class="c">// returns a value of 60</span>
</li></ol></div></div></div>
<p>The example above shows that calling <code class="docutils literal notranslate"><span class="pre">alsoIncrementByTen</span></code> is the same as calling <code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code>. Because both of them refer to the same closure, they both increment and return the same running total.</p>
</div>
<div class="section" id="ID546">
<h2>Escaping Closures<a class="headerlink" href="Closures.html#ID546" title="Permalink to this headline">¶</a></h2>
<p>A closure is said to <em>escape</em> a function when the closure is passed as an argument to the function, but is called after the function returns. When you declare a function that takes a closure as one of its parameters, you can write <code class="docutils literal notranslate"><span class="pre">@escaping</span></code> before the parameter’s type to indicate that the closure is allowed to escape.</p>
<p>One way that a closure can escape is by being stored in a variable that is defined outside the function. As an example, many functions that start an asynchronous operation take a closure argument as a completion handler. The function returns after it starts the operation, but the closure isn’t called until the operation is completed—the closure needs to escape, to be called later. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">completionHandlers</span>: [() -&gt; <span class="nc">Void</span>] = []
</li><li><span class="k">func</span> <span class="nv">someFunctionWithEscapingClosure</span>(<span class="nv">completionHandler</span>: <span class="k">@escaping</span> () -&gt; <span class="nc">Void</span>) {
</li><li> <span class="nv">completionHandlers</span>.<span class="nv">append</span>(<span class="nv">completionHandler</span>)
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">someFunctionWithEscapingClosure(_:)</span></code> function takes a closure as its argument and adds it to an array that’s declared outside the function. If you didn’t mark the parameter of this function with <code class="docutils literal notranslate"><span class="pre">@escaping</span></code>, you would get a compile-time error.</p>
<p>Marking a closure with <code class="docutils literal notranslate"><span class="pre">@escaping</span></code> means you have to refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> explicitly within the closure. For example, in the code below, the closure passed to <code class="docutils literal notranslate"><span class="pre">someFunctionWithEscapingClosure(_:)</span></code> is an escaping closure, which means it needs to refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> explicitly. In contrast, the closure passed to <code class="docutils literal notranslate"><span class="pre">someFunctionWithNonescapingClosure(_:)</span></code> is a nonescaping closure, which means it can refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> implicitly.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunctionWithNonescapingClosure</span>(<span class="nv">closure</span>: () -&gt; <span class="nc">Void</span>) {
</li><li> <span class="nv">closure</span>()
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li> <span class="k">var</span> <span class="nv">x</span> = <span class="m">10</span>
</li><li> <span class="k">func</span> <span class="nv">doSomething</span>() {
</li><li> <span class="nv">someFunctionWithEscapingClosure</span> { <span class="k">self</span>.<span class="nv">x</span> = <span class="m">100</span> }
</li><li> <span class="nv">someFunctionWithNonescapingClosure</span> { <span class="nv">x</span> = <span class="m">200</span> }
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">instance</span> = <span class="nv">SomeClass</span>()
</li><li><span class="nv">instance</span>.<span class="nv">doSomething</span>()
</li><li><span class="nv">print</span>(<span class="nv">instance</span>.<span class="nv">x</span>)
</li><li><span class="c">// Prints "200"</span>
</li><li>
</li><li><span class="nv">completionHandlers</span>.<span class="nv">first</span>?()
</li><li><span class="nv">print</span>(<span class="nv">instance</span>.<span class="nv">x</span>)
</li><li><span class="c">// Prints "100"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID543">
<h2>Autoclosures<a class="headerlink" href="Closures.html#ID543" title="Permalink to this headline">¶</a></h2>
<p>An <em>autoclosure</em> is a closure that is automatically created to wrap an expression that’s being passed as an argument to a function. It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it. This syntactic convenience lets you omit braces around a function’s parameter by writing a normal expression instead of an explicit closure.</p>
<p>It’s common to <em>call</em> functions that take autoclosures, but it’s not common to <em>implement</em> that kind of function. For example, the <code class="docutils literal notranslate"><span class="pre">assert(condition:message:file:line:)</span></code> function takes an autoclosure for its <code class="docutils literal notranslate"><span class="pre">condition</span></code> and <code class="docutils literal notranslate"><span class="pre">message</span></code> parameters; its <code class="docutils literal notranslate"><span class="pre">condition</span></code> parameter is evaluated only in debug builds and its <code class="docutils literal notranslate"><span class="pre">message</span></code> parameter is evaluated only if <code class="docutils literal notranslate"><span class="pre">condition</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>An autoclosure lets you delay evaluation, because the code inside isn’t run until you call the closure. Delaying evaluation is useful for code that has side effects or is computationally expensive, because it lets you control when that code is evaluated. The code below shows how a closure delays evaluation.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">customersInLine</span> = [<span class="s">"Chris"</span>, <span class="s">"Alex"</span>, <span class="s">"Ewa"</span>, <span class="s">"Barry"</span>, <span class="s">"Daniella"</span>]
</li><li><span class="nv">print</span>(<span class="nv">customersInLine</span>.<span class="nv">count</span>)
</li><li><span class="c">// Prints "5"</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">customerProvider</span> = { <span class="nv">customersInLine</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>) }
</li><li><span class="nv">print</span>(<span class="nv">customersInLine</span>.<span class="nv">count</span>)
</li><li><span class="c">// Prints "5"</span>
</li><li>
</li><li><span class="nv">print</span>(<span class="s">"Now serving </span>\<span class="p">(</span><span class="nv">customerProvider</span>()<span class="p">)</span><span class="s">!"</span>)
</li><li><span class="c">// Prints "Now serving Chris!"</span>
</li><li><span class="nv">print</span>(<span class="nv">customersInLine</span>.<span class="nv">count</span>)
</li><li><span class="c">// Prints "4"</span>
</li></ol></div></div></div>
<p>Even though the first element of the <code class="docutils literal notranslate"><span class="pre">customersInLine</span></code> array is removed by the code inside the closure, the array element isn’t removed until the closure is actually called. If the closure is never called, the expression inside the closure is never evaluated, which means the array element is never removed. Note that the type of <code class="docutils literal notranslate"><span class="pre">customerProvider</span></code> is not <code class="docutils literal notranslate"><span class="pre">String</span></code> but <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code>—a function with no parameters that returns a string.</p>
<p>You get the same behavior of delayed evaluation when you pass a closure as an argument to a function.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]</span>
</li><li><span class="k">func</span> <span class="nv">serve</span>(<span class="nv">customer</span> <span class="nv">customerProvider</span>: () -&gt; <span class="nc">String</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Now serving </span>\<span class="p">(</span><span class="nv">customerProvider</span>()<span class="p">)</span><span class="s">!"</span>)
</li><li>}
</li><li><span class="nv">serve</span>(<span class="nv">customer</span>: { <span class="nv">customersInLine</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>) } )
</li><li><span class="c">// Prints "Now serving Alex!"</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">serve(customer:)</span></code> function in the listing above takes an explicit closure that returns a customer’s name. The version of <code class="docutils literal notranslate"><span class="pre">serve(customer:)</span></code> below performs the same operation but, instead of taking an explicit closure, it takes an autoclosure by marking its parameter’s type with the <code class="docutils literal notranslate"><span class="pre">@autoclosure</span></code> attribute. Now you can call the function as if it took a <code class="docutils literal notranslate"><span class="pre">String</span></code> argument instead of a closure. The argument is automatically converted to a closure, because the <code class="docutils literal notranslate"><span class="pre">customerProvider</span></code> parameter’s type is marked with the <code class="docutils literal notranslate"><span class="pre">@autoclosure</span></code> attribute.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// customersInLine is ["Ewa", "Barry", "Daniella"]</span>
</li><li><span class="k">func</span> <span class="nv">serve</span>(<span class="nv">customer</span> <span class="nv">customerProvider</span>: <span class="k">@autoclosure</span> () -&gt; <span class="nc">String</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Now serving </span>\<span class="p">(</span><span class="nv">customerProvider</span>()<span class="p">)</span><span class="s">!"</span>)
</li><li>}
</li><li><span class="nv">serve</span>(<span class="nv">customer</span>: <span class="nv">customersInLine</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>))
</li><li><span class="c">// Prints "Now serving Ewa!"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Overusing autoclosures can make your code hard to understand. The context and function name should make it clear that evaluation is being deferred.</p>
</div>
<p>If you want an autoclosure that is allowed to escape, use both the <code class="docutils literal notranslate"><span class="pre">@autoclosure</span></code> and <code class="docutils literal notranslate"><span class="pre">@escaping</span></code> attributes. The <code class="docutils literal notranslate"><span class="pre">@escaping</span></code> attribute is described above in <a class="reference internal" href="Closures.html#ID546"><span class="std std-ref">Escaping Closures</span></a>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// customersInLine is ["Barry", "Daniella"]</span>
</li><li><span class="k">var</span> <span class="nv">customerProviders</span>: [() -&gt; <span class="nc">String</span>] = []
</li><li><span class="k">func</span> <span class="nv">collectCustomerProviders</span>(<span class="k">_</span> <span class="nv">customerProvider</span>: <span class="k">@autoclosure</span> <span class="k">@escaping</span> () -&gt; <span class="nc">String</span>) {
</li><li> <span class="nv">customerProviders</span>.<span class="nv">append</span>(<span class="nv">customerProvider</span>)
</li><li>}
</li><li><span class="nv">collectCustomerProviders</span>(<span class="nv">customersInLine</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>))
</li><li><span class="nv">collectCustomerProviders</span>(<span class="nv">customersInLine</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>))
</li><li>
</li><li><span class="nv">print</span>(<span class="s">"Collected </span>\<span class="p">(</span><span class="nv">customerProviders</span>.<span class="nv">count</span><span class="p">)</span><span class="s"> closures."</span>)
</li><li><span class="c">// Prints "Collected 2 closures."</span>
</li><li><span class="k">for</span> <span class="nv">customerProvider</span> <span class="k">in</span> <span class="nv">customerProviders</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Now serving </span>\<span class="p">(</span><span class="nv">customerProvider</span>()<span class="p">)</span><span class="s">!"</span>)
</li><li>}
</li><li><span class="c">// Prints "Now serving Barry!"</span>
</li><li><span class="c">// Prints "Now serving Daniella!"</span>
</li></ol></div></div></div>
<p>In the code above, instead of calling the closure passed to it as its <code class="docutils literal notranslate"><span class="pre">customerProvider</span></code> argument, the <code class="docutils literal notranslate"><span class="pre">collectCustomerProviders(_:)</span></code> function appends the closure to the <code class="docutils literal notranslate"><span class="pre">customerProviders</span></code> array. The array is declared outside the scope of the function, which means the closures in the array can be executed after the function returns. As a result, the value of the <code class="docutils literal notranslate"><span class="pre">customerProvider</span></code> argument must be allowed to escape the function’s scope.</p>
</div>
</div><div class="section" id="enumerations">
<h1>Enumerations<a class="headerlink" href="Enumerations.html#enumerations" title="Permalink to this headline">¶</a></h1>
<p>An <em>enumeration</em> defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.</p>
<p>If you are familiar with C, you will know that C enumerations assign related names to a set of integer values. Enumerations in Swift are much more flexible, and do not have to provide a value for each case of the enumeration. If a value (known as a “raw” value) <em>is</em> provided for each enumeration case, the value can be a string, a character, or a value of any integer or floating-point type.</p>
<p>Alternatively, enumeration cases can specify associated values of <em>any</em> type to be stored along with each different case value, much as unions or variants do in other languages. You can define a common set of related cases as part of one enumeration, each of which has a different set of values of appropriate types associated with it.</p>
<p>Enumerations in Swift are first-class types in their own right. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial case value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</p>
<p>For more about these capabilities, see <a class="reference internal" href="Properties.html"><span class="doc">Properties</span></a>, <a class="reference internal" href="Methods.html"><span class="doc">Methods</span></a>, <a class="reference internal" href="Initialization.html"><span class="doc">Initialization</span></a>, <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>, and <a class="reference internal" href="Protocols.html"><span class="doc">Protocols</span></a>.</p>
<div class="section" id="ID146">
<h2>Enumeration Syntax<a class="headerlink" href="Enumerations.html#ID146" title="Permalink to this headline">¶</a></h2>
<p>You introduce enumerations with the <code class="docutils literal notranslate"><span class="pre">enum</span></code> keyword and place their entire definition within a pair of braces:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">SomeEnumeration</span> {
</li><li> <span class="c">// enumeration definition goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>Here’s an example for the four main points of a compass:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">CompassPoint</span> {
</li><li> <span class="k">case</span> <span class="nv">north</span>
</li><li> <span class="k">case</span> <span class="nv">south</span>
</li><li> <span class="k">case</span> <span class="nv">east</span>
</li><li> <span class="k">case</span> <span class="nv">west</span>
</li><li>}
</li></ol></div></div></div>
<p>The values defined in an enumeration (such as <code class="docutils literal notranslate"><span class="pre">north</span></code>, <code class="docutils literal notranslate"><span class="pre">south</span></code>, <code class="docutils literal notranslate"><span class="pre">east</span></code>, and <code class="docutils literal notranslate"><span class="pre">west</span></code>) are its <em>enumeration cases</em>. You use the <code class="docutils literal notranslate"><span class="pre">case</span></code> keyword to introduce new enumeration cases.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike C and Objective-C, Swift enumeration cases are not assigned a default integer value when they are created. In the <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> example above, <code class="docutils literal notranslate"><span class="pre">north</span></code>, <code class="docutils literal notranslate"><span class="pre">south</span></code>, <code class="docutils literal notranslate"><span class="pre">east</span></code> and <code class="docutils literal notranslate"><span class="pre">west</span></code> do not implicitly equal <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">3</span></code>. Instead, the different enumeration cases are fully-fledged values in their own right, with an explicitly defined type of <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>.</p>
</div>
<p>Multiple cases can appear on a single line, separated by commas:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Planet</span> {
</li><li> <span class="k">case</span> <span class="nv">mercury</span>, <span class="nv">venus</span>, <span class="nv">earth</span>, <span class="nv">mars</span>, <span class="nv">jupiter</span>, <span class="nv">saturn</span>, <span class="nv">uranus</span>, <span class="nv">neptune</span>
</li><li>}
</li></ol></div></div></div>
<p>Each enumeration definition defines a new type. Like other types in Swift, their names (such as <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> and <code class="docutils literal notranslate"><span class="pre">Planet</span></code>) should start with a capital letter. Give enumeration types singular rather than plural names, so that they read as self-evident:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">directionToHead</span> = <span class="nv">CompassPoint</span>.<span class="nv">west</span>
</li></ol></div></div></div>
<p>The type of <code class="docutils literal notranslate"><span class="pre">directionToHead</span></code> is inferred when it is initialized with one of the possible values of <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>. Once <code class="docutils literal notranslate"><span class="pre">directionToHead</span></code> is declared as a <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>, you can set it to a different <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> value using a shorter dot syntax:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">directionToHead</span> = .<span class="nv">east</span>
</li></ol></div></div></div>
<p>The type of <code class="docutils literal notranslate"><span class="pre">directionToHead</span></code> is already known, and so you can drop the type when setting its value. This makes for highly readable code when working with explicitly typed enumeration values.</p>
</div>
<div class="section" id="ID147">
<h2>Matching Enumeration Values with a Switch Statement<a class="headerlink" href="Enumerations.html#ID147" title="Permalink to this headline">¶</a></h2>
<p>You can match individual enumeration values with a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">directionToHead</span> = .<span class="nv">south</span>
</li><li><span class="k">switch</span> <span class="nv">directionToHead</span> {
</li><li><span class="k">case</span> .<span class="nv">north</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Lots of planets have a north"</span>)
</li><li><span class="k">case</span> .<span class="nv">south</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Watch out for penguins"</span>)
</li><li><span class="k">case</span> .<span class="nv">east</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Where the sun rises"</span>)
</li><li><span class="k">case</span> .<span class="nv">west</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Where the skies are blue"</span>)
</li><li>}
</li><li><span class="c">// Prints "Watch out for penguins"</span>
</li></ol></div></div></div>
<p>You can read this code as:</p>
<p>“Consider the value of <code class="docutils literal notranslate"><span class="pre">directionToHead</span></code>. In the case where it equals <code class="docutils literal notranslate"><span class="pre">.north</span></code>, print <code class="docutils literal notranslate"><span class="pre">"Lots</span> <span class="pre">of</span> <span class="pre">planets</span> <span class="pre">have</span> <span class="pre">a</span> <span class="pre">north"</span></code>. In the case where it equals <code class="docutils literal notranslate"><span class="pre">.south</span></code>, print <code class="docutils literal notranslate"><span class="pre">"Watch</span> <span class="pre">out</span> <span class="pre">for</span> <span class="pre">penguins"</span></code>.”</p>
<p>…and so on.</p>
<p>As described in <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>, a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement must be exhaustive when considering an enumeration’s cases. If the <code class="docutils literal notranslate"><span class="pre">case</span></code> for <code class="docutils literal notranslate"><span class="pre">.west</span></code> is omitted, this code does not compile, because it does not consider the complete list of <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> cases. Requiring exhaustiveness ensures that enumeration cases are not accidentally omitted.</p>
<p>When it is not appropriate to provide a <code class="docutils literal notranslate"><span class="pre">case</span></code> for every enumeration case, you can provide a <code class="docutils literal notranslate"><span class="pre">default</span></code> case to cover any cases that are not addressed explicitly:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">somePlanet</span> = <span class="nv">Planet</span>.<span class="nv">earth</span>
</li><li><span class="k">switch</span> <span class="nv">somePlanet</span> {
</li><li><span class="k">case</span> .<span class="nv">earth</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Mostly harmless"</span>)
</li><li><span class="k">default</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Not a safe place for humans"</span>)
</li><li>}
</li><li><span class="c">// Prints "Mostly harmless"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID581">
<h2>Iterating over Enumeration Cases<a class="headerlink" href="Enumerations.html#ID581" title="Permalink to this headline">¶</a></h2>
<p>For some enumerations, it’s useful to have a collection of all of that enumeration’s cases. You enable this by writing <code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">CaseIterable</span></code> after the enumeration’s name. Swift exposes a collection of all the cases as an <code class="docutils literal notranslate"><span class="pre">allCases</span></code> property of the enumeration type. Here’s an example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Beverage</span>: <span class="nc">CaseIterable</span> {
</li><li> <span class="k">case</span> <span class="nv">coffee</span>, <span class="nv">tea</span>, <span class="nv">juice</span>
</li><li>}
</li><li><span class="k">let</span> <span class="nv">numberOfChoices</span> = <span class="nv">Beverage</span>.<span class="nv">allCases</span>.<span class="nv">count</span>
</li><li><span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">numberOfChoices</span><span class="p">)</span><span class="s"> beverages available"</span>)
</li><li><span class="c">// Prints "3 beverages available"</span>
</li></ol></div></div></div>
<p>In the example above, you write <code class="docutils literal notranslate"><span class="pre">Beverage.allCases</span></code> to access a collection that contains all of the cases of the <code class="docutils literal notranslate"><span class="pre">Beverage</span></code> enumeration. You can use <code class="docutils literal notranslate"><span class="pre">allCases</span></code> like any other collection—the collection’s elements are instances of the enumeration type, so in this case they’re <code class="docutils literal notranslate"><span class="pre">Beverage</span></code> values. The example above counts how many cases there are, and the example below uses a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop to iterate over all the cases.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">beverage</span> <span class="k">in</span> <span class="nv">Beverage</span>.<span class="nv">allCases</span> {
</li><li> <span class="nv">print</span>(<span class="nv">beverage</span>)
</li><li>}
</li><li><span class="c">// coffee</span>
</li><li><span class="c">// tea</span>
</li><li><span class="c">// juice</span>
</li></ol></div></div></div>
<p>The syntax used in the examples above marks the enumeration as conforming to the <a class="reference external" href="https://developer.apple.com/documentation/swift/caseiterable"><code class="docutils literal notranslate"><span class="pre">CaseIterable</span></code></a> protocol. For information about protocols, see <a class="reference internal" href="Protocols.html"><span class="doc">Protocols</span></a>.</p>
</div>
<div class="section" id="ID148">
<h2>Associated Values<a class="headerlink" href="Enumerations.html#ID148" title="Permalink to this headline">¶</a></h2>
<p>The examples in the previous section show how the cases of an enumeration are a defined (and typed) value in their own right. You can set a constant or variable to <code class="docutils literal notranslate"><span class="pre">Planet.earth</span></code>, and check for this value later. However, it is sometimes useful to be able to store <em>associated values</em> of other types alongside these case values. This enables you to store additional custom information along with the case value, and permits this information to vary each time you use that case in your code.</p>
<p>You can define Swift enumerations to store associated values of any given type, and the value types can be different for each case of the enumeration if needed. Enumerations similar to these are known as <em>discriminated unions</em>, <em>tagged unions</em>, or <em>variants</em> in other programming languages.</p>
<p>For example, suppose an inventory tracking system needs to track products by two different types of barcode. Some products are labeled with 1D barcodes in UPC format, which uses the numbers <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">9</span></code>. Each barcode has a “number system” digit, followed by five “manufacturer code” digits and five “product code” digits. These are followed by a “check” digit to verify that the code has been scanned correctly:</p>
<img alt="../_images/barcode_UPC_2x.png" class="align-center" src="../_images/barcode_UPC_2x.png" style="width: 252px;"/>
<p>Other products are labeled with 2D barcodes in QR code format, which can use any ISO 8859-1 character and can encode a string up to 2,953 characters long:</p>
<img alt="../_images/barcode_QR_2x.png" class="align-center" src="../_images/barcode_QR_2x.png" style="width: 169px;"/>
<p>It would be convenient for an inventory tracking system to be able to store UPC barcodes as a tuple of four integers, and QR code barcodes as a string of any length.</p>
<p>In Swift, an enumeration to define product barcodes of either type might look like this:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Barcode</span> {
</li><li> <span class="k">case</span> <span class="nv">upc</span>(<span class="nv">Int</span>, <span class="nv">Int</span>, <span class="nv">Int</span>, <span class="nv">Int</span>)
</li><li> <span class="k">case</span> <span class="nv">qrCode</span>(<span class="nv">String</span>)
</li><li>}
</li></ol></div></div></div>
<p>This can be read as:</p>
<p>“Define an enumeration type called <code class="docutils literal notranslate"><span class="pre">Barcode</span></code>, which can take either a value of <code class="docutils literal notranslate"><span class="pre">upc</span></code> with an associated value of type (<code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>), or a value of <code class="docutils literal notranslate"><span class="pre">qrCode</span></code> with an associated value of type <code class="docutils literal notranslate"><span class="pre">String</span></code>.”</p>
<p>This definition does not provide any actual <code class="docutils literal notranslate"><span class="pre">Int</span></code> or <code class="docutils literal notranslate"><span class="pre">String</span></code> values—it just defines the <em>type</em> of associated values that <code class="docutils literal notranslate"><span class="pre">Barcode</span></code> constants and variables can store when they are equal to <code class="docutils literal notranslate"><span class="pre">Barcode.upc</span></code> or <code class="docutils literal notranslate"><span class="pre">Barcode.qrCode</span></code>.</p>
<p>New barcodes can then be created using either type:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">productBarcode</span> = <span class="nv">Barcode</span>.<span class="nv">upc</span>(<span class="m">8</span>, <span class="m">85909</span>, <span class="m">51226</span>, <span class="m">3</span>)
</li></ol></div></div></div>
<p>This example creates a new variable called <code class="docutils literal notranslate"><span class="pre">productBarcode</span></code> and assigns it a value of <code class="docutils literal notranslate"><span class="pre">Barcode.upc</span></code> with an associated tuple value of <code class="docutils literal notranslate"><span class="pre">(8,</span> <span class="pre">85909,</span> <span class="pre">51226,</span> <span class="pre">3)</span></code>.</p>
<p>The same product can be assigned a different type of barcode:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">productBarcode</span> = .<span class="nv">qrCode</span>(<span class="s">"ABCDEFGHIJKLMNOP"</span>)
</li></ol></div></div></div>
<p>At this point, the original <code class="docutils literal notranslate"><span class="pre">Barcode.upc</span></code> and its integer values are replaced by the new <code class="docutils literal notranslate"><span class="pre">Barcode.qrCode</span></code> and its string value. Constants and variables of type <code class="docutils literal notranslate"><span class="pre">Barcode</span></code> can store either a <code class="docutils literal notranslate"><span class="pre">.upc</span></code> or a <code class="docutils literal notranslate"><span class="pre">.qrCode</span></code> (together with their associated values), but they can only store one of them at any given time.</p>
<p>The different barcode types can be checked using a switch statement, as before. This time, however, the associated values can be extracted as part of the switch statement. You extract each associated value as a constant (with the <code class="docutils literal notranslate"><span class="pre">let</span></code> prefix) or a variable (with the <code class="docutils literal notranslate"><span class="pre">var</span></code> prefix) for use within the <code class="docutils literal notranslate"><span class="pre">switch</span></code> case’s body:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">switch</span> <span class="nv">productBarcode</span> {
</li><li><span class="k">case</span> .<span class="nv">upc</span>(<span class="k">let</span> <span class="nv">numberSystem</span>, <span class="k">let</span> <span class="nv">manufacturer</span>, <span class="k">let</span> <span class="nv">product</span>, <span class="k">let</span> <span class="nv">check</span>):
</li><li> <span class="nv">print</span>(<span class="s">"UPC: </span>\<span class="p">(</span><span class="nv">numberSystem</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">manufacturer</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">product</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">check</span><span class="p">)</span><span class="s">."</span>)
</li><li><span class="k">case</span> .<span class="nv">qrCode</span>(<span class="k">let</span> <span class="nv">productCode</span>):
</li><li> <span class="nv">print</span>(<span class="s">"QR code: </span>\<span class="p">(</span><span class="nv">productCode</span><span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li><span class="c">// Prints "QR code: ABCDEFGHIJKLMNOP."</span>
</li></ol></div></div></div>
<p>If all of the associated values for an enumeration case are extracted as constants, or if all are extracted as variables, you can place a single <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">let</span></code> annotation before the case name, for brevity:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">switch</span> <span class="nv">productBarcode</span> {
</li><li><span class="k">case</span> <span class="k">let</span> .<span class="nv">upc</span>(<span class="nv">numberSystem</span>, <span class="nv">manufacturer</span>, <span class="nv">product</span>, <span class="nv">check</span>):
</li><li> <span class="nv">print</span>(<span class="s">"UPC : </span>\<span class="p">(</span><span class="nv">numberSystem</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">manufacturer</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">product</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">check</span><span class="p">)</span><span class="s">."</span>)
</li><li><span class="k">case</span> <span class="k">let</span> .<span class="nv">qrCode</span>(<span class="nv">productCode</span>):
</li><li> <span class="nv">print</span>(<span class="s">"QR code: </span>\<span class="p">(</span><span class="nv">productCode</span><span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li><span class="c">// Prints "QR code: ABCDEFGHIJKLMNOP."</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID149">
<h2>Raw Values<a class="headerlink" href="Enumerations.html#ID149" title="Permalink to this headline">¶</a></h2>
<p>The barcode example in <a class="reference internal" href="Enumerations.html#ID148"><span class="std std-ref">Associated Values</span></a> shows how cases of an enumeration can declare that they store associated values of different types. As an alternative to associated values, enumeration cases can come prepopulated with default values (called <em>raw values</em>), which are all of the same type.</p>
<p>Here’s an example that stores raw ASCII values alongside named enumeration cases:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">ASCIIControlCharacter</span>: <span class="nc">Character</span> {
</li><li> <span class="k">case</span> <span class="nv">tab</span> = <span class="s">"\t"</span>
</li><li> <span class="k">case</span> <span class="nv">lineFeed</span> = <span class="s">"\n"</span>
</li><li> <span class="k">case</span> <span class="nv">carriageReturn</span> = <span class="s">"\r"</span>
</li><li>}
</li></ol></div></div></div>
<p>Here, the raw values for an enumeration called <code class="docutils literal notranslate"><span class="pre">ASCIIControlCharacter</span></code> are defined to be of type <code class="docutils literal notranslate"><span class="pre">Character</span></code>, and are set to some of the more common ASCII control characters. <code class="docutils literal notranslate"><span class="pre">Character</span></code> values are described in <a class="reference internal" href="StringsAndCharacters.html"><span class="doc">Strings and Characters</span></a>.</p>
<p>Raw values can be strings, characters, or any of the integer or floating-point number types. Each raw value must be unique within its enumeration declaration.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Raw values are <em>not</em> the same as associated values. Raw values are set to prepopulated values when you first define the enumeration in your code, like the three ASCII codes above. The raw value for a particular enumeration case is always the same. Associated values are set when you create a new constant or variable based on one of the enumeration’s cases, and can be different each time you do so.</p>
</div>
<div class="section" id="ID535">
<h3>Implicitly Assigned Raw Values<a class="headerlink" href="Enumerations.html#ID535" title="Permalink to this headline">¶</a></h3>
<p>When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case. When you don’t, Swift will automatically assign the values for you.</p>
<p>For instance, when integers are used for raw values, the implicit value for each case is one more than the previous case. If the first case doesn’t have a value set, its value is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>The enumeration below is a refinement of the earlier <code class="docutils literal notranslate"><span class="pre">Planet</span></code> enumeration, with integer raw values to represent each planet’s order from the sun:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Planet</span>: <span class="nc">Int</span> {
</li><li> <span class="k">case</span> <span class="nv">mercury</span> = <span class="m">1</span>, <span class="nv">venus</span>, <span class="nv">earth</span>, <span class="nv">mars</span>, <span class="nv">jupiter</span>, <span class="nv">saturn</span>, <span class="nv">uranus</span>, <span class="nv">neptune</span>
</li><li>}
</li></ol></div></div></div>
<p>In the example above, <code class="docutils literal notranslate"><span class="pre">Planet.mercury</span></code> has an explicit raw value of <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">Planet.venus</span></code> has an implicit raw value of <code class="docutils literal notranslate"><span class="pre">2</span></code>, and so on.</p>
<p>When strings are used for raw values, the implicit value for each case is the text of that case’s name.</p>
<p>The enumeration below is a refinement of the earlier <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> enumeration, with string raw values to represent each direction’s name:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">CompassPoint</span>: <span class="nc">String</span> {
</li><li> <span class="k">case</span> <span class="nv">north</span>, <span class="nv">south</span>, <span class="nv">east</span>, <span class="nv">west</span>
</li><li>}
</li></ol></div></div></div>
<p>In the example above, <code class="docutils literal notranslate"><span class="pre">CompassPoint.south</span></code> has an implicit raw value of <code class="docutils literal notranslate"><span class="pre">"south"</span></code>, and so on.</p>
<p>You access the raw value of an enumeration case with its <code class="docutils literal notranslate"><span class="pre">rawValue</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">earthsOrder</span> = <span class="nv">Planet</span>.<span class="nv">earth</span>.<span class="nv">rawValue</span>
</li><li><span class="c">// earthsOrder is 3</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">sunsetDirection</span> = <span class="nv">CompassPoint</span>.<span class="nv">west</span>.<span class="nv">rawValue</span>
</li><li><span class="c">// sunsetDirection is "west"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID150">
<h3>Initializing from a Raw Value<a class="headerlink" href="Enumerations.html#ID150" title="Permalink to this headline">¶</a></h3>
<p>If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value’s type (as a parameter called <code class="docutils literal notranslate"><span class="pre">rawValue</span></code>) and returns either an enumeration case or <code class="docutils literal notranslate"><span class="pre">nil</span></code>. You can use this initializer to try to create a new instance of the enumeration.</p>
<p>This example identifies Uranus from its raw value of <code class="docutils literal notranslate"><span class="pre">7</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">possiblePlanet</span> = <span class="nv">Planet</span>(<span class="nv">rawValue</span>: <span class="m">7</span>)
</li><li><span class="c">// possiblePlanet is of type Planet? and equals Planet.uranus</span>
</li></ol></div></div></div>
<p>Not all possible <code class="docutils literal notranslate"><span class="pre">Int</span></code> values will find a matching planet, however. Because of this, the raw value initializer always returns an <em>optional</em> enumeration case. In the example above, <code class="docutils literal notranslate"><span class="pre">possiblePlanet</span></code> is of type <code class="docutils literal notranslate"><span class="pre">Planet?</span></code>, or “optional <code class="docutils literal notranslate"><span class="pre">Planet</span></code>.”</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The raw value initializer is a failable initializer, because not every raw value will return an enumeration case. For more information, see <a class="reference internal" href="../ReferenceManual/Declarations.html#ID376"><span class="std std-ref">Failable Initializers</span></a>.</p>
</div>
<p>If you try to find a planet with a position of <code class="docutils literal notranslate"><span class="pre">11</span></code>, the optional <code class="docutils literal notranslate"><span class="pre">Planet</span></code> value returned by the raw value initializer will be <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">positionToFind</span> = <span class="m">11</span>
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">somePlanet</span> = <span class="nv">Planet</span>(<span class="nv">rawValue</span>: <span class="nv">positionToFind</span>) {
</li><li> <span class="k">switch</span> <span class="nv">somePlanet</span> {
</li><li> <span class="k">case</span> .<span class="nv">earth</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Mostly harmless"</span>)
</li><li> <span class="k">default</span>:
</li><li> <span class="nv">print</span>(<span class="s">"Not a safe place for humans"</span>)
</li><li>    }
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"There isn't a planet at position </span>\<span class="p">(</span><span class="nv">positionToFind</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Prints "There isn't a planet at position 11"</span>
</li></ol></div></div></div>
<p>This example uses optional binding to try to access a planet with a raw value of <code class="docutils literal notranslate"><span class="pre">11</span></code>. The statement <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">let</span> <span class="pre">somePlanet</span> <span class="pre">=</span> <span class="pre">Planet(rawValue:</span> <span class="pre">11)</span></code> creates an optional <code class="docutils literal notranslate"><span class="pre">Planet</span></code>, and sets <code class="docutils literal notranslate"><span class="pre">somePlanet</span></code> to the value of that optional <code class="docutils literal notranslate"><span class="pre">Planet</span></code> if it can be retrieved. In this case, it is not possible to retrieve a planet with a position of <code class="docutils literal notranslate"><span class="pre">11</span></code>, and so the <code class="docutils literal notranslate"><span class="pre">else</span></code> branch is executed instead.</p>
</div>
</div>
<div class="section" id="ID536">
<h2>Recursive Enumerations<a class="headerlink" href="Enumerations.html#ID536" title="Permalink to this headline">¶</a></h2>
<p>A <em>recursive enumeration</em> is an enumeration that has another instance of the enumeration as the associated value for one or more of the enumeration cases. You indicate that an enumeration case is recursive by writing <code class="docutils literal notranslate"><span class="pre">indirect</span></code> before it, which tells the compiler to insert the necessary layer of indirection.</p>
<p>For example, here is an enumeration that stores simple arithmetic expressions:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">ArithmeticExpression</span> {
</li><li> <span class="k">case</span> <span class="nv">number</span>(<span class="nv">Int</span>)
</li><li> <span class="k">indirect</span> <span class="k">case</span> <span class="nv">addition</span>(<span class="nv">ArithmeticExpression</span>, <span class="nv">ArithmeticExpression</span>)
</li><li> <span class="k">indirect</span> <span class="k">case</span> <span class="nv">multiplication</span>(<span class="nv">ArithmeticExpression</span>, <span class="nv">ArithmeticExpression</span>)
</li><li>}
</li></ol></div></div></div>
<p>You can also write <code class="docutils literal notranslate"><span class="pre">indirect</span></code> before the beginning of the enumeration to enable indirection for all of the enumeration’s cases that have an associated value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">indirect</span> <span class="k">enum</span> <span class="nv">ArithmeticExpression</span> {
</li><li> <span class="k">case</span> <span class="nv">number</span>(<span class="nv">Int</span>)
</li><li> <span class="k">case</span> <span class="nv">addition</span>(<span class="nv">ArithmeticExpression</span>, <span class="nv">ArithmeticExpression</span>)
</li><li> <span class="k">case</span> <span class="nv">multiplication</span>(<span class="nv">ArithmeticExpression</span>, <span class="nv">ArithmeticExpression</span>)
</li><li>}
</li></ol></div></div></div>
<p>This enumeration can store three kinds of arithmetic expressions: a plain number, the addition of two expressions, and the multiplication of two expressions. The <code class="docutils literal notranslate"><span class="pre">addition</span></code> and <code class="docutils literal notranslate"><span class="pre">multiplication</span></code> cases have associated values that are also arithmetic expressions—these associated values make it possible to nest expressions. For example, the expression <code class="docutils literal notranslate"><span class="pre">(5</span> <span class="pre">+</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">2</span></code> has a number on the right-hand side of the multiplication and another expression on the left-hand side of the multiplication. Because the data is nested, the enumeration used to store the data also needs to support nesting—this means the enumeration needs to be recursive. The code below shows the <code class="docutils literal notranslate"><span class="pre">ArithmeticExpression</span></code> recursive enumeration being created for <code class="docutils literal notranslate"><span class="pre">(5</span> <span class="pre">+</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">2</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">five</span> = <span class="nv">ArithmeticExpression</span>.<span class="nv">number</span>(<span class="m">5</span>)
</li><li><span class="k">let</span> <span class="nv">four</span> = <span class="nv">ArithmeticExpression</span>.<span class="nv">number</span>(<span class="m">4</span>)
</li><li><span class="k">let</span> <span class="nv">sum</span> = <span class="nv">ArithmeticExpression</span>.<span class="nv">addition</span>(<span class="nv">five</span>, <span class="nv">four</span>)
</li><li><span class="k">let</span> <span class="nv">product</span> = <span class="nv">ArithmeticExpression</span>.<span class="nv">multiplication</span>(<span class="nv">sum</span>, <span class="nv">ArithmeticExpression</span>.<span class="nv">number</span>(<span class="m">2</span>))
</li></ol></div></div></div>
<p>A recursive function is a straightforward way to work with data that has a recursive structure. For example, here’s a function that evaluates an arithmetic expression:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">evaluate</span>(<span class="k">_</span> <span class="nv">expression</span>: <span class="nc">ArithmeticExpression</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">switch</span> <span class="nv">expression</span> {
</li><li> <span class="k">case</span> <span class="k">let</span> .<span class="nv">number</span>(<span class="nv">value</span>):
</li><li> <span class="k">return</span> <span class="nv">value</span>
</li><li> <span class="k">case</span> <span class="k">let</span> .<span class="nv">addition</span>(<span class="nv">left</span>, <span class="nv">right</span>):
</li><li> <span class="k">return</span> <span class="nv">evaluate</span>(<span class="nv">left</span>) + <span class="nv">evaluate</span>(<span class="nv">right</span>)
</li><li> <span class="k">case</span> <span class="k">let</span> .<span class="nv">multiplication</span>(<span class="nv">left</span>, <span class="nv">right</span>):
</li><li> <span class="k">return</span> <span class="nv">evaluate</span>(<span class="nv">left</span>) * <span class="nv">evaluate</span>(<span class="nv">right</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="nv">print</span>(<span class="nv">evaluate</span>(<span class="nv">product</span>))
</li><li><span class="c">// Prints "18"</span>
</li></ol></div></div></div>
<p>This function evaluates a plain number by simply returning the associated value. It evaluates an addition or multiplication by evaluating the expression on the left-hand side, evaluating the expression on the right-hand side, and then adding them or multiplying them.</p>
</div>
</div><div class="section" id="structures-and-classes">
<h1>Structures and Classes<a class="headerlink" href="ClassesAndStructures.html#structures-and-classes" title="Permalink to this headline">¶</a></h1>
<p><em>Structures</em> and <em>classes</em> are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions.</p>
<p>Unlike other programming languages, Swift doesn’t require you to create separate interface and implementation files for custom structures and classes. In Swift, you define a structure or class in a single file, and the external interface to that class or structure is automatically made available for other code to use.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An instance of a class is traditionally known as an <em>object</em>. However, Swift structures and classes are much closer in functionality than in other languages, and much of this chapter describes functionality that applies to instances of <em>either</em> a class or a structure type. Because of this, the more general term <em>instance</em> is used.</p>
</div>
<div class="section" id="ID83">
<h2>Comparing Structures and Classes<a class="headerlink" href="ClassesAndStructures.html#ID83" title="Permalink to this headline">¶</a></h2>
<p>Structures and classes in Swift have many things in common. Both can:</p>
<ul class="simple">
<li>Define properties to store values</li>
<li>Define methods to provide functionality</li>
<li>Define subscripts to provide access to their values using subscript syntax</li>
<li>Define initializers to set up their initial state</li>
<li>Be extended to expand their functionality beyond a default implementation</li>
<li>Conform to protocols to provide standard functionality of a certain kind</li>
</ul>
<p>For more information, see <a class="reference internal" href="Properties.html"><span class="doc">Properties</span></a>, <a class="reference internal" href="Methods.html"><span class="doc">Methods</span></a>, <a class="reference internal" href="Subscripts.html"><span class="doc">Subscripts</span></a>, <a class="reference internal" href="Initialization.html"><span class="doc">Initialization</span></a>, <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>, and <a class="reference internal" href="Protocols.html"><span class="doc">Protocols</span></a>.</p>
<p>Classes have additional capabilities that structures don’t have:</p>
<ul class="simple">
<li>Inheritance enables one class to inherit the characteristics of another.</li>
<li>Type casting enables you to check and interpret the type of a class instance at runtime.</li>
<li>Deinitializers enable an instance of a class to free up any resources it has assigned.</li>
<li>Reference counting allows more than one reference to a class instance.</li>
</ul>
<p>For more information, see <a class="reference internal" href="Inheritance.html"><span class="doc">Inheritance</span></a>, <a class="reference internal" href="TypeCasting.html"><span class="doc">Type Casting</span></a>, <a class="reference internal" href="Deinitialization.html"><span class="doc">Deinitialization</span></a>, and <a class="reference internal" href="AutomaticReferenceCounting.html"><span class="doc">Automatic Reference Counting</span></a>.</p>
<p>The additional capabilities that classes support come at the cost of increased complexity. As a general guideline, prefer structures and enumerations because they’re easier to reason about, and use classes when they’re appropriate or necessary. In practice, this means most of the custom data types you define will be structures and enumerations. For a more detailed comparison, see <a class="reference external" href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes">Choosing Between Structures and Classes</a>.</p>
<div class="section" id="ID84">
<h3>Definition Syntax<a class="headerlink" href="ClassesAndStructures.html#ID84" title="Permalink to this headline">¶</a></h3>
<p>Structures and classes have a similar definition syntax. You introduce structures with the <code class="docutils literal notranslate"><span class="pre">struct</span></code> keyword and classes with the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword. Both place their entire definition within a pair of braces:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">SomeStructure</span> {
</li><li> <span class="c">// structure definition goes here</span>
</li><li>}
</li><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li> <span class="c">// class definition goes here</span>
</li><li>}
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Whenever you define a new structure or class, you define a new Swift type. Give types <code class="docutils literal notranslate"><span class="pre">UpperCamelCase</span></code> names (such as <code class="docutils literal notranslate"><span class="pre">SomeStructure</span></code> and <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code> here) to match the capitalization of standard Swift types (such as <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, and <code class="docutils literal notranslate"><span class="pre">Bool</span></code>). Give properties and methods <code class="docutils literal notranslate"><span class="pre">lowerCamelCase</span></code> names (such as <code class="docutils literal notranslate"><span class="pre">frameRate</span></code> and <code class="docutils literal notranslate"><span class="pre">incrementCount</span></code>) to differentiate them from type names.</p>
</div>
<p>Here’s an example of a structure definition and a class definition:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Resolution</span> {
</li><li> <span class="k">var</span> <span class="nv">width</span> = <span class="m">0</span>
</li><li> <span class="k">var</span> <span class="nv">height</span> = <span class="m">0</span>
</li><li>}
</li><li><span class="k">class</span> <span class="nv">VideoMode</span> {
</li><li> <span class="k">var</span> <span class="nv">resolution</span> = <span class="nv">Resolution</span>()
</li><li> <span class="k">var</span> <span class="nv">interlaced</span> = <span class="k">false</span>
</li><li> <span class="k">var</span> <span class="nv">frameRate</span> = <span class="m">0.0</span>
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>?
</li><li>}
</li></ol></div></div></div>
<p>The example above defines a new structure called <code class="docutils literal notranslate"><span class="pre">Resolution</span></code>, to describe a pixel-based display resolution. This structure has two stored properties called <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code>. Stored properties are constants or variables that are bundled up and stored as part of the structure or class. These two properties are inferred to be of type <code class="docutils literal notranslate"><span class="pre">Int</span></code> by setting them to an initial integer value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>The example above also defines a new class called <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>, to describe a specific video mode for video display. This class has four variable stored properties. The first, <code class="docutils literal notranslate"><span class="pre">resolution</span></code>, is initialized with a new <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> structure instance, which infers a property type of <code class="docutils literal notranslate"><span class="pre">Resolution</span></code>. For the other three properties, new <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> instances will be initialized with an <code class="docutils literal notranslate"><span class="pre">interlaced</span></code> setting of <code class="docutils literal notranslate"><span class="pre">false</span></code> (meaning “noninterlaced video”), a playback frame rate of <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, and an optional <code class="docutils literal notranslate"><span class="pre">String</span></code> value called <code class="docutils literal notranslate"><span class="pre">name</span></code>. The <code class="docutils literal notranslate"><span class="pre">name</span></code> property is automatically given a default value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, or “no <code class="docutils literal notranslate"><span class="pre">name</span></code> value”, because it’s of an optional type.</p>
</div>
<div class="section" id="ID85">
<h3>Structure and Class Instances<a class="headerlink" href="ClassesAndStructures.html#ID85" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> structure definition and the <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> class definition only describe what a <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> or <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> will look like. They themselves don’t describe a specific resolution or video mode. To do that, you need to create an instance of the structure or class.</p>
<p>The syntax for creating instances is very similar for both structures and classes:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someResolution</span> = <span class="nv">Resolution</span>()
</li><li><span class="k">let</span> <span class="nv">someVideoMode</span> = <span class="nv">VideoMode</span>()
</li></ol></div></div></div>
<p>Structures and classes both use initializer syntax for new instances. The simplest form of initializer syntax uses the type name of the class or structure followed by empty parentheses, such as <code class="docutils literal notranslate"><span class="pre">Resolution()</span></code> or <code class="docutils literal notranslate"><span class="pre">VideoMode()</span></code>. This creates a new instance of the class or structure, with any properties initialized to their default values. Class and structure initialization is described in more detail in <a class="reference internal" href="Initialization.html"><span class="doc">Initialization</span></a>.</p>
</div>
<div class="section" id="ID86">
<h3>Accessing Properties<a class="headerlink" href="ClassesAndStructures.html#ID86" title="Permalink to this headline">¶</a></h3>
<p>You can access the properties of an instance using <em>dot syntax</em>. In dot syntax, you write the property name immediately after the instance name, separated by a period (<code class="docutils literal notranslate"><span class="pre">.</span></code>), without any spaces:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"The width of someResolution is </span>\<span class="p">(</span><span class="nv">someResolution</span>.<span class="nv">width</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The width of someResolution is 0"</span>
</li></ol></div></div></div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">someResolution.width</span></code> refers to the <code class="docutils literal notranslate"><span class="pre">width</span></code> property of <code class="docutils literal notranslate"><span class="pre">someResolution</span></code>, and returns its default initial value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>You can drill down into subproperties, such as the <code class="docutils literal notranslate"><span class="pre">width</span></code> property in the <code class="docutils literal notranslate"><span class="pre">resolution</span></code> property of a <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"The width of someVideoMode is </span>\<span class="p">(</span><span class="nv">someVideoMode</span>.<span class="nv">resolution</span>.<span class="nv">width</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The width of someVideoMode is 0"</span>
</li></ol></div></div></div>
<p>You can also use dot syntax to assign a new value to a variable property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">someVideoMode</span>.<span class="nv">resolution</span>.<span class="nv">width</span> = <span class="m">1280</span>
</li><li><span class="nv">print</span>(<span class="s">"The width of someVideoMode is now </span>\<span class="p">(</span><span class="nv">someVideoMode</span>.<span class="nv">resolution</span>.<span class="nv">width</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The width of someVideoMode is now 1280"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID87">
<h3>Memberwise Initializers for Structure Types<a class="headerlink" href="ClassesAndStructures.html#ID87" title="Permalink to this headline">¶</a></h3>
<p>All structures have an automatically generated <em>memberwise initializer</em>, which you can use to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">vga</span> = <span class="nv">Resolution</span>(<span class="nv">width</span>: <span class="m">640</span>, <span class="nv">height</span>: <span class="m">480</span>)
</li></ol></div></div></div>
<p>Unlike structures, class instances don’t receive a default memberwise initializer. Initializers are described in more detail in <a class="reference internal" href="Initialization.html"><span class="doc">Initialization</span></a>.</p>
</div>
</div>
<div class="section" id="ID88">
<h2>Structures and Enumerations Are Value Types<a class="headerlink" href="ClassesAndStructures.html#ID88" title="Permalink to this headline">¶</a></h2>
<p>A <em>value type</em> is a type whose value is <em>copied</em> when it’s assigned to a variable or constant, or when it’s passed to a function.</p>
<p>You’ve actually been using value types extensively throughout the previous chapters. In fact, all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.</p>
<p>All structures and enumerations are value types in Swift. This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they are passed around in your code.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Collections defined by the standard library like arrays, dictionaries, and strings use an optimization to reduce the performance cost of copying. Instead of making a copy immediately, these collections share the memory where the elements are stored between the original instance and any copies. If one of the copies of the collection is modified, the elements are copied just before the modification. The behavior you see in your code is always as if a copy took place immediately.</p>
</div>
<p>Consider this example, which uses the <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> structure from the previous example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">hd</span> = <span class="nv">Resolution</span>(<span class="nv">width</span>: <span class="m">1920</span>, <span class="nv">height</span>: <span class="m">1080</span>)
</li><li><span class="k">var</span> <span class="nv">cinema</span> = <span class="nv">hd</span>
</li></ol></div></div></div>
<p>This example declares a constant called <code class="docutils literal notranslate"><span class="pre">hd</span></code> and sets it to a <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> instance initialized with the width and height of full HD video (1920 pixels wide by 1080 pixels high).</p>
<p>It then declares a variable called <code class="docutils literal notranslate"><span class="pre">cinema</span></code> and sets it to the current value of <code class="docutils literal notranslate"><span class="pre">hd</span></code>. Because <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> is a structure, a <em>copy</em> of the existing instance is made, and this new copy is assigned to <code class="docutils literal notranslate"><span class="pre">cinema</span></code>. Even though <code class="docutils literal notranslate"><span class="pre">hd</span></code> and <code class="docutils literal notranslate"><span class="pre">cinema</span></code> now have the same width and height, they are two completely different instances behind the scenes.</p>
<p>Next, the <code class="docutils literal notranslate"><span class="pre">width</span></code> property of <code class="docutils literal notranslate"><span class="pre">cinema</span></code> is amended to be the width of the slightly wider 2K standard used for digital cinema projection (2048 pixels wide and 1080 pixels high):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">cinema</span>.<span class="nv">width</span> = <span class="m">2048</span>
</li></ol></div></div></div>
<p>Checking the <code class="docutils literal notranslate"><span class="pre">width</span></code> property of <code class="docutils literal notranslate"><span class="pre">cinema</span></code> shows that it has indeed changed to be <code class="docutils literal notranslate"><span class="pre">2048</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"cinema is now </span>\<span class="p">(</span><span class="nv">cinema</span>.<span class="nv">width</span><span class="p">)</span><span class="s"> pixels wide"</span>)
</li><li><span class="c">// Prints "cinema is now 2048 pixels wide"</span>
</li></ol></div></div></div>
<p>However, the <code class="docutils literal notranslate"><span class="pre">width</span></code> property of the original <code class="docutils literal notranslate"><span class="pre">hd</span></code> instance still has the old value of <code class="docutils literal notranslate"><span class="pre">1920</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"hd is still </span>\<span class="p">(</span><span class="nv">hd</span>.<span class="nv">width</span><span class="p">)</span><span class="s"> pixels wide"</span>)
</li><li><span class="c">// Prints "hd is still 1920 pixels wide"</span>
</li></ol></div></div></div>
<p>When <code class="docutils literal notranslate"><span class="pre">cinema</span></code> was given the current value of <code class="docutils literal notranslate"><span class="pre">hd</span></code>, the <em>values</em> stored in <code class="docutils literal notranslate"><span class="pre">hd</span></code> were copied into the new <code class="docutils literal notranslate"><span class="pre">cinema</span></code> instance. The end result is two completely separate instances that contain the same numeric values. However, because they are separate instances, setting the width of <code class="docutils literal notranslate"><span class="pre">cinema</span></code> to <code class="docutils literal notranslate"><span class="pre">2048</span></code> doesn’t affect the width stored in <code class="docutils literal notranslate"><span class="pre">hd</span></code>, as shown in the figure below:</p>
<img alt="../_images/sharedStateStruct_2x.png" class="align-center" src="../_images/sharedStateStruct_2x.png" style="width: 650px;"/>
<p>The same behavior applies to enumerations:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">CompassPoint</span> {
</li><li> <span class="k">case</span> <span class="nv">north</span>, <span class="nv">south</span>, <span class="nv">east</span>, <span class="nv">west</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">turnNorth</span>() {
</li><li> <span class="k">self</span> = .<span class="nv">north</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">currentDirection</span> = <span class="nv">CompassPoint</span>.<span class="nv">west</span>
</li><li><span class="k">let</span> <span class="nv">rememberedDirection</span> = <span class="nv">currentDirection</span>
</li><li><span class="nv">currentDirection</span>.<span class="nv">turnNorth</span>()
</li><li>
</li><li><span class="nv">print</span>(<span class="s">"The current direction is </span>\<span class="p">(</span><span class="nv">currentDirection</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="nv">print</span>(<span class="s">"The remembered direction is </span>\<span class="p">(</span><span class="nv">rememberedDirection</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The current direction is north"</span>
</li><li><span class="c">// Prints "The remembered direction is west"</span>
</li></ol></div></div></div>
<p>When <code class="docutils literal notranslate"><span class="pre">rememberedDirection</span></code> is assigned the value of <code class="docutils literal notranslate"><span class="pre">currentDirection</span></code>, it’s actually set to a copy of that value. Changing the value of <code class="docutils literal notranslate"><span class="pre">currentDirection</span></code> thereafter doesn’t affect the copy of the original value that was stored in <code class="docutils literal notranslate"><span class="pre">rememberedDirection</span></code>.</p>
</div>
<div class="section" id="ID89">
<h2>Classes Are Reference Types<a class="headerlink" href="ClassesAndStructures.html#ID89" title="Permalink to this headline">¶</a></h2>
<p>Unlike value types, <em>reference types</em> are <em>not</em> copied when they are assigned to a variable or constant, or when they are passed to a function. Rather than a copy, a reference to the same existing instance is used.</p>
<p>Here’s an example, using the <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> class defined above:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">tenEighty</span> = <span class="nv">VideoMode</span>()
</li><li><span class="nv">tenEighty</span>.<span class="nv">resolution</span> = <span class="nv">hd</span>
</li><li><span class="nv">tenEighty</span>.<span class="nv">interlaced</span> = <span class="k">true</span>
</li><li><span class="nv">tenEighty</span>.<span class="nv">name</span> = <span class="s">"1080i"</span>
</li><li><span class="nv">tenEighty</span>.<span class="nv">frameRate</span> = <span class="m">25.0</span>
</li></ol></div></div></div>
<p>This example declares a new constant called <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and sets it to refer to a new instance of the <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> class. The video mode is assigned a copy of the HD resolution of <code class="docutils literal notranslate"><span class="pre">1920</span></code> by <code class="docutils literal notranslate"><span class="pre">1080</span></code> from before. It’s set to be interlaced, and is given a name of <code class="docutils literal notranslate"><span class="pre">"1080i"</span></code>. Finally, it’s set to a frame rate of <code class="docutils literal notranslate"><span class="pre">25.0</span></code> frames per second.</p>
<p>Next, <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> is assigned to a new constant, called <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>, and the frame rate of <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> is modified:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">alsoTenEighty</span> = <span class="nv">tenEighty</span>
</li><li><span class="nv">alsoTenEighty</span>.<span class="nv">frameRate</span> = <span class="m">30.0</span>
</li></ol></div></div></div>
<p>Because classes are reference types, <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> actually both refer to the <em>same</em> <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> instance. Effectively, they are just two different names for the same single instance, as shown in the figure below:</p>
<img alt="../_images/sharedStateClass_2x.png" class="align-center" src="../_images/sharedStateClass_2x.png" style="width: 670px;"/>
<p>Checking the <code class="docutils literal notranslate"><span class="pre">frameRate</span></code> property of <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> shows that it correctly reports the new frame rate of <code class="docutils literal notranslate"><span class="pre">30.0</span></code> from the underlying <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"The frameRate property of tenEighty is now </span>\<span class="p">(</span><span class="nv">tenEighty</span>.<span class="nv">frameRate</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The frameRate property of tenEighty is now 30.0"</span>
</li></ol></div></div></div>
<p>This example also shows how reference types can be harder to reason about. If <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> were far apart in your program’s code, it could be difficult to find all the ways that the video mode is changed. Wherever you use <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>, you also have to think about the code that uses <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>, and vice versa. In contrast, value types are easier to reason about because all of the code that interacts with the same value is close together in your source files.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> are declared as <em>constants</em>, rather than variables. However, you can still change <code class="docutils literal notranslate"><span class="pre">tenEighty.frameRate</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty.frameRate</span></code> because the values of the <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> constants themselves don’t actually change. <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> themselves don’t “store” the <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> instance—instead, they both <em>refer</em> to a <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> instance behind the scenes. It’s the <code class="docutils literal notranslate"><span class="pre">frameRate</span></code> property of the underlying <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> that is changed, not the values of the constant references to that <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>.</p>
<div class="section" id="ID90">
<h3>Identity Operators<a class="headerlink" href="ClassesAndStructures.html#ID90" title="Permalink to this headline">¶</a></h3>
<p>Because classes are reference types, it’s possible for multiple constants and variables to refer to the same single instance of a class behind the scenes. (The same isn’t true for structures and enumerations, because they are always copied when they are assigned to a constant or variable, or passed to a function.)</p>
<p>It can sometimes be useful to find out whether two constants or variables refer to exactly the same instance of a class. To enable this, Swift provides two identity operators:</p>
<ul class="simple">
<li>Identical to (<code class="docutils literal notranslate"><span class="pre">===</span></code>)</li>
<li>Not identical to (<code class="docutils literal notranslate"><span class="pre">!==</span></code>)</li>
</ul>
<p>Use these operators to check whether two constants or variables refer to the same single instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">tenEighty</span> === <span class="nv">alsoTenEighty</span> {
</li><li> <span class="nv">print</span>(<span class="s">"tenEighty and alsoTenEighty refer to the same VideoMode instance."</span>)
</li><li>}
</li><li><span class="c">// Prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."</span>
</li></ol></div></div></div>
<p>Note that <em>identical to</em> (represented by three equals signs, or <code class="docutils literal notranslate"><span class="pre">===</span></code>) doesn’t mean the same thing as <em>equal to</em> (represented by two equals signs, or <code class="docutils literal notranslate"><span class="pre">==</span></code>). <em>Identical to</em> means that two constants or variables of class type refer to exactly the same class instance. <em>Equal to</em> means that two instances are considered equal or equivalent in value, for some appropriate meaning of <em>equal</em>, as defined by the type’s designer.</p>
<p>When you define your own custom structures and classes, it’s your responsibility to decide what qualifies as two instances being equal. The process of defining your own implementations of the “equal to” and “not equal to” operators is described in <a class="reference internal" href="AdvancedOperators.html#ID45"><span class="std std-ref">Equivalence Operators</span></a>.</p>
</div>
<div class="section" id="ID91">
<h3>Pointers<a class="headerlink" href="ClassesAndStructures.html#ID91" title="Permalink to this headline">¶</a></h3>
<p>If you have experience with C, C++, or Objective-C, you may know that these languages use <em>pointers</em> to refer to addresses in memory. A Swift constant or variable that refers to an instance of some reference type is similar to a pointer in C, but isn’t a direct pointer to an address in memory, and doesn’t require you to write an asterisk (<code class="docutils literal notranslate"><span class="pre">*</span></code>) to indicate that you are creating a reference. Instead, these references are defined like any other constant or variable in Swift. The standard library provides pointer and buffer types that you can use if you need to interact with pointers directly—see <a class="reference external" href="https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management">Manual Memory Management</a>.</p>
</div>
</div>
</div><div class="section" id="properties">
<h1>Properties<a class="headerlink" href="Properties.html#properties" title="Permalink to this headline">¶</a></h1>
<p><em>Properties</em> associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures.</p>
<p>Stored and computed properties are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as type properties.</p>
<p>In addition, you can define property observers to monitor changes in a property’s value, which you can respond to with custom actions. Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.</p>
<div class="section" id="ID255">
<h2>Stored Properties<a class="headerlink" href="Properties.html#ID255" title="Permalink to this headline">¶</a></h2>
<p>In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure. Stored properties can be either <em>variable stored properties</em> (introduced by the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword) or <em>constant stored properties</em> (introduced by the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword).</p>
<p>You can provide a default value for a stored property as part of its definition, as described in <a class="reference internal" href="Initialization.html#ID206"><span class="std std-ref">Default Property Values</span></a>. You can also set and modify the initial value for a stored property during initialization. This is true even for constant stored properties, as described in <a class="reference internal" href="Initialization.html#ID212"><span class="std std-ref">Assigning Constant Properties During Initialization</span></a>.</p>
<p>The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">FixedLengthRange</span></code>, which describes a range of integers whose range length cannot be changed after it is created:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">FixedLengthRange</span> {
</li><li> <span class="k">var</span> <span class="nv">firstValue</span>: <span class="nc">Int</span>
</li><li> <span class="k">let</span> <span class="nv">length</span>: <span class="nc">Int</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">rangeOfThreeItems</span> = <span class="nv">FixedLengthRange</span>(<span class="nv">firstValue</span>: <span class="m">0</span>, <span class="nv">length</span>: <span class="m">3</span>)
</li><li><span class="c">// the range represents integer values 0, 1, and 2</span>
</li><li><span class="nv">rangeOfThreeItems</span>.<span class="nv">firstValue</span> = <span class="m">6</span>
</li><li><span class="c">// the range now represents integer values 6, 7, and 8</span>
</li></ol></div></div></div>
<p>Instances of <code class="docutils literal notranslate"><span class="pre">FixedLengthRange</span></code> have a variable stored property called <code class="docutils literal notranslate"><span class="pre">firstValue</span></code> and a constant stored property called <code class="docutils literal notranslate"><span class="pre">length</span></code>. In the example above, <code class="docutils literal notranslate"><span class="pre">length</span></code> is initialized when the new range is created and cannot be changed thereafter, because it is a constant property.</p>
<div class="section" id="ID256">
<h3>Stored Properties of Constant Structure Instances<a class="headerlink" href="Properties.html#ID256" title="Permalink to this headline">¶</a></h3>
<p>If you create an instance of a structure and assign that instance to a constant, you cannot modify the instance’s properties, even if they were declared as variable properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">rangeOfFourItems</span> = <span class="nv">FixedLengthRange</span>(<span class="nv">firstValue</span>: <span class="m">0</span>, <span class="nv">length</span>: <span class="m">4</span>)
</li><li><span class="c">// this range represents integer values 0, 1, 2, and 3</span>
</li><li><span class="nv">rangeOfFourItems</span>.<span class="nv">firstValue</span> = <span class="m">6</span>
</li><li><span class="c">// this will report an error, even though firstValue is a variable property</span>
</li></ol></div></div></div>
<p>Because <code class="docutils literal notranslate"><span class="pre">rangeOfFourItems</span></code> is declared as a constant (with the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword), it is not possible to change its <code class="docutils literal notranslate"><span class="pre">firstValue</span></code> property, even though <code class="docutils literal notranslate"><span class="pre">firstValue</span></code> is a variable property.</p>
<p>This behavior is due to structures being <em>value types</em>. When an instance of a value type is marked as a constant, so are all of its properties.</p>
<p>The same is not true for classes, which are <em>reference types</em>. If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties.</p>
</div>
<div class="section" id="ID257">
<h3>Lazy Stored Properties<a class="headerlink" href="Properties.html#ID257" title="Permalink to this headline">¶</a></h3>
<p>A <em>lazy stored property</em> is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier before its declaration.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You must always declare a lazy property as a variable (with the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword), because its initial value might not be retrieved until after instance initialization completes. Constant properties must always have a value <em>before</em> initialization completes, and therefore cannot be declared as lazy.</p>
</div>
<p>Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instance’s initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.</p>
<p>The example below uses a lazy stored property to avoid unnecessary initialization of a complex class. This example defines two classes called <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> and <code class="docutils literal notranslate"><span class="pre">DataManager</span></code>, neither of which is shown in full:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">DataImporter</span> {
</li><li> <span class="c">/*</span>
</li><li><span class="c">    DataImporter is a class to import data from an external file.</span>
</li><li><span class="c">    The class is assumed to take a nontrivial amount of time to initialize.</span>
</li><li><span class="c">    */</span>
</li><li> <span class="k">var</span> <span class="nv">filename</span> = <span class="s">"data.txt"</span>
</li><li> <span class="c">// the DataImporter class would provide data importing functionality here</span>
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">DataManager</span> {
</li><li> <span class="k">lazy</span> <span class="k">var</span> <span class="nv">importer</span> = <span class="nv">DataImporter</span>()
</li><li> <span class="k">var</span> <span class="nv">data</span> = [<span class="nv">String</span>]()
</li><li> <span class="c">// the DataManager class would provide data management functionality here</span>
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">manager</span> = <span class="nv">DataManager</span>()
</li><li><span class="nv">manager</span>.<span class="nv">data</span>.<span class="nv">append</span>(<span class="s">"Some data"</span>)
</li><li><span class="nv">manager</span>.<span class="nv">data</span>.<span class="nv">append</span>(<span class="s">"Some more data"</span>)
</li><li><span class="c">// the DataImporter instance for the importer property has not yet been created</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> class has a stored property called <code class="docutils literal notranslate"><span class="pre">data</span></code>, which is initialized with a new, empty array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values. Although the rest of its functionality is not shown, the purpose of this <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> class is to manage and provide access to this array of <code class="docutils literal notranslate"><span class="pre">String</span></code> data.</p>
<p>Part of the functionality of the <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> class is the ability to import data from a file. This functionality is provided by the <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> class, which is assumed to take a nontrivial amount of time to initialize. This might be because a <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> instance needs to open a file and read its contents into memory when the <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> instance is initialized.</p>
<p>It is possible for a <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> instance to manage its data without ever importing data from a file, so there is no need to create a new <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> instance when the <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> itself is created. Instead, it makes more sense to create the <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> instance if and when it is first used.</p>
<p>Because it is marked with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier, the <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> instance for the <code class="docutils literal notranslate"><span class="pre">importer</span></code> property is only created when the <code class="docutils literal notranslate"><span class="pre">importer</span></code> property is first accessed, such as when its <code class="docutils literal notranslate"><span class="pre">filename</span></code> property is queried:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="nv">manager</span>.<span class="nv">importer</span>.<span class="nv">filename</span>)
</li><li><span class="c">// the DataImporter instance for the importer property has now been created</span>
</li><li><span class="c">// Prints "data.txt"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a property marked with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.</p>
</div>
</div>
<div class="section" id="ID258">
<h3>Stored Properties and Instance Variables<a class="headerlink" href="Properties.html#ID258" title="Permalink to this headline">¶</a></h3>
<p>If you have experience with Objective-C, you may know that it provides <em>two</em> ways to store values and references as part of a class instance. In addition to properties, you can use instance variables as a backing store for the values stored in a property.</p>
<p>Swift unifies these concepts into a single property declaration. A Swift property does not have a corresponding instance variable, and the backing store for a property is not accessed directly. This approach avoids confusion about how the value is accessed in different contexts and simplifies the property’s declaration into a single, definitive statement. All information about the property—including its name, type, and memory management characteristics—is defined in a single location as part of the type’s definition.</p>
</div>
</div>
<div class="section" id="ID259">
<h2>Computed Properties<a class="headerlink" href="Properties.html#ID259" title="Permalink to this headline">¶</a></h2>
<p>In addition to stored properties, classes, structures, and enumerations can define <em>computed properties</em>, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li> <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Size</span> {
</li><li> <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Rect</span> {
</li><li> <span class="k">var</span> <span class="nv">origin</span> = <span class="nv">Point</span>()
</li><li> <span class="k">var</span> <span class="nv">size</span> = <span class="nv">Size</span>()
</li><li> <span class="k">var</span> <span class="nv">center</span>: <span class="nc">Point</span> {
</li><li> <span class="k">get</span> {
</li><li> <span class="k">let</span> <span class="nv">centerX</span> = <span class="nv">origin</span>.<span class="nv">x</span> + (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li> <span class="k">let</span> <span class="nv">centerY</span> = <span class="nv">origin</span>.<span class="nv">y</span> + (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li> <span class="k">return</span> <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">centerX</span>, <span class="nv">y</span>: <span class="nv">centerY</span>)
</li><li>        }
</li><li> <span class="k">set</span>(<span class="nv">newCenter</span>) {
</li><li> <span class="nv">origin</span>.<span class="nv">x</span> = <span class="nv">newCenter</span>.<span class="nv">x</span> - (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li> <span class="nv">origin</span>.<span class="nv">y</span> = <span class="nv">newCenter</span>.<span class="nv">y</span> - (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">square</span> = <span class="nv">Rect</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">0.0</span>, <span class="nv">y</span>: <span class="m">0.0</span>),
</li><li> <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">10.0</span>, <span class="nv">height</span>: <span class="m">10.0</span>))
</li><li><span class="k">let</span> <span class="nv">initialSquareCenter</span> = <span class="nv">square</span>.<span class="nv">center</span>
</li><li><span class="nv">square</span>.<span class="nv">center</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">15.0</span>, <span class="nv">y</span>: <span class="m">15.0</span>)
</li><li><span class="nv">print</span>(<span class="s">"square.origin is now at (</span>\<span class="p">(</span><span class="nv">square</span>.<span class="nv">origin</span>.<span class="nv">x</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">square</span>.<span class="nv">origin</span>.<span class="nv">y</span><span class="p">)</span><span class="s">)"</span>)
</li><li><span class="c">// Prints "square.origin is now at (10.0, 10.0)"</span>
</li></ol></div></div></div>
<p>This example defines three structures for working with geometric shapes:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Point</span></code> encapsulates the x- and y-coordinate of a point.</li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code> encapsulates a <code class="docutils literal notranslate"><span class="pre">width</span></code> and a <code class="docutils literal notranslate"><span class="pre">height</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">Rect</span></code> defines a rectangle by an origin point and a size.</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure also provides a computed property called <code class="docutils literal notranslate"><span class="pre">center</span></code>. The current center position of a <code class="docutils literal notranslate"><span class="pre">Rect</span></code> can always be determined from its <code class="docutils literal notranslate"><span class="pre">origin</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code>, and so you don’t need to store the center point as an explicit <code class="docutils literal notranslate"><span class="pre">Point</span></code> value. Instead, <code class="docutils literal notranslate"><span class="pre">Rect</span></code> defines a custom getter and setter for a computed variable called <code class="docutils literal notranslate"><span class="pre">center</span></code>, to enable you to work with the rectangle’s <code class="docutils literal notranslate"><span class="pre">center</span></code> as if it were a real stored property.</p>
<p>The example above creates a new <code class="docutils literal notranslate"><span class="pre">Rect</span></code> variable called <code class="docutils literal notranslate"><span class="pre">square</span></code>. The <code class="docutils literal notranslate"><span class="pre">square</span></code> variable is initialized with an origin point of <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>, and a width and height of <code class="docutils literal notranslate"><span class="pre">10</span></code>. This square is represented by the blue square in the diagram below.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">square</span></code> variable’s <code class="docutils literal notranslate"><span class="pre">center</span></code> property is then accessed through dot syntax (<code class="docutils literal notranslate"><span class="pre">square.center</span></code>), which causes the getter for <code class="docutils literal notranslate"><span class="pre">center</span></code> to be called, to retrieve the current property value. Rather than returning an existing value, the getter actually calculates and returns a new <code class="docutils literal notranslate"><span class="pre">Point</span></code> to represent the center of the square. As can be seen above, the getter correctly returns a center point of <code class="docutils literal notranslate"><span class="pre">(5,</span> <span class="pre">5)</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">center</span></code> property is then set to a new value of <code class="docutils literal notranslate"><span class="pre">(15,</span> <span class="pre">15)</span></code>, which moves the square up and to the right, to the new position shown by the orange square in the diagram below. Setting the <code class="docutils literal notranslate"><span class="pre">center</span></code> property calls the setter for <code class="docutils literal notranslate"><span class="pre">center</span></code>, which modifies the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> values of the stored <code class="docutils literal notranslate"><span class="pre">origin</span></code> property, and moves the square to its new position.</p>
<img alt="../_images/computedProperties_2x.png" class="align-center" src="../_images/computedProperties_2x.png" style="width: 388px;"/>
<div class="section" id="ID260">
<h3>Shorthand Setter Declaration<a class="headerlink" href="Properties.html#ID260" title="Permalink to this headline">¶</a></h3>
<p>If a computed property’s setter does not define a name for the new value to be set, a default name of <code class="docutils literal notranslate"><span class="pre">newValue</span></code> is used. Here’s an alternative version of the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure, which takes advantage of this shorthand notation:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">AlternativeRect</span> {
</li><li> <span class="k">var</span> <span class="nv">origin</span> = <span class="nv">Point</span>()
</li><li> <span class="k">var</span> <span class="nv">size</span> = <span class="nv">Size</span>()
</li><li> <span class="k">var</span> <span class="nv">center</span>: <span class="nc">Point</span> {
</li><li> <span class="k">get</span> {
</li><li> <span class="k">let</span> <span class="nv">centerX</span> = <span class="nv">origin</span>.<span class="nv">x</span> + (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li> <span class="k">let</span> <span class="nv">centerY</span> = <span class="nv">origin</span>.<span class="nv">y</span> + (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li> <span class="k">return</span> <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">centerX</span>, <span class="nv">y</span>: <span class="nv">centerY</span>)
</li><li>        }
</li><li> <span class="k">set</span> {
</li><li> <span class="nv">origin</span>.<span class="nv">x</span> = <span class="nv">newValue</span>.<span class="nv">x</span> - (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li> <span class="nv">origin</span>.<span class="nv">y</span> = <span class="nv">newValue</span>.<span class="nv">y</span> - (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID261">
<h3>Read-Only Computed Properties<a class="headerlink" href="Properties.html#ID261" title="Permalink to this headline">¶</a></h3>
<p>A computed property with a getter but no setter is known as a <em>read-only computed property</em>. A read-only computed property always returns a value, and can be accessed through dot syntax, but cannot be set to a different value.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You must declare computed properties—including read-only computed properties—as variable properties with the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword, because their value is not fixed. The <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword is only used for constant properties, to indicate that their values cannot be changed once they are set as part of instance initialization.</p>
</div>
<p>You can simplify the declaration of a read-only computed property by removing the <code class="docutils literal notranslate"><span class="pre">get</span></code> keyword and its braces:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Cuboid</span> {
</li><li> <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>, <span class="nv">depth</span> = <span class="m">0.0</span>
</li><li> <span class="k">var</span> <span class="nv">volume</span>: <span class="nc">Double</span> {
</li><li> <span class="k">return</span> <span class="nv">width</span> * <span class="nv">height</span> * <span class="nv">depth</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">fourByFiveByTwo</span> = <span class="nv">Cuboid</span>(<span class="nv">width</span>: <span class="m">4.0</span>, <span class="nv">height</span>: <span class="m">5.0</span>, <span class="nv">depth</span>: <span class="m">2.0</span>)
</li><li><span class="nv">print</span>(<span class="s">"the volume of fourByFiveByTwo is </span>\<span class="p">(</span><span class="nv">fourByFiveByTwo</span>.<span class="nv">volume</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "the volume of fourByFiveByTwo is 40.0"</span>
</li></ol></div></div></div>
<p>This example defines a new structure called <code class="docutils literal notranslate"><span class="pre">Cuboid</span></code>, which represents a 3D rectangular box with <code class="docutils literal notranslate"><span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code>, and <code class="docutils literal notranslate"><span class="pre">depth</span></code> properties. This structure also has a read-only computed property called <code class="docutils literal notranslate"><span class="pre">volume</span></code>, which calculates and returns the current volume of the cuboid. It doesn’t make sense for <code class="docutils literal notranslate"><span class="pre">volume</span></code> to be settable, because it would be ambiguous as to which values of <code class="docutils literal notranslate"><span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code>, and <code class="docutils literal notranslate"><span class="pre">depth</span></code> should be used for a particular <code class="docutils literal notranslate"><span class="pre">volume</span></code> value. Nonetheless, it is useful for a <code class="docutils literal notranslate"><span class="pre">Cuboid</span></code> to provide a read-only computed property to enable external users to discover its current calculated volume.</p>
</div>
</div>
<div class="section" id="ID262">
<h2>Property Observers<a class="headerlink" href="Properties.html#ID262" title="Permalink to this headline">¶</a></h2>
<p>Property observers observe and respond to changes in a property’s value. Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</p>
<p>You can add property observers to any stored properties you define, except for lazy stored properties. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass. You don’t need to define property observers for nonoverridden computed properties, because you can observe and respond to changes to their value in the computed property’s setter. Property overriding is described in <a class="reference internal" href="Inheritance.html#ID196"><span class="std std-ref">Overriding</span></a>.</p>
<p>You have the option to define either or both of these observers on a property:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">willSet</span></code> is called just before the value is stored.</li>
<li><code class="docutils literal notranslate"><span class="pre">didSet</span></code> is called immediately after the new value is stored.</li>
</ul>
<p>If you implement a <code class="docutils literal notranslate"><span class="pre">willSet</span></code> observer, it’s passed the new property value as a constant parameter. You can specify a name for this parameter as part of your <code class="docutils literal notranslate"><span class="pre">willSet</span></code> implementation. If you don’t write the parameter name and parentheses within your implementation, the parameter is made available with a default parameter name of <code class="docutils literal notranslate"><span class="pre">newValue</span></code>.</p>
<p>Similarly, if you implement a <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer, it’s passed a constant parameter containing the old property value. You can name the parameter or use the default parameter name of <code class="docutils literal notranslate"><span class="pre">oldValue</span></code>. If you assign a value to a property within its own <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer, the new value that you assign replaces the one that was just set.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called. They are not called while a class is setting its own properties, before the superclass initializer has been called.</p>
<p class="last">For more information about initializer delegation, see <a class="reference internal" href="Initialization.html#ID215"><span class="std std-ref">Initializer Delegation for Value Types</span></a> and <a class="reference internal" href="Initialization.html#ID219"><span class="std std-ref">Initializer Delegation for Class Types</span></a>.</p>
</div>
<p>Here’s an example of <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> in action. The example below defines a new class called <code class="docutils literal notranslate"><span class="pre">StepCounter</span></code>, which tracks the total number of steps that a person takes while walking. This class might be used with input data from a pedometer or other step counter to keep track of a person’s exercise during their daily routine.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">StepCounter</span> {
</li><li> <span class="k">var</span> <span class="nv">totalSteps</span>: <span class="nc">Int</span> = <span class="m">0</span> {
</li><li> <span class="k">willSet</span>(<span class="nv">newTotalSteps</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"About to set totalSteps to </span>\<span class="p">(</span><span class="nv">newTotalSteps</span><span class="p">)</span><span class="s">"</span>)
</li><li>        }
</li><li> <span class="k">didSet</span> {
</li><li> <span class="k">if</span> <span class="nv">totalSteps</span> &gt; <span class="nv">oldValue</span>  {
</li><li> <span class="nv">print</span>(<span class="s">"Added </span>\<span class="p">(</span><span class="nv">totalSteps</span> - <span class="nv">oldValue</span><span class="p">)</span><span class="s"> steps"</span>)
</li><li>            }
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">stepCounter</span> = <span class="nv">StepCounter</span>()
</li><li><span class="nv">stepCounter</span>.<span class="nv">totalSteps</span> = <span class="m">200</span>
</li><li><span class="c">// About to set totalSteps to 200</span>
</li><li><span class="c">// Added 200 steps</span>
</li><li><span class="nv">stepCounter</span>.<span class="nv">totalSteps</span> = <span class="m">360</span>
</li><li><span class="c">// About to set totalSteps to 360</span>
</li><li><span class="c">// Added 160 steps</span>
</li><li><span class="nv">stepCounter</span>.<span class="nv">totalSteps</span> = <span class="m">896</span>
</li><li><span class="c">// About to set totalSteps to 896</span>
</li><li><span class="c">// Added 536 steps</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">StepCounter</span></code> class declares a <code class="docutils literal notranslate"><span class="pre">totalSteps</span></code> property of type <code class="docutils literal notranslate"><span class="pre">Int</span></code>. This is a stored property with <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers for <code class="docutils literal notranslate"><span class="pre">totalSteps</span></code> are called whenever the property is assigned a new value. This is true even if the new value is the same as the current value.</p>
<p>This example’s <code class="docutils literal notranslate"><span class="pre">willSet</span></code> observer uses a custom parameter name of <code class="docutils literal notranslate"><span class="pre">newTotalSteps</span></code> for the upcoming new value. In this example, it simply prints out the value that is about to be set.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer is called after the value of <code class="docutils literal notranslate"><span class="pre">totalSteps</span></code> is updated. It compares the new value of <code class="docutils literal notranslate"><span class="pre">totalSteps</span></code> against the old value. If the total number of steps has increased, a message is printed to indicate how many new steps have been taken. The <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer does not provide a custom parameter name for the old value, and the default name of <code class="docutils literal notranslate"><span class="pre">oldValue</span></code> is used instead.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you pass a property that has observers to a function as an in-out parameter, the <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers are always called. This is because of the copy-in copy-out memory model for in-out parameters: The value is always written back to the property at the end of the function. For a detailed discussion of the behavior of in-out parameters, see <a class="reference internal" href="../ReferenceManual/Declarations.html#ID545"><span class="std std-ref">In-Out Parameters</span></a>.</p>
</div>
</div>
<div class="section" id="ID263">
<h2>Global and Local Variables<a class="headerlink" href="Properties.html#ID263" title="Permalink to this headline">¶</a></h2>
<p>The capabilities described above for computing and observing properties are also available to <em>global variables</em> and <em>local variables</em>. Global variables are variables that are defined outside of any function, method, closure, or type context. Local variables are variables that are defined within a function, method, or closure context.</p>
<p>The global and local variables you have encountered in previous chapters have all been <em>stored variables</em>. Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved.</p>
<p>However, you can also define <em>computed variables</em> and define observers for stored variables, in either a global or local scope. Computed variables calculate their value, rather than storing it, and they are written in the same way as computed properties.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Global constants and variables are always computed lazily, in a similar manner to <a class="reference internal" href="Properties.html#ID257"><span class="std std-ref">Lazy Stored Properties</span></a>. Unlike lazy stored properties, global constants and variables do not need to be marked with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier.</p>
<p class="last">Local constants and variables are never computed lazily.</p>
</div>
</div>
<div class="section" id="ID264">
<h2>Type Properties<a class="headerlink" href="Properties.html#ID264" title="Permalink to this headline">¶</a></h2>
<p>Instance properties are properties that belong to an instance of a particular type. Every time you create a new instance of that type, it has its own set of property values, separate from any other instance.</p>
<p>You can also define properties that belong to the type itself, not to any one instance of that type. There will only ever be one copy of these properties, no matter how many instances of that type you create. These kinds of properties are called <em>type properties</em>.</p>
<p>Type properties are useful for defining values that are universal to <em>all</em> instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that is global to all instances of that type (like a static variable in C).</p>
<p>Stored type properties can be variables or constants. Computed type properties are always declared as variable properties, in the same way as computed instance properties.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</p>
<p class="last">Stored type properties are lazily initialized on their first access. They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier.</p>
</div>
<div class="section" id="ID265">
<h3>Type Property Syntax<a class="headerlink" href="Properties.html#ID265" title="Permalink to this headline">¶</a></h3>
<p>In C and Objective-C, you define static constants and variables associated with a type as <em>global</em> static variables. In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.</p>
<p>You define type properties with the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword. For computed type properties for class types, you can use the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword instead to allow subclasses to override the superclass’s implementation. The example below shows the syntax for stored and computed type properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">SomeStructure</span> {
</li><li> <span class="k">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> = <span class="s">"Some value."</span>
</li><li> <span class="k">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span>: <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="m">1</span>
</li><li>    }
</li><li>}
</li><li><span class="k">enum</span> <span class="nv">SomeEnumeration</span> {
</li><li> <span class="k">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> = <span class="s">"Some value."</span>
</li><li> <span class="k">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span>: <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="m">6</span>
</li><li>    }
</li><li>}
</li><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li> <span class="k">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> = <span class="s">"Some value."</span>
</li><li> <span class="k">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span>: <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="m">27</span>
</li><li>    }
</li><li> <span class="k">class</span> <span class="k">var</span> <span class="nv">overrideableComputedTypeProperty</span>: <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="m">107</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The computed type property examples above are for read-only computed type properties, but you can also define read-write computed type properties with the same syntax as for computed instance properties.</p>
</div>
</div>
<div class="section" id="ID266">
<h3>Querying and Setting Type Properties<a class="headerlink" href="Properties.html#ID266" title="Permalink to this headline">¶</a></h3>
<p>Type properties are queried and set with dot syntax, just like instance properties. However, type properties are queried and set on the <em>type</em>, not on an instance of that type. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="nv">SomeStructure</span>.<span class="nv">storedTypeProperty</span>)
</li><li><span class="c">// Prints "Some value."</span>
</li><li><span class="nv">SomeStructure</span>.<span class="nv">storedTypeProperty</span> = <span class="s">"Another value."</span>
</li><li><span class="nv">print</span>(<span class="nv">SomeStructure</span>.<span class="nv">storedTypeProperty</span>)
</li><li><span class="c">// Prints "Another value."</span>
</li><li><span class="nv">print</span>(<span class="nv">SomeEnumeration</span>.<span class="nv">computedTypeProperty</span>)
</li><li><span class="c">// Prints "6"</span>
</li><li><span class="nv">print</span>(<span class="nv">SomeClass</span>.<span class="nv">computedTypeProperty</span>)
</li><li><span class="c">// Prints "27"</span>
</li></ol></div></div></div>
<p>The examples that follow use two stored type properties as part of a structure that models an audio level meter for a number of audio channels. Each channel has an integer audio level between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">10</span></code> inclusive.</p>
<p>The figure below illustrates how two of these audio channels can be combined to model a stereo audio level meter. When a channel’s audio level is <code class="docutils literal notranslate"><span class="pre">0</span></code>, none of the lights for that channel are lit. When the audio level is <code class="docutils literal notranslate"><span class="pre">10</span></code>, all of the lights for that channel are lit. In this figure, the left channel has a current level of <code class="docutils literal notranslate"><span class="pre">9</span></code>, and the right channel has a current level of <code class="docutils literal notranslate"><span class="pre">7</span></code>:</p>
<img alt="../_images/staticPropertiesVUMeter_2x.png" class="align-center" src="../_images/staticPropertiesVUMeter_2x.png" style="width: 243px;"/>
<p>The audio channels described above are represented by instances of the <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> structure:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">AudioChannel</span> {
</li><li> <span class="k">static</span> <span class="k">let</span> <span class="nv">thresholdLevel</span> = <span class="m">10</span>
</li><li> <span class="k">static</span> <span class="k">var</span> <span class="nv">maxInputLevelForAllChannels</span> = <span class="m">0</span>
</li><li> <span class="k">var</span> <span class="nv">currentLevel</span>: <span class="nc">Int</span> = <span class="m">0</span> {
</li><li> <span class="k">didSet</span> {
</li><li> <span class="k">if</span> <span class="nv">currentLevel</span> &gt; <span class="nv">AudioChannel</span>.<span class="nv">thresholdLevel</span> {
</li><li> <span class="c">// cap the new audio level to the threshold level</span>
</li><li> <span class="nv">currentLevel</span> = <span class="nv">AudioChannel</span>.<span class="nv">thresholdLevel</span>
</li><li>            }
</li><li> <span class="k">if</span> <span class="nv">currentLevel</span> &gt; <span class="nv">AudioChannel</span>.<span class="nv">maxInputLevelForAllChannels</span> {
</li><li> <span class="c">// store this as the new overall maximum input level</span>
</li><li> <span class="nv">AudioChannel</span>.<span class="nv">maxInputLevelForAllChannels</span> = <span class="nv">currentLevel</span>
</li><li>            }
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> structure defines two stored type properties to support its functionality. The first, <code class="docutils literal notranslate"><span class="pre">thresholdLevel</span></code>, defines the maximum threshold value an audio level can take. This is a constant value of <code class="docutils literal notranslate"><span class="pre">10</span></code> for all <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> instances. If an audio signal comes in with a higher value than <code class="docutils literal notranslate"><span class="pre">10</span></code>, it will be capped to this threshold value (as described below).</p>
<p>The second type property is a variable stored property called <code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code>. This keeps track of the maximum input value that has been received by <em>any</em> <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> instance. It starts with an initial value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> structure also defines a stored instance property called <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>, which represents the channel’s current audio level on a scale of <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">10</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> property has a <code class="docutils literal notranslate"><span class="pre">didSet</span></code> property observer to check the value of <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> whenever it is set. This observer performs two checks:</p>
<ul class="simple">
<li>If the new value of <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> is greater than the allowed <code class="docutils literal notranslate"><span class="pre">thresholdLevel</span></code>, the property observer caps <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> to <code class="docutils literal notranslate"><span class="pre">thresholdLevel</span></code>.</li>
<li>If the new value of <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> (after any capping) is higher than any value previously received by <em>any</em> <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> instance, the property observer stores the new <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> value in the <code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code> type property.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the first of these two checks, the <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer sets <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> to a different value. This does not, however, cause the observer to be called again.</p>
</div>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> structure to create two new audio channels called <code class="docutils literal notranslate"><span class="pre">leftChannel</span></code> and <code class="docutils literal notranslate"><span class="pre">rightChannel</span></code>, to represent the audio levels of a stereo sound system:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">leftChannel</span> = <span class="nv">AudioChannel</span>()
</li><li><span class="k">var</span> <span class="nv">rightChannel</span> = <span class="nv">AudioChannel</span>()
</li></ol></div></div></div>
<p>If you set the <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> of the <em>left</em> channel to <code class="docutils literal notranslate"><span class="pre">7</span></code>, you can see that the <code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code> type property is updated to equal <code class="docutils literal notranslate"><span class="pre">7</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">leftChannel</span>.<span class="nv">currentLevel</span> = <span class="m">7</span>
</li><li><span class="nv">print</span>(<span class="nv">leftChannel</span>.<span class="nv">currentLevel</span>)
</li><li><span class="c">// Prints "7"</span>
</li><li><span class="nv">print</span>(<span class="nv">AudioChannel</span>.<span class="nv">maxInputLevelForAllChannels</span>)
</li><li><span class="c">// Prints "7"</span>
</li></ol></div></div></div>
<p>If you try to set the <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> of the <em>right</em> channel to <code class="docutils literal notranslate"><span class="pre">11</span></code>, you can see that the right channel’s <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> property is capped to the maximum value of <code class="docutils literal notranslate"><span class="pre">10</span></code>, and the <code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code> type property is updated to equal <code class="docutils literal notranslate"><span class="pre">10</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">rightChannel</span>.<span class="nv">currentLevel</span> = <span class="m">11</span>
</li><li><span class="nv">print</span>(<span class="nv">rightChannel</span>.<span class="nv">currentLevel</span>)
</li><li><span class="c">// Prints "10"</span>
</li><li><span class="nv">print</span>(<span class="nv">AudioChannel</span>.<span class="nv">maxInputLevelForAllChannels</span>)
</li><li><span class="c">// Prints "10"</span>
</li></ol></div></div></div>
</div>
</div>
</div><div class="section" id="methods">
<h1>Methods<a class="headerlink" href="Methods.html#methods" title="Permalink to this headline">¶</a></h1>
<p><em>Methods</em> are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C.</p>
<p>The fact that structures and enumerations can define methods in Swift is a major difference from C and Objective-C. In Objective-C, classes are the only types that can define methods. In Swift, you can choose whether to define a class, structure, or enumeration, and still have the flexibility to define methods on the type you create.</p>
<div class="section" id="ID235">
<h2>Instance Methods<a class="headerlink" href="Methods.html#ID235" title="Permalink to this headline">¶</a></h2>
<p><em>Instance methods</em> are functions that belong to instances of a particular class, structure, or enumeration. They support the functionality of those instances, either by providing ways to access and modify instance properties, or by providing functionality related to the instance’s purpose. Instance methods have exactly the same syntax as functions, as described in <a class="reference internal" href="Functions.html"><span class="doc">Functions</span></a>.</p>
<p>You write an instance method within the opening and closing braces of the type it belongs to. An instance method has implicit access to all other instance methods and properties of that type. An instance method can be called only on a specific instance of the type it belongs to. It cannot be called in isolation without an existing instance.</p>
<p>Here’s an example that defines a simple <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class, which can be used to count the number of times an action occurs:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Counter</span> {
</li><li> <span class="k">var</span> <span class="nv">count</span> = <span class="m">0</span>
</li><li> <span class="k">func</span> <span class="nv">increment</span>() {
</li><li> <span class="nv">count</span> += <span class="m">1</span>
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">increment</span>(<span class="nv">by</span> <span class="nv">amount</span>: <span class="nc">Int</span>) {
</li><li> <span class="nv">count</span> += <span class="nv">amount</span>
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">reset</span>() {
</li><li> <span class="nv">count</span> = <span class="m">0</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class defines three instance methods:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">increment()</span></code> increments the counter by <code class="docutils literal notranslate"><span class="pre">1</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">increment(by:</span> <span class="pre">Int)</span></code> increments the counter by a specified integer amount.</li>
<li><code class="docutils literal notranslate"><span class="pre">reset()</span></code> resets the counter to zero.</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class also declares a variable property, <code class="docutils literal notranslate"><span class="pre">count</span></code>, to keep track of the current counter value.</p>
<p>You call instance methods with the same dot syntax as properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">counter</span> = <span class="nv">Counter</span>()
</li><li><span class="c">// the initial counter value is 0</span>
</li><li><span class="nv">counter</span>.<span class="nv">increment</span>()
</li><li><span class="c">// the counter's value is now 1</span>
</li><li><span class="nv">counter</span>.<span class="nv">increment</span>(<span class="nv">by</span>: <span class="m">5</span>)
</li><li><span class="c">// the counter's value is now 6</span>
</li><li><span class="nv">counter</span>.<span class="nv">reset</span>()
</li><li><span class="c">// the counter's value is now 0</span>
</li></ol></div></div></div>
<p>Function parameters can have both a name (for use within the function’s body) and an argument label (for use when calling the function), as described in <a class="reference internal" href="Functions.html#ID166"><span class="std std-ref">Function Argument Labels and Parameter Names</span></a>. The same is true for method parameters, because methods are just functions that are associated with a type.</p>
<div class="section" id="ID238">
<h3>The self Property<a class="headerlink" href="Methods.html#ID238" title="Permalink to this headline">¶</a></h3>
<p>Every instance of a type has an implicit property called <code class="docutils literal notranslate"><span class="pre">self</span></code>, which is exactly equivalent to the instance itself. You use the <code class="docutils literal notranslate"><span class="pre">self</span></code> property to refer to the current instance within its own instance methods.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">increment()</span></code> method in the example above could have been written like this:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">increment</span>() {
</li><li> <span class="k">self</span>.<span class="nv">count</span> += <span class="m">1</span>
</li><li>}
</li></ol></div></div></div>
<p>In practice, you don’t need to write <code class="docutils literal notranslate"><span class="pre">self</span></code> in your code very often. If you don’t explicitly write <code class="docutils literal notranslate"><span class="pre">self</span></code>, Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method. This assumption is demonstrated by the use of <code class="docutils literal notranslate"><span class="pre">count</span></code> (rather than <code class="docutils literal notranslate"><span class="pre">self.count</span></code>) inside the three instance methods for <code class="docutils literal notranslate"><span class="pre">Counter</span></code>.</p>
<p>The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance. In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way. You use the <code class="docutils literal notranslate"><span class="pre">self</span></code> property to distinguish between the parameter name and the property name.</p>
<p>Here, <code class="docutils literal notranslate"><span class="pre">self</span></code> disambiguates between a method parameter called <code class="docutils literal notranslate"><span class="pre">x</span></code> and an instance property that is also called <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li> <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li> <span class="k">func</span> <span class="nv">isToTheRightOf</span>(<span class="nv">x</span>: <span class="nc">Double</span>) -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">return</span> <span class="k">self</span>.<span class="nv">x</span> &gt; <span class="nv">x</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">somePoint</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">4.0</span>, <span class="nv">y</span>: <span class="m">5.0</span>)
</li><li><span class="k">if</span> <span class="nv">somePoint</span>.<span class="nv">isToTheRightOf</span>(<span class="nv">x</span>: <span class="m">1.0</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"This point is to the right of the line where x == 1.0"</span>)
</li><li>}
</li><li><span class="c">// Prints "This point is to the right of the line where x == 1.0"</span>
</li></ol></div></div></div>
<p>Without the <code class="docutils literal notranslate"><span class="pre">self</span></code> prefix, Swift would assume that both uses of <code class="docutils literal notranslate"><span class="pre">x</span></code> referred to the method parameter called <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</div>
<div class="section" id="ID239">
<h3>Modifying Value Types from Within Instance Methods<a class="headerlink" href="Methods.html#ID239" title="Permalink to this headline">¶</a></h3>
<p>Structures and enumerations are <em>value types</em>. By default, the properties of a value type cannot be modified from within its instance methods.</p>
<p>However, if you need to modify the properties of your structure or enumeration within a particular method, you can opt in to <em>mutating</em> behavior for that method. The method can then mutate (that is, change) its properties from within the method, and any changes that it makes are written back to the original structure when the method ends. The method can also assign a completely new instance to its implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> property, and this new instance will replace the existing one when the method ends.</p>
<p>You can opt in to this behavior by placing the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword before the <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword for that method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li> <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">moveBy</span>(<span class="nv">x</span> <span class="nv">deltaX</span>: <span class="nc">Double</span>, <span class="nv">y</span> <span class="nv">deltaY</span>: <span class="nc">Double</span>) {
</li><li> <span class="nv">x</span> += <span class="nv">deltaX</span>
</li><li> <span class="nv">y</span> += <span class="nv">deltaY</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">somePoint</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">1.0</span>)
</li><li><span class="nv">somePoint</span>.<span class="nv">moveBy</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li><li><span class="nv">print</span>(<span class="s">"The point is now at (</span>\<span class="p">(</span><span class="nv">somePoint</span>.<span class="nv">x</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">somePoint</span>.<span class="nv">y</span><span class="p">)</span><span class="s">)"</span>)
</li><li><span class="c">// Prints "The point is now at (3.0, 4.0)"</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Point</span></code> structure above defines a mutating <code class="docutils literal notranslate"><span class="pre">moveBy(x:y:)</span></code> method, which moves a <code class="docutils literal notranslate"><span class="pre">Point</span></code> instance by a certain amount. Instead of returning a new point, this method actually modifies the point on which it is called. The <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword is added to its definition to enable it to modify its properties.</p>
<p>Note that you cannot call a mutating method on a constant of structure type, because its properties cannot be changed, even if they are variable properties, as described in <a class="reference internal" href="Properties.html#ID256"><span class="std std-ref">Stored Properties of Constant Structure Instances</span></a>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">fixedPoint</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li><li><span class="nv">fixedPoint</span>.<span class="nv">moveBy</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li><li><span class="c">// this will report an error</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID240">
<h3>Assigning to self Within a Mutating Method<a class="headerlink" href="Methods.html#ID240" title="Permalink to this headline">¶</a></h3>
<p>Mutating methods can assign an entirely new instance to the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> property. The <code class="docutils literal notranslate"><span class="pre">Point</span></code> example shown above could have been written in the following way instead:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li> <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">moveBy</span>(<span class="nv">x</span> <span class="nv">deltaX</span>: <span class="nc">Double</span>, <span class="nv">y</span> <span class="nv">deltaY</span>: <span class="nc">Double</span>) {
</li><li> <span class="k">self</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">x</span> + <span class="nv">deltaX</span>, <span class="nv">y</span>: <span class="nv">y</span> + <span class="nv">deltaY</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This version of the mutating <code class="docutils literal notranslate"><span class="pre">moveBy(x:y:)</span></code> method creates a new structure whose <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> values are set to the target location. The end result of calling this alternative version of the method will be exactly the same as for calling the earlier version.</p>
<p>Mutating methods for enumerations can set the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter to be a different case from the same enumeration:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">TriStateSwitch</span> {
</li><li> <span class="k">case</span> <span class="nv">off</span>, <span class="nv">low</span>, <span class="nv">high</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">next</span>() {
</li><li> <span class="k">switch</span> <span class="k">self</span> {
</li><li> <span class="k">case</span> .<span class="nv">off</span>:
</li><li> <span class="k">self</span> = .<span class="nv">low</span>
</li><li> <span class="k">case</span> .<span class="nv">low</span>:
</li><li> <span class="k">self</span> = .<span class="nv">high</span>
</li><li> <span class="k">case</span> .<span class="nv">high</span>:
</li><li> <span class="k">self</span> = .<span class="nv">off</span>
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">ovenLight</span> = <span class="nv">TriStateSwitch</span>.<span class="nv">low</span>
</li><li><span class="nv">ovenLight</span>.<span class="nv">next</span>()
</li><li><span class="c">// ovenLight is now equal to .high</span>
</li><li><span class="nv">ovenLight</span>.<span class="nv">next</span>()
</li><li><span class="c">// ovenLight is now equal to .off</span>
</li></ol></div></div></div>
<p>This example defines an enumeration for a three-state switch. The switch cycles between three different power states (<code class="docutils literal notranslate"><span class="pre">off</span></code>, <code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code>) every time its <code class="docutils literal notranslate"><span class="pre">next()</span></code> method is called.</p>
</div>
</div>
<div class="section" id="ID241">
<h2>Type Methods<a class="headerlink" href="Methods.html#ID241" title="Permalink to this headline">¶</a></h2>
<p>Instance methods, as described above, are methods that are called on an instance of a particular type. You can also define methods that are called on the type itself. These kinds of methods are called <em>type methods</em>. You indicate type methods by writing the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword before the method’s <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword. Classes may also use the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword to allow subclasses to override the superclass’s implementation of that method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Objective-C, you can define type-level methods only for Objective-C classes. In Swift, you can define type-level methods for all classes, structures, and enumerations. Each type method is explicitly scoped to the type it supports.</p>
</div>
<p>Type methods are called with dot syntax, like instance methods. However, you call type methods on the type, not on an instance of that type. Here’s how you call a type method on a class called <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li> <span class="k">class</span> <span class="k">func</span> <span class="nv">someTypeMethod</span>() {
</li><li> <span class="c">// type method implementation goes here</span>
</li><li>    }
</li><li>}
</li><li><span class="nv">SomeClass</span>.<span class="nv">someTypeMethod</span>()
</li></ol></div></div></div>
<p>Within the body of a type method, the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> property refers to the type itself, rather than an instance of that type. This means that you can use <code class="docutils literal notranslate"><span class="pre">self</span></code> to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters.</p>
<p>More generally, any unqualified method and property names that you use within the body of a type method will refer to other type-level methods and properties. A type method can call another type method with the other method’s name, without needing to prefix it with the type name. Similarly, type methods on structures and enumerations can access type properties by using the type property’s name without a type name prefix.</p>
<p>The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code>, which tracks a player’s progress through the different levels or stages of a game. It is a single-player game, but can store information for multiple players on a single device.</p>
<p>All of the game’s levels (apart from level one) are locked when the game is first played. Every time a player finishes a level, that level is unlocked for all players on the device. The <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> structure uses type properties and methods to keep track of which levels of the game have been unlocked. It also tracks the current level for an individual player.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">LevelTracker</span> {
</li><li> <span class="k">static</span> <span class="k">var</span> <span class="nv">highestUnlockedLevel</span> = <span class="m">1</span>
</li><li> <span class="k">var</span> <span class="nv">currentLevel</span> = <span class="m">1</span>
</li><li>
</li><li> <span class="k">static</span> <span class="k">func</span> <span class="nv">unlock</span>(<span class="k">_</span> <span class="nv">level</span>: <span class="nc">Int</span>) {
</li><li> <span class="k">if</span> <span class="nv">level</span> &gt; <span class="nv">highestUnlockedLevel</span> { <span class="nv">highestUnlockedLevel</span> = <span class="nv">level</span> }
</li><li>    }
</li><li>
</li><li> <span class="k">static</span> <span class="k">func</span> <span class="nv">isUnlocked</span>(<span class="k">_</span> <span class="nv">level</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">return</span> <span class="nv">level</span> &lt;= <span class="nv">highestUnlockedLevel</span>
</li><li>    }
</li><li>
</li><li> <span class="k">@discardableResult</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">advance</span>(<span class="nv">to</span> <span class="nv">level</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">if</span> <span class="nv">LevelTracker</span>.<span class="nv">isUnlocked</span>(<span class="nv">level</span>) {
</li><li> <span class="nv">currentLevel</span> = <span class="nv">level</span>
</li><li> <span class="k">return</span> <span class="k">true</span>
</li><li>        } <span class="k">else</span> {
</li><li> <span class="k">return</span> <span class="k">false</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> structure keeps track of the highest level that any player has unlocked. This value is stored in a type property called <code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> also defines two type functions to work with the <code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code> property. The first is a type function called <code class="docutils literal notranslate"><span class="pre">unlock(_:)</span></code>, which updates the value of <code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code> whenever a new level is unlocked. The second is a convenience type function called <code class="docutils literal notranslate"><span class="pre">isUnlocked(_:)</span></code>, which returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if a particular level number is already unlocked. (Note that these type methods can access the <code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code> type property without your needing to write it as <code class="docutils literal notranslate"><span class="pre">LevelTracker.highestUnlockedLevel</span></code>.)</p>
<p>In addition to its type property and type methods, <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> tracks an individual player’s progress through the game. It uses an instance property called <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> to track the level that a player is currently playing.</p>
<p>To help manage the <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> property, <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> defines an instance method called <code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code>. Before updating <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>, this method checks whether the requested new level is already unlocked. The <code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code> method returns a Boolean value to indicate whether or not it was actually able to set <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>. Because it’s not necessarily a mistake for code that calls the <code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code> method to ignore the return value, this function is marked with the <code class="docutils literal notranslate"><span class="pre">@discardableResult</span></code> attribute. For more information about this attribute, see <a class="reference internal" href="../ReferenceManual/Attributes.html"><span class="doc">Attributes</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> structure is used with the <code class="docutils literal notranslate"><span class="pre">Player</span></code> class, shown below, to track and update the progress of an individual player:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Player</span> {
</li><li> <span class="k">var</span> <span class="nv">tracker</span> = <span class="nv">LevelTracker</span>()
</li><li> <span class="k">let</span> <span class="nv">playerName</span>: <span class="nc">String</span>
</li><li> <span class="k">func</span> <span class="nv">complete</span>(<span class="nv">level</span>: <span class="nc">Int</span>) {
</li><li> <span class="nv">LevelTracker</span>.<span class="nv">unlock</span>(<span class="nv">level</span> + <span class="m">1</span>)
</li><li> <span class="nv">tracker</span>.<span class="nv">advance</span>(<span class="nv">to</span>: <span class="nv">level</span> + <span class="m">1</span>)
</li><li>    }
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li> <span class="nv">playerName</span> = <span class="nv">name</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Player</span></code> class creates a new instance of <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> to track that player’s progress. It also provides a method called <code class="docutils literal notranslate"><span class="pre">complete(level:)</span></code>, which is called whenever a player completes a particular level. This method unlocks the next level for all players and updates the player’s progress to move them to the next level. (The Boolean return value of <code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code> is ignored, because the level is known to have been unlocked by the call to <code class="docutils literal notranslate"><span class="pre">LevelTracker.unlock(_:)</span></code> on the previous line.)</p>
<p>You can create an instance of the <code class="docutils literal notranslate"><span class="pre">Player</span></code> class for a new player, and see what happens when the player completes level one:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">player</span> = <span class="nv">Player</span>(<span class="nv">name</span>: <span class="s">"Argyrios"</span>)
</li><li><span class="nv">player</span>.<span class="nv">complete</span>(<span class="nv">level</span>: <span class="m">1</span>)
</li><li><span class="nv">print</span>(<span class="s">"highest unlocked level is now </span>\<span class="p">(</span><span class="nv">LevelTracker</span>.<span class="nv">highestUnlockedLevel</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "highest unlocked level is now 2"</span>
</li></ol></div></div></div>
<p>If you create a second player, whom you try to move to a level that is not yet unlocked by any player in the game, the attempt to set the player’s current level fails:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">player</span> = <span class="nv">Player</span>(<span class="nv">name</span>: <span class="s">"Beto"</span>)
</li><li><span class="k">if</span> <span class="nv">player</span>.<span class="nv">tracker</span>.<span class="nv">advance</span>(<span class="nv">to</span>: <span class="m">6</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"player is now on level 6"</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"level 6 has not yet been unlocked"</span>)
</li><li>}
</li><li><span class="c">// Prints "level 6 has not yet been unlocked"</span>
</li></ol></div></div></div>
</div>
</div><div class="section" id="subscripts">
<h1>Subscripts<a class="headerlink" href="Subscripts.html#subscripts" title="Permalink to this headline">¶</a></h1>
<p>Classes, structures, and enumerations can define <em>subscripts</em>, which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an <code class="docutils literal notranslate"><span class="pre">Array</span></code> instance as <code class="docutils literal notranslate"><span class="pre">someArray[index]</span></code> and elements in a <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> instance as <code class="docutils literal notranslate"><span class="pre">someDictionary[key]</span></code>.</p>
<p>You can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript. Subscripts are not limited to a single dimension, and you can define subscripts with multiple input parameters to suit your custom type’s needs.</p>
<div class="section" id="ID306">
<h2>Subscript Syntax<a class="headerlink" href="Subscripts.html#ID306" title="Permalink to this headline">¶</a></h2>
<p>Subscripts enable you to query instances of a type by writing one or more values in square brackets after the instance name. Their syntax is similar to both instance method syntax and computed property syntax. You write subscript definitions with the <code class="docutils literal notranslate"><span class="pre">subscript</span></code> keyword, and specify one or more input parameters and a return type, in the same way as instance methods. Unlike instance methods, subscripts can be read-write or read-only. This behavior is communicated by a getter and setter in the same way as for computed properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">subscript</span>(<span class="nv">index</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">get</span> {
</li><li> <span class="c">// return an appropriate subscript value here</span>
</li><li>    }
</li><li> <span class="k">set</span>(<span class="nv">newValue</span>) {
</li><li> <span class="c">// perform a suitable setting action here</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The type of <code class="docutils literal notranslate"><span class="pre">newValue</span></code> is the same as the return value of the subscript. As with computed properties, you can choose not to specify the setter’s <code class="docutils literal notranslate"><span class="pre">(newValue)</span></code> parameter. A default parameter called <code class="docutils literal notranslate"><span class="pre">newValue</span></code> is provided to your setter if you do not provide one yourself.</p>
<p>As with read-only computed properties, you can simplify the declaration of a read-only subscript by removing the <code class="docutils literal notranslate"><span class="pre">get</span></code> keyword and its braces:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">subscript</span>(<span class="nv">index</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="c">// return an appropriate subscript value here</span>
</li><li>}
</li></ol></div></div></div>
<p>Here’s an example of a read-only subscript implementation, which defines a <code class="docutils literal notranslate"><span class="pre">TimesTable</span></code> structure to represent an <em>n</em>-times-table of integers:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">TimesTable</span> {
</li><li> <span class="k">let</span> <span class="nv">multiplier</span>: <span class="nc">Int</span>
</li><li> <span class="k">subscript</span>(<span class="nv">index</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">multiplier</span> * <span class="nv">index</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">threeTimesTable</span> = <span class="nv">TimesTable</span>(<span class="nv">multiplier</span>: <span class="m">3</span>)
</li><li><span class="nv">print</span>(<span class="s">"six times three is </span>\<span class="p">(</span><span class="nv">threeTimesTable</span>[<span class="m">6</span>]<span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "six times three is 18"</span>
</li></ol></div></div></div>
<p>In this example, a new instance of <code class="docutils literal notranslate"><span class="pre">TimesTable</span></code> is created to represent the three-times-table. This is indicated by passing a value of <code class="docutils literal notranslate"><span class="pre">3</span></code> to the structure’s <code class="docutils literal notranslate"><span class="pre">initializer</span></code> as the value to use for the instance’s <code class="docutils literal notranslate"><span class="pre">multiplier</span></code> parameter.</p>
<p>You can query the <code class="docutils literal notranslate"><span class="pre">threeTimesTable</span></code> instance by calling its subscript, as shown in the call to <code class="docutils literal notranslate"><span class="pre">threeTimesTable[6]</span></code>. This requests the sixth entry in the three-times-table, which returns a value of <code class="docutils literal notranslate"><span class="pre">18</span></code>, or <code class="docutils literal notranslate"><span class="pre">3</span></code> times <code class="docutils literal notranslate"><span class="pre">6</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An <em>n</em>-times-table is based on a fixed mathematical rule. It is not appropriate to set <code class="docutils literal notranslate"><span class="pre">threeTimesTable[someIndex]</span></code> to a new value, and so the subscript for <code class="docutils literal notranslate"><span class="pre">TimesTable</span></code> is defined as a read-only subscript.</p>
</div>
</div>
<div class="section" id="ID307">
<h2>Subscript Usage<a class="headerlink" href="Subscripts.html#ID307" title="Permalink to this headline">¶</a></h2>
<p>The exact meaning of “subscript” depends on the context in which it is used. Subscripts are typically used as a shortcut for accessing the member elements in a collection, list, or sequence. You are free to implement subscripts in the most appropriate way for your particular class or structure’s functionality.</p>
<p>For example, Swift’s <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> type implements a subscript to set and retrieve the values stored in a <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> instance. You can set a value in a dictionary by providing a key of the dictionary’s key type within subscript brackets, and assigning a value of the dictionary’s value type to the subscript:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">numberOfLegs</span> = [<span class="s">"spider"</span>: <span class="m">8</span>, <span class="s">"ant"</span>: <span class="m">6</span>, <span class="s">"cat"</span>: <span class="m">4</span>]
</li><li><span class="nv">numberOfLegs</span>[<span class="s">"bird"</span>] = <span class="m">2</span>
</li></ol></div></div></div>
<p>The example above defines a variable called <code class="docutils literal notranslate"><span class="pre">numberOfLegs</span></code> and initializes it with a dictionary literal containing three key-value pairs. The type of the <code class="docutils literal notranslate"><span class="pre">numberOfLegs</span></code> dictionary is inferred to be <code class="docutils literal notranslate"><span class="pre">[String:</span> <span class="pre">Int]</span></code>. After creating the dictionary, this example uses subscript assignment to add a <code class="docutils literal notranslate"><span class="pre">String</span></code> key of <code class="docutils literal notranslate"><span class="pre">"bird"</span></code> and an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value of <code class="docutils literal notranslate"><span class="pre">2</span></code> to the dictionary.</p>
<p>For more information about <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> subscripting, see <a class="reference internal" href="CollectionTypes.html#ID116"><span class="std std-ref">Accessing and Modifying a Dictionary</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Swift’s <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> type implements its key-value subscripting as a subscript that takes and returns an <em>optional</em> type. For the <code class="docutils literal notranslate"><span class="pre">numberOfLegs</span></code> dictionary above, the key-value subscript takes and returns a value of type <code class="docutils literal notranslate"><span class="pre">Int?</span></code>, or “optional int”. The <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> type uses an optional subscript type to model the fact that not every key will have a value, and to give a way to delete a value for a key by assigning a <code class="docutils literal notranslate"><span class="pre">nil</span></code> value for that key.</p>
</div>
</div>
<div class="section" id="ID308">
<h2>Subscript Options<a class="headerlink" href="Subscripts.html#ID308" title="Permalink to this headline">¶</a></h2>
<p>Subscripts can take any number of input parameters, and these input parameters can be of any type. Subscripts can also return any type. Subscripts can use variadic parameters, but they can’t use in-out parameters or provide default parameter values.</p>
<p>A class or structure can provide as many subscript implementations as it needs, and the appropriate subscript to be used will be inferred based on the types of the value or values that are contained within the subscript brackets at the point that the subscript is used. This definition of multiple subscripts is known as <em>subscript overloading</em>.</p>
<p>While it is most common for a subscript to take a single parameter, you can also define a subscript with multiple parameters if it is appropriate for your type. The following example defines a <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> structure, which represents a two-dimensional matrix of <code class="docutils literal notranslate"><span class="pre">Double</span></code> values. The <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> structure’s subscript takes two integer parameters:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Matrix</span> {
</li><li> <span class="k">let</span> <span class="nv">rows</span>: <span class="nc">Int</span>, <span class="nv">columns</span>: <span class="nc">Int</span>
</li><li> <span class="k">var</span> <span class="nv">grid</span>: [<span class="nc">Double</span>]
</li><li> <span class="k">init</span>(<span class="nv">rows</span>: <span class="nc">Int</span>, <span class="nv">columns</span>: <span class="nc">Int</span>) {
</li><li> <span class="k">self</span>.<span class="nv">rows</span> = <span class="nv">rows</span>
</li><li> <span class="k">self</span>.<span class="nv">columns</span> = <span class="nv">columns</span>
</li><li> <span class="nv">grid</span> = <span class="nv">Array</span>(<span class="nv">repeating</span>: <span class="m">0.0</span>, <span class="nv">count</span>: <span class="nv">rows</span> * <span class="nv">columns</span>)
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">indexIsValid</span>(<span class="nv">row</span>: <span class="nc">Int</span>, <span class="nv">column</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">return</span> <span class="nv">row</span> &gt;= <span class="m">0</span> &amp;&amp; <span class="nv">row</span> &lt; <span class="nv">rows</span> &amp;&amp; <span class="nv">column</span> &gt;= <span class="m">0</span> &amp;&amp; <span class="nv">column</span> &lt; <span class="nv">columns</span>
</li><li>    }
</li><li> <span class="k">subscript</span>(<span class="nv">row</span>: <span class="nc">Int</span>, <span class="nv">column</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Double</span> {
</li><li> <span class="k">get</span> {
</li><li> <span class="nv">assert</span>(<span class="nv">indexIsValid</span>(<span class="nv">row</span>: <span class="nv">row</span>, <span class="nv">column</span>: <span class="nv">column</span>), <span class="s">"Index out of range"</span>)
</li><li> <span class="k">return</span> <span class="nv">grid</span>[(<span class="nv">row</span> * <span class="nv">columns</span>) + <span class="nv">column</span>]
</li><li>        }
</li><li> <span class="k">set</span> {
</li><li> <span class="nv">assert</span>(<span class="nv">indexIsValid</span>(<span class="nv">row</span>: <span class="nv">row</span>, <span class="nv">column</span>: <span class="nv">column</span>), <span class="s">"Index out of range"</span>)
</li><li> <span class="nv">grid</span>[(<span class="nv">row</span> * <span class="nv">columns</span>) + <span class="nv">column</span>] = <span class="nv">newValue</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">Matrix</span></code> provides an initializer that takes two parameters called <code class="docutils literal notranslate"><span class="pre">rows</span></code> and <code class="docutils literal notranslate"><span class="pre">columns</span></code>, and creates an array that is large enough to store <code class="docutils literal notranslate"><span class="pre">rows</span> <span class="pre">*</span> <span class="pre">columns</span></code> values of type <code class="docutils literal notranslate"><span class="pre">Double</span></code>. Each position in the matrix is given an initial value of <code class="docutils literal notranslate"><span class="pre">0.0</span></code>. To achieve this, the array’s size, and an initial cell value of <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, are passed to an array initializer that creates and initializes a new array of the correct size. This initializer is described in more detail in <a class="reference internal" href="CollectionTypes.html#ID501"><span class="std std-ref">Creating an Array with a Default Value</span></a>.</p>
<p>You can construct a new <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> instance by passing an appropriate row and column count to its initializer:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">matrix</span> = <span class="nv">Matrix</span>(<span class="nv">rows</span>: <span class="m">2</span>, <span class="nv">columns</span>: <span class="m">2</span>)
</li></ol></div></div></div>
<p>The example above creates a new <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> instance with two rows and two columns. The <code class="docutils literal notranslate"><span class="pre">grid</span></code> array for this <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> instance is effectively a flattened version of the matrix, as read from top left to bottom right:</p>
<img alt="../_images/subscriptMatrix01_2x.png" class="align-center" src="../_images/subscriptMatrix01_2x.png" style="width: 280px;"/>
<p>Values in the matrix can be set by passing row and column values into the subscript, separated by a comma:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">matrix</span>[<span class="m">0</span>, <span class="m">1</span>] = <span class="m">1.5</span>
</li><li><span class="nv">matrix</span>[<span class="m">1</span>, <span class="m">0</span>] = <span class="m">3.2</span>
</li></ol></div></div></div>
<p>These two statements call the subscript’s setter to set a value of <code class="docutils literal notranslate"><span class="pre">1.5</span></code> in the top right position of the matrix (where <code class="docutils literal notranslate"><span class="pre">row</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">column</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code>), and <code class="docutils literal notranslate"><span class="pre">3.2</span></code> in the bottom left position (where <code class="docutils literal notranslate"><span class="pre">row</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">column</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code>):</p>
<img alt="../_images/subscriptMatrix02_2x.png" class="align-center" src="../_images/subscriptMatrix02_2x.png" style="width: 98px;"/>
<p>The <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> subscript’s getter and setter both contain an assertion to check that the subscript’s <code class="docutils literal notranslate"><span class="pre">row</span></code> and <code class="docutils literal notranslate"><span class="pre">column</span></code> values are valid. To assist with these assertions, <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> includes a convenience method called <code class="docutils literal notranslate"><span class="pre">indexIsValid(row:column:)</span></code>, which checks whether the requested <code class="docutils literal notranslate"><span class="pre">row</span></code> and <code class="docutils literal notranslate"><span class="pre">column</span></code> are inside the bounds of the matrix:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">indexIsValid</span>(<span class="nv">row</span>: <span class="nc">Int</span>, <span class="nv">column</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">return</span> <span class="nv">row</span> &gt;= <span class="m">0</span> &amp;&amp; <span class="nv">row</span> &lt; <span class="nv">rows</span> &amp;&amp; <span class="nv">column</span> &gt;= <span class="m">0</span> &amp;&amp; <span class="nv">column</span> &lt; <span class="nv">columns</span>
</li><li>}
</li></ol></div></div></div>
<p>An assertion is triggered if you try to access a subscript that is outside of the matrix bounds:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someValue</span> = <span class="nv">matrix</span>[<span class="m">2</span>, <span class="m">2</span>]
</li><li><span class="c">// this triggers an assert, because [2, 2] is outside of the matrix bounds</span>
</li></ol></div></div></div>
</div>
</div><div class="section" id="inheritance">
<h1>Inheritance<a class="headerlink" href="Inheritance.html#inheritance" title="Permalink to this headline">¶</a></h1>
<p>A class can <em>inherit</em> methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a <em>subclass</em>, and the class it inherits from is known as its <em>superclass</em>. Inheritance is a fundamental behavior that differentiates classes from other types in Swift.</p>
<p>Classes in Swift can call and access methods, properties, and subscripts belonging to their superclass and can provide their own overriding versions of those methods, properties, and subscripts to refine or modify their behavior. Swift helps to ensure your overrides are correct by checking that the override definition has a matching superclass definition.</p>
<p>Classes can also add property observers to inherited properties in order to be notified when the value of a property changes. Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.</p>
<div class="section" id="ID194">
<h2>Defining a Base Class<a class="headerlink" href="Inheritance.html#ID194" title="Permalink to this headline">¶</a></h2>
<p>Any class that does not inherit from another class is known as a <em>base class</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Swift classes do not inherit from a universal base class. Classes you define without specifying a superclass automatically become base classes for you to build upon.</p>
</div>
<p>The example below defines a base class called <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>. This base class defines a stored property called <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">0.0</span></code> (inferring a property type of <code class="docutils literal notranslate"><span class="pre">Double</span></code>). The <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> property’s value is used by a read-only computed <code class="docutils literal notranslate"><span class="pre">String</span></code> property called <code class="docutils literal notranslate"><span class="pre">description</span></code> to create a description of the vehicle.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> base class also defines a method called <code class="docutils literal notranslate"><span class="pre">makeNoise</span></code>. This method does not actually do anything for a base <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> instance, but will be customized by subclasses of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> later on:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Vehicle</span> {
</li><li> <span class="k">var</span> <span class="nv">currentSpeed</span> = <span class="m">0.0</span>
</li><li> <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="s">"traveling at </span>\<span class="p">(</span><span class="nv">currentSpeed</span><span class="p">)</span><span class="s"> miles per hour"</span>
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">makeNoise</span>() {
</li><li> <span class="c">// do nothing - an arbitrary vehicle doesn't necessarily make a noise</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>You create a new instance of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> with <em>initializer syntax</em>, which is written as a type name followed by empty parentheses:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someVehicle</span> = <span class="nv">Vehicle</span>()
</li></ol></div></div></div>
<p>Having created a new <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> instance, you can access its <code class="docutils literal notranslate"><span class="pre">description</span></code> property to print a human-readable description of the vehicle’s current speed:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"Vehicle: </span>\<span class="p">(</span><span class="nv">someVehicle</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Vehicle: traveling at 0.0 miles per hour</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> class defines common characteristics for an arbitrary vehicle, but is not much use in itself. To make it more useful, you need to refine it to describe more specific kinds of vehicles.</p>
</div>
<div class="section" id="ID195">
<h2>Subclassing<a class="headerlink" href="Inheritance.html#ID195" title="Permalink to this headline">¶</a></h2>
<p><em>Subclassing</em> is the act of basing a new class on an existing class. The subclass inherits characteristics from the existing class, which you can then refine. You can also add new characteristics to the subclass.</p>
<p>To indicate that a subclass has a superclass, write the subclass name before the superclass name, separated by a colon:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeSubclass</span>: <span class="nc">SomeSuperclass</span> {
</li><li> <span class="c">// subclass definition goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>The following example defines a subclass called <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>, with a superclass of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Bicycle</span>: <span class="nc">Vehicle</span> {
</li><li> <span class="k">var</span> <span class="nv">hasBasket</span> = <span class="k">false</span>
</li><li>}
</li></ol></div></div></div>
<p>The new <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> class automatically gains all of the characteristics of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>, such as its <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> and <code class="docutils literal notranslate"><span class="pre">description</span></code> properties and its <code class="docutils literal notranslate"><span class="pre">makeNoise()</span></code> method.</p>
<p>In addition to the characteristics it inherits, the <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> class defines a new stored property, <code class="docutils literal notranslate"><span class="pre">hasBasket</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">false</span></code> (inferring a type of <code class="docutils literal notranslate"><span class="pre">Bool</span></code> for the property).</p>
<p>By default, any new <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> instance you create will not have a basket. You can set the <code class="docutils literal notranslate"><span class="pre">hasBasket</span></code> property to <code class="docutils literal notranslate"><span class="pre">true</span></code> for a particular <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> instance after that instance is created:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">bicycle</span> = <span class="nv">Bicycle</span>()
</li><li><span class="nv">bicycle</span>.<span class="nv">hasBasket</span> = <span class="k">true</span>
</li></ol></div></div></div>
<p>You can also modify the inherited <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> property of a <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> instance, and query the instance’s inherited <code class="docutils literal notranslate"><span class="pre">description</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">bicycle</span>.<span class="nv">currentSpeed</span> = <span class="m">15.0</span>
</li><li><span class="nv">print</span>(<span class="s">"Bicycle: </span>\<span class="p">(</span><span class="nv">bicycle</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Bicycle: traveling at 15.0 miles per hour</span>
</li></ol></div></div></div>
<p>Subclasses can themselves be subclassed. The next example creates a subclass of <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> for a two-seater bicycle known as a “tandem”:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Tandem</span>: <span class="nc">Bicycle</span> {
</li><li> <span class="k">var</span> <span class="nv">currentNumberOfPassengers</span> = <span class="m">0</span>
</li><li>}
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">Tandem</span></code> inherits all of the properties and methods from <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>, which in turn inherits all of the properties and methods from <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>. The <code class="docutils literal notranslate"><span class="pre">Tandem</span></code> subclass also adds a new stored property called <code class="docutils literal notranslate"><span class="pre">currentNumberOfPassengers</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>If you create an instance of <code class="docutils literal notranslate"><span class="pre">Tandem</span></code>, you can work with any of its new and inherited properties, and query the read-only <code class="docutils literal notranslate"><span class="pre">description</span></code> property it inherits from <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">tandem</span> = <span class="nv">Tandem</span>()
</li><li><span class="nv">tandem</span>.<span class="nv">hasBasket</span> = <span class="k">true</span>
</li><li><span class="nv">tandem</span>.<span class="nv">currentNumberOfPassengers</span> = <span class="m">2</span>
</li><li><span class="nv">tandem</span>.<span class="nv">currentSpeed</span> = <span class="m">22.0</span>
</li><li><span class="nv">print</span>(<span class="s">"Tandem: </span>\<span class="p">(</span><span class="nv">tandem</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Tandem: traveling at 22.0 miles per hour</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID196">
<h2>Overriding<a class="headerlink" href="Inheritance.html#ID196" title="Permalink to this headline">¶</a></h2>
<p>A subclass can provide its own custom implementation of an instance method, type method, instance property, type property, or subscript that it would otherwise inherit from a superclass. This is known as <em>overriding</em>.</p>
<p>To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the <code class="docutils literal notranslate"><span class="pre">override</span></code> keyword. Doing so clarifies that you intend to provide an override and have not provided a matching definition by mistake. Overriding by accident can cause unexpected behavior, and any overrides without the <code class="docutils literal notranslate"><span class="pre">override</span></code> keyword are diagnosed as an error when your code is compiled.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">override</span></code> keyword also prompts the Swift compiler to check that your overriding class’s superclass (or one of its parents) has a declaration that matches the one you provided for the override. This check ensures that your overriding definition is correct.</p>
<div class="section" id="ID197">
<h3>Accessing Superclass Methods, Properties, and Subscripts<a class="headerlink" href="Inheritance.html#ID197" title="Permalink to this headline">¶</a></h3>
<p>When you provide a method, property, or subscript override for a subclass, it is sometimes useful to use the existing superclass implementation as part of your override. For example, you can refine the behavior of that existing implementation, or store a modified value in an existing inherited variable.</p>
<p>Where this is appropriate, you access the superclass version of a method, property, or subscript by using the <code class="docutils literal notranslate"><span class="pre">super</span></code> prefix:</p>
<ul class="simple">
<li>An overridden method named <code class="docutils literal notranslate"><span class="pre">someMethod()</span></code> can call the superclass version of <code class="docutils literal notranslate"><span class="pre">someMethod()</span></code> by calling <code class="docutils literal notranslate"><span class="pre">super.someMethod()</span></code> within the overriding method implementation.</li>
<li>An overridden property called <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> can access the superclass version of <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> as <code class="docutils literal notranslate"><span class="pre">super.someProperty</span></code> within the overriding getter or setter implementation.</li>
<li>An overridden subscript for <code class="docutils literal notranslate"><span class="pre">someIndex</span></code> can access the superclass version of the same subscript as <code class="docutils literal notranslate"><span class="pre">super[someIndex]</span></code> from within the overriding subscript implementation.</li>
</ul>
</div>
<div class="section" id="ID198">
<h3>Overriding Methods<a class="headerlink" href="Inheritance.html#ID198" title="Permalink to this headline">¶</a></h3>
<p>You can override an inherited instance or type method to provide a tailored or alternative implementation of the method within your subclass.</p>
<p>The following example defines a new subclass of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> called <code class="docutils literal notranslate"><span class="pre">Train</span></code>, which overrides the <code class="docutils literal notranslate"><span class="pre">makeNoise()</span></code> method that <code class="docutils literal notranslate"><span class="pre">Train</span></code> inherits from <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Train</span>: <span class="nc">Vehicle</span> {
</li><li> <span class="k">override</span> <span class="k">func</span> <span class="nv">makeNoise</span>() {
</li><li> <span class="nv">print</span>(<span class="s">"Choo Choo"</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>If you create a new instance of <code class="docutils literal notranslate"><span class="pre">Train</span></code> and call its <code class="docutils literal notranslate"><span class="pre">makeNoise()</span></code> method, you can see that the <code class="docutils literal notranslate"><span class="pre">Train</span></code> subclass version of the method is called:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">train</span> = <span class="nv">Train</span>()
</li><li><span class="nv">train</span>.<span class="nv">makeNoise</span>()
</li><li><span class="c">// Prints "Choo Choo"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID199">
<h3>Overriding Properties<a class="headerlink" href="Inheritance.html#ID199" title="Permalink to this headline">¶</a></h3>
<p>You can override an inherited instance or type property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes.</p>
<div class="section" id="ID200">
<h4>Overriding Property Getters and Setters<a class="headerlink" href="Inheritance.html#ID200" title="Permalink to this headline">¶</a></h4>
<p>You can provide a custom getter (and setter, if appropriate) to override <em>any</em> inherited property, regardless of whether the inherited property is implemented as a stored or computed property at source. The stored or computed nature of an inherited property is not known by a subclass—it only knows that the inherited property has a certain name and type. You must always state both the name and the type of the property you are overriding, to enable the compiler to check that your override matches a superclass property with the same name and type.</p>
<p>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you provide a setter as part of a property override, you must also provide a getter for that override. If you don’t want to modify the inherited property’s value within the overriding getter, you can simply pass through the inherited value by returning <code class="docutils literal notranslate"><span class="pre">super.someProperty</span></code> from the getter, where <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> is the name of the property you are overriding.</p>
</div>
<p>The following example defines a new class called <code class="docutils literal notranslate"><span class="pre">Car</span></code>, which is a subclass of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>. The <code class="docutils literal notranslate"><span class="pre">Car</span></code> class introduces a new stored property called <code class="docutils literal notranslate"><span class="pre">gear</span></code>, with a default integer value of <code class="docutils literal notranslate"><span class="pre">1</span></code>. The <code class="docutils literal notranslate"><span class="pre">Car</span></code> class also overrides the <code class="docutils literal notranslate"><span class="pre">description</span></code> property it inherits from <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>, to provide a custom description that includes the current gear:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Car</span>: <span class="nc">Vehicle</span> {
</li><li> <span class="k">var</span> <span class="nv">gear</span> = <span class="m">1</span>
</li><li> <span class="k">override</span> <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="k">super</span>.<span class="nv">description</span> + <span class="s">" in gear </span>\<span class="p">(</span><span class="nv">gear</span><span class="p">)</span><span class="s">"</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The override of the <code class="docutils literal notranslate"><span class="pre">description</span></code> property starts by calling <code class="docutils literal notranslate"><span class="pre">super.description</span></code>, which returns the <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> class’s <code class="docutils literal notranslate"><span class="pre">description</span></code> property. The <code class="docutils literal notranslate"><span class="pre">Car</span></code> class’s version of <code class="docutils literal notranslate"><span class="pre">description</span></code> then adds some extra text onto the end of this description to provide information about the current gear.</p>
<p>If you create an instance of the <code class="docutils literal notranslate"><span class="pre">Car</span></code> class and set its <code class="docutils literal notranslate"><span class="pre">gear</span></code> and <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> properties, you can see that its <code class="docutils literal notranslate"><span class="pre">description</span></code> property returns the tailored description defined within the <code class="docutils literal notranslate"><span class="pre">Car</span></code> class:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">car</span> = <span class="nv">Car</span>()
</li><li><span class="nv">car</span>.<span class="nv">currentSpeed</span> = <span class="m">25.0</span>
</li><li><span class="nv">car</span>.<span class="nv">gear</span> = <span class="m">3</span>
</li><li><span class="nv">print</span>(<span class="s">"Car: </span>\<span class="p">(</span><span class="nv">car</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Car: traveling at 25.0 miles per hour in gear 3</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID201">
<h4>Overriding Property Observers<a class="headerlink" href="Inheritance.html#ID201" title="Permalink to this headline">¶</a></h4>
<p>You can use property overriding to add property observers to an inherited property. This enables you to be notified when the value of an inherited property changes, regardless of how that property was originally implemented. For more information on property observers, see <a class="reference internal" href="Properties.html#ID262"><span class="std std-ref">Property Observers</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>You cannot add property observers to inherited constant stored properties or inherited read-only computed properties. The value of these properties cannot be set, and so it is not appropriate to provide a <code class="docutils literal notranslate"><span class="pre">willSet</span></code> or <code class="docutils literal notranslate"><span class="pre">didSet</span></code> implementation as part of an override.</p>
<p class="last">Note also that you cannot provide both an overriding setter and an overriding property observer for the same property. If you want to observe changes to a property’s value, and you are already providing a custom setter for that property, you can simply observe any value changes from within the custom setter.</p>
</div>
<p>The following example defines a new class called <code class="docutils literal notranslate"><span class="pre">AutomaticCar</span></code>, which is a subclass of <code class="docutils literal notranslate"><span class="pre">Car</span></code>. The <code class="docutils literal notranslate"><span class="pre">AutomaticCar</span></code> class represents a car with an automatic gearbox, which automatically selects an appropriate gear to use based on the current speed:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">AutomaticCar</span>: <span class="nc">Car</span> {
</li><li> <span class="k">override</span> <span class="k">var</span> <span class="nv">currentSpeed</span>: <span class="nc">Double</span> {
</li><li> <span class="k">didSet</span> {
</li><li> <span class="nv">gear</span> = <span class="nv">Int</span>(<span class="nv">currentSpeed</span> / <span class="m">10.0</span>) + <span class="m">1</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Whenever you set the <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> property of an <code class="docutils literal notranslate"><span class="pre">AutomaticCar</span></code> instance, the property’s <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer sets the instance’s <code class="docutils literal notranslate"><span class="pre">gear</span></code> property to an appropriate choice of gear for the new speed. Specifically, the property observer chooses a gear that is the new <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> value divided by <code class="docutils literal notranslate"><span class="pre">10</span></code>, rounded down to the nearest integer, plus <code class="docutils literal notranslate"><span class="pre">1</span></code>. A speed of <code class="docutils literal notranslate"><span class="pre">35.0</span></code> produces a gear of <code class="docutils literal notranslate"><span class="pre">4</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">automatic</span> = <span class="nv">AutomaticCar</span>()
</li><li><span class="nv">automatic</span>.<span class="nv">currentSpeed</span> = <span class="m">35.0</span>
</li><li><span class="nv">print</span>(<span class="s">"AutomaticCar: </span>\<span class="p">(</span><span class="nv">automatic</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// AutomaticCar: traveling at 35.0 miles per hour in gear 4</span>
</li></ol></div></div></div>
</div>
</div>
</div>
<div class="section" id="ID202">
<h2>Preventing Overrides<a class="headerlink" href="Inheritance.html#ID202" title="Permalink to this headline">¶</a></h2>
<p>You can prevent a method, property, or subscript from being overridden by marking it as <em>final</em>. Do this by writing the <code class="docutils literal notranslate"><span class="pre">final</span></code> modifier before the method, property, or subscript’s introducer keyword (such as <code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">var</span></code>, <code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">func</span></code>, <code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">class</span> <span class="pre">func</span></code>, and <code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">subscript</span></code>).</p>
<p>Any attempt to override a final method, property, or subscript in a subclass is reported as a compile-time error. Methods, properties, or subscripts that you add to a class in an extension can also be marked as final within the extension’s definition.</p>
<p>You can mark an entire class as final by writing the <code class="docutils literal notranslate"><span class="pre">final</span></code> modifier before the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword in its class definition (<code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">class</span></code>). Any attempt to subclass a final class is reported as a compile-time error.</p>
</div>
</div><div class="section" id="initialization">
<h1>Initialization<a class="headerlink" href="Initialization.html#initialization" title="Permalink to this headline">¶</a></h1>
<p><em>Initialization</em> is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that is required before the new instance is ready for use.</p>
<p>You implement this initialization process by defining <em>initializers</em>, which are like special methods that can be called to create a new instance of a particular type. Unlike Objective-C initializers, Swift initializers do not return a value. Their primary role is to ensure that new instances of a type are correctly initialized before they are used for the first time.</p>
<p>Instances of class types can also implement a <em>deinitializer</em>, which performs any custom cleanup just before an instance of that class is deallocated. For more information about deinitializers, see <a class="reference internal" href="Deinitialization.html"><span class="doc">Deinitialization</span></a>.</p>
<div class="section" id="ID204">
<h2>Setting Initial Values for Stored Properties<a class="headerlink" href="Initialization.html#ID204" title="Permalink to this headline">¶</a></h2>
<p>Classes and structures <em>must</em> set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties cannot be left in an indeterminate state.</p>
<p>You can set an initial value for a stored property within an initializer, or by assigning a default property value as part of the property’s definition. These actions are described in the following sections.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers.</p>
</div>
<div class="section" id="ID205">
<h3>Initializers<a class="headerlink" href="Initialization.html#ID205" title="Permalink to this headline">¶</a></h3>
<p><em>Initializers</em> are called to create a new instance of a particular type. In its simplest form, an initializer is like an instance method with no parameters, written using the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">init</span>() {
</li><li> <span class="c">// perform some initialization here</span>
</li><li>}
</li></ol></div></div></div>
<p>The example below defines a new structure called <code class="docutils literal notranslate"><span class="pre">Fahrenheit</span></code> to store temperatures expressed in the Fahrenheit scale. The <code class="docutils literal notranslate"><span class="pre">Fahrenheit</span></code> structure has one stored property, <code class="docutils literal notranslate"><span class="pre">temperature</span></code>, which is of type <code class="docutils literal notranslate"><span class="pre">Double</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Fahrenheit</span> {
</li><li> <span class="k">var</span> <span class="nv">temperature</span>: <span class="nc">Double</span>
</li><li> <span class="k">init</span>() {
</li><li> <span class="nv">temperature</span> = <span class="m">32.0</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">f</span> = <span class="nv">Fahrenheit</span>()
</li><li><span class="nv">print</span>(<span class="s">"The default temperature is </span>\<span class="p">(</span><span class="nv">f</span>.<span class="nv">temperature</span><span class="p">)</span><span class="s">° Fahrenheit"</span>)
</li><li><span class="c">// Prints "The default temperature is 32.0° Fahrenheit"</span>
</li></ol></div></div></div>
<p>The structure defines a single initializer, <code class="docutils literal notranslate"><span class="pre">init</span></code>, with no parameters, which initializes the stored temperature with a value of <code class="docutils literal notranslate"><span class="pre">32.0</span></code> (the freezing point of water in degrees Fahrenheit).</p>
</div>
<div class="section" id="ID206">
<h3>Default Property Values<a class="headerlink" href="Initialization.html#ID206" title="Permalink to this headline">¶</a></h3>
<p>You can set the initial value of a stored property from within an initializer, as shown above. Alternatively, specify a <em>default property value</em> as part of the property’s declaration. You specify a default property value by assigning an initial value to the property when it is defined.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a property always takes the same initial value, provide a default value rather than setting a value within an initializer. The end result is the same, but the default value ties the property’s initialization more closely to its declaration. It makes for shorter, clearer initializers and enables you to infer the type of the property from its default value. The default value also makes it easier for you to take advantage of default initializers and initializer inheritance, as described later in this chapter.</p>
</div>
<p>You can write the <code class="docutils literal notranslate"><span class="pre">Fahrenheit</span></code> structure from above in a simpler form by providing a default value for its <code class="docutils literal notranslate"><span class="pre">temperature</span></code> property at the point that the property is declared:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Fahrenheit</span> {
</li><li> <span class="k">var</span> <span class="nv">temperature</span> = <span class="m">32.0</span>
</li><li>}
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID207">
<h2>Customizing Initialization<a class="headerlink" href="Initialization.html#ID207" title="Permalink to this headline">¶</a></h2>
<p>You can customize the initialization process with input parameters and optional property types, or by assigning constant properties during initialization, as described in the following sections.</p>
<div class="section" id="ID208">
<h3>Initialization Parameters<a class="headerlink" href="Initialization.html#ID208" title="Permalink to this headline">¶</a></h3>
<p>You can provide <em>initialization parameters</em> as part of an initializer’s definition, to define the types and names of values that customize the initialization process. Initialization parameters have the same capabilities and syntax as function and method parameters.</p>
<p>The following example defines a structure called <code class="docutils literal notranslate"><span class="pre">Celsius</span></code>, which stores temperatures expressed in degrees Celsius. The <code class="docutils literal notranslate"><span class="pre">Celsius</span></code> structure implements two custom initializers called <code class="docutils literal notranslate"><span class="pre">init(fromFahrenheit:)</span></code> and <code class="docutils literal notranslate"><span class="pre">init(fromKelvin:)</span></code>, which initialize a new instance of the structure with a value from a different temperature scale:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Celsius</span> {
</li><li> <span class="k">var</span> <span class="nv">temperatureInCelsius</span>: <span class="nc">Double</span>
</li><li> <span class="k">init</span>(<span class="nv">fromFahrenheit</span> <span class="nv">fahrenheit</span>: <span class="nc">Double</span>) {
</li><li> <span class="nv">temperatureInCelsius</span> = (<span class="nv">fahrenheit</span> - <span class="m">32.0</span>) / <span class="m">1.8</span>
</li><li>    }
</li><li> <span class="k">init</span>(<span class="nv">fromKelvin</span> <span class="nv">kelvin</span>: <span class="nc">Double</span>) {
</li><li> <span class="nv">temperatureInCelsius</span> = <span class="nv">kelvin</span> - <span class="m">273.15</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">boilingPointOfWater</span> = <span class="nv">Celsius</span>(<span class="nv">fromFahrenheit</span>: <span class="m">212.0</span>)
</li><li><span class="c">// boilingPointOfWater.temperatureInCelsius is 100.0</span>
</li><li><span class="k">let</span> <span class="nv">freezingPointOfWater</span> = <span class="nv">Celsius</span>(<span class="nv">fromKelvin</span>: <span class="m">273.15</span>)
</li><li><span class="c">// freezingPointOfWater.temperatureInCelsius is 0.0</span>
</li></ol></div></div></div>
<p>The first initializer has a single initialization parameter with an argument label of <code class="docutils literal notranslate"><span class="pre">fromFahrenheit</span></code> and a parameter name of <code class="docutils literal notranslate"><span class="pre">fahrenheit</span></code>. The second initializer has a single initialization parameter with an argument label of <code class="docutils literal notranslate"><span class="pre">fromKelvin</span></code> and a parameter name of <code class="docutils literal notranslate"><span class="pre">kelvin</span></code>. Both initializers convert their single argument into the corresponding Celsius value and store this value in a property called <code class="docutils literal notranslate"><span class="pre">temperatureInCelsius</span></code>.</p>
</div>
<div class="section" id="ID209">
<h3>Parameter Names and Argument Labels<a class="headerlink" href="Initialization.html#ID209" title="Permalink to this headline">¶</a></h3>
<p>As with function and method parameters, initialization parameters can have both a parameter name for use within the initializer’s body and an argument label for use when calling the initializer.</p>
<p>However, initializers do not have an identifying function name before their parentheses in the way that functions and methods do. Therefore, the names and types of an initializer’s parameters play a particularly important role in identifying which initializer should be called. Because of this, Swift provides an automatic argument label for <em>every</em> parameter in an initializer if you don’t provide one.</p>
<p>The following example defines a structure called <code class="docutils literal notranslate"><span class="pre">Color</span></code>, with three constant properties called <code class="docutils literal notranslate"><span class="pre">red</span></code>, <code class="docutils literal notranslate"><span class="pre">green</span></code>, and <code class="docutils literal notranslate"><span class="pre">blue</span></code>. These properties store a value between <code class="docutils literal notranslate"><span class="pre">0.0</span></code> and <code class="docutils literal notranslate"><span class="pre">1.0</span></code> to indicate the amount of red, green, and blue in the color.</p>
<p><code class="docutils literal notranslate"><span class="pre">Color</span></code> provides an initializer with three appropriately named parameters of type <code class="docutils literal notranslate"><span class="pre">Double</span></code> for its red, green, and blue components. <code class="docutils literal notranslate"><span class="pre">Color</span></code> also provides a second initializer with a single <code class="docutils literal notranslate"><span class="pre">white</span></code> parameter, which is used to provide the same value for all three color components.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Color</span> {
</li><li> <span class="k">let</span> <span class="nv">red</span>, <span class="nv">green</span>, <span class="nv">blue</span>: <span class="nc">Double</span>
</li><li> <span class="k">init</span>(<span class="nv">red</span>: <span class="nc">Double</span>, <span class="nv">green</span>: <span class="nc">Double</span>, <span class="nv">blue</span>: <span class="nc">Double</span>) {
</li><li> <span class="k">self</span>.<span class="nv">red</span>   = <span class="nv">red</span>
</li><li> <span class="k">self</span>.<span class="nv">green</span> = <span class="nv">green</span>
</li><li> <span class="k">self</span>.<span class="nv">blue</span>  = <span class="nv">blue</span>
</li><li>    }
</li><li> <span class="k">init</span>(<span class="nv">white</span>: <span class="nc">Double</span>) {
</li><li> <span class="nv">red</span>   = <span class="nv">white</span>
</li><li> <span class="nv">green</span> = <span class="nv">white</span>
</li><li> <span class="nv">blue</span>  = <span class="nv">white</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Both initializers can be used to create a new <code class="docutils literal notranslate"><span class="pre">Color</span></code> instance, by providing named values for each initializer parameter:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">magenta</span> = <span class="nv">Color</span>(<span class="nv">red</span>: <span class="m">1.0</span>, <span class="nv">green</span>: <span class="m">0.0</span>, <span class="nv">blue</span>: <span class="m">1.0</span>)
</li><li><span class="k">let</span> <span class="nv">halfGray</span> = <span class="nv">Color</span>(<span class="nv">white</span>: <span class="m">0.5</span>)
</li></ol></div></div></div>
<p>Note that it is not possible to call these initializers without using argument labels. Argument labels must always be used in an initializer if they are defined, and omitting them is a compile-time error:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">veryGreen</span> = <span class="nv">Color</span>(<span class="m">0.0</span>, <span class="m">1.0</span>, <span class="m">0.0</span>)
</li><li><span class="c">// this reports a compile-time error - argument labels are required</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID210">
<h3>Initializer Parameters Without Argument Labels<a class="headerlink" href="Initialization.html#ID210" title="Permalink to this headline">¶</a></h3>
<p>If you do not want to use an argument label for an initializer parameter, write an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) instead of an explicit argument label for that parameter to override the default behavior.</p>
<p>Here’s an expanded version of the <code class="docutils literal notranslate"><span class="pre">Celsius</span></code> example from <a class="reference internal" href="Initialization.html#ID208"><span class="std std-ref">Initialization Parameters</span></a> above, with an additional initializer to create a new <code class="docutils literal notranslate"><span class="pre">Celsius</span></code> instance from a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value that is already in the Celsius scale:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Celsius</span> {
</li><li> <span class="k">var</span> <span class="nv">temperatureInCelsius</span>: <span class="nc">Double</span>
</li><li> <span class="k">init</span>(<span class="nv">fromFahrenheit</span> <span class="nv">fahrenheit</span>: <span class="nc">Double</span>) {
</li><li> <span class="nv">temperatureInCelsius</span> = (<span class="nv">fahrenheit</span> - <span class="m">32.0</span>) / <span class="m">1.8</span>
</li><li>    }
</li><li> <span class="k">init</span>(<span class="nv">fromKelvin</span> <span class="nv">kelvin</span>: <span class="nc">Double</span>) {
</li><li> <span class="nv">temperatureInCelsius</span> = <span class="nv">kelvin</span> - <span class="m">273.15</span>
</li><li>    }
</li><li> <span class="k">init</span>(<span class="k">_</span> <span class="nv">celsius</span>: <span class="nc">Double</span>) {
</li><li> <span class="nv">temperatureInCelsius</span> = <span class="nv">celsius</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">bodyTemperature</span> = <span class="nv">Celsius</span>(<span class="m">37.0</span>)
</li><li><span class="c">// bodyTemperature.temperatureInCelsius is 37.0</span>
</li></ol></div></div></div>
<p>The initializer call <code class="docutils literal notranslate"><span class="pre">Celsius(37.0)</span></code> is clear in its intent without the need for an argument label. It is therefore appropriate to write this initializer as <code class="docutils literal notranslate"><span class="pre">init(_</span> <span class="pre">celsius:</span> <span class="pre">Double)</span></code> so that it can be called by providing an unnamed <code class="docutils literal notranslate"><span class="pre">Double</span></code> value.</p>
</div>
<div class="section" id="ID211">
<h3>Optional Property Types<a class="headerlink" href="Initialization.html#ID211" title="Permalink to this headline">¶</a></h3>
<p>If your custom type has a stored property that is logically allowed to have “no value”—perhaps because its value cannot be set during initialization, or because it is allowed to have “no value” at some later point—declare the property with an <em>optional</em> type. Properties of optional type are automatically initialized with a value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, indicating that the property is deliberately intended to have “no value yet” during initialization.</p>
<p>The following example defines a class called <code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code>, with an optional <code class="docutils literal notranslate"><span class="pre">String</span></code> property called <code class="docutils literal notranslate"><span class="pre">response</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SurveyQuestion</span> {
</li><li> <span class="k">var</span> <span class="nv">text</span>: <span class="nc">String</span>
</li><li> <span class="k">var</span> <span class="nv">response</span>: <span class="nc">String</span>?
</li><li> <span class="k">init</span>(<span class="nv">text</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">text</span> = <span class="nv">text</span>
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">ask</span>() {
</li><li> <span class="nv">print</span>(<span class="nv">text</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">cheeseQuestion</span> = <span class="nv">SurveyQuestion</span>(<span class="nv">text</span>: <span class="s">"Do you like cheese?"</span>)
</li><li><span class="nv">cheeseQuestion</span>.<span class="nv">ask</span>()
</li><li><span class="c">// Prints "Do you like cheese?"</span>
</li><li><span class="nv">cheeseQuestion</span>.<span class="nv">response</span> = <span class="s">"Yes, I do like cheese."</span>
</li></ol></div></div></div>
<p>The response to a survey question cannot be known until it is asked, and so the <code class="docutils literal notranslate"><span class="pre">response</span></code> property is declared with a type of <code class="docutils literal notranslate"><span class="pre">String?</span></code>, or “optional <code class="docutils literal notranslate"><span class="pre">String</span></code>”. It is automatically assigned a default value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, meaning “no string yet”, when a new instance of <code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code> is initialized.</p>
</div>
<div class="section" id="ID212">
<h3>Assigning Constant Properties During Initialization<a class="headerlink" href="Initialization.html#ID212" title="Permalink to this headline">¶</a></h3>
<p>You can assign a value to a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes. Once a constant property is assigned a value, it can’t be further modified.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For class instances, a constant property can be modified during initialization only by the class that introduces it. It cannot be modified by a subclass.</p>
</div>
<p>You can revise the <code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code> example from above to use a constant property rather than a variable property for the <code class="docutils literal notranslate"><span class="pre">text</span></code> property of the question, to indicate that the question does not change once an instance of <code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code> is created. Even though the <code class="docutils literal notranslate"><span class="pre">text</span></code> property is now a constant, it can still be set within the class’s initializer:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SurveyQuestion</span> {
</li><li> <span class="k">let</span> <span class="nv">text</span>: <span class="nc">String</span>
</li><li> <span class="k">var</span> <span class="nv">response</span>: <span class="nc">String</span>?
</li><li> <span class="k">init</span>(<span class="nv">text</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">text</span> = <span class="nv">text</span>
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">ask</span>() {
</li><li> <span class="nv">print</span>(<span class="nv">text</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">beetsQuestion</span> = <span class="nv">SurveyQuestion</span>(<span class="nv">text</span>: <span class="s">"How about beets?"</span>)
</li><li><span class="nv">beetsQuestion</span>.<span class="nv">ask</span>()
</li><li><span class="c">// Prints "How about beets?"</span>
</li><li><span class="nv">beetsQuestion</span>.<span class="nv">response</span> = <span class="s">"I also like beets. (But not with cheese.)"</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID213">
<h2>Default Initializers<a class="headerlink" href="Initialization.html#ID213" title="Permalink to this headline">¶</a></h2>
<p>Swift provides a <em>default initializer</em> for any structure or class that provides default values for all of its properties and does not provide at least one initializer itself. The default initializer simply creates a new instance with all of its properties set to their default values.</p>
<p>This example defines a class called <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>, which encapsulates the name, quantity, and purchase state of an item in a shopping list:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">ShoppingListItem</span> {
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>?
</li><li> <span class="k">var</span> <span class="nv">quantity</span> = <span class="m">1</span>
</li><li> <span class="k">var</span> <span class="nv">purchased</span> = <span class="k">false</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">item</span> = <span class="nv">ShoppingListItem</span>()
</li></ol></div></div></div>
<p>Because all properties of the <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> class have default values, and because it is a base class with no superclass, <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> automatically gains a default initializer implementation that creates a new instance with all of its properties set to their default values. (The <code class="docutils literal notranslate"><span class="pre">name</span></code> property is an optional <code class="docutils literal notranslate"><span class="pre">String</span></code> property, and so it automatically receives a default value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, even though this value is not written in the code.) The example above uses the default initializer for the <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> class to create a new instance of the class with initializer syntax, written as <code class="docutils literal notranslate"><span class="pre">ShoppingListItem()</span></code>, and assigns this new instance to a variable called <code class="docutils literal notranslate"><span class="pre">item</span></code>.</p>
<div class="section" id="ID214">
<h3>Memberwise Initializers for Structure Types<a class="headerlink" href="Initialization.html#ID214" title="Permalink to this headline">¶</a></h3>
<p>Structure types automatically receive a <em>memberwise initializer</em> if they do not define any of their own custom initializers. Unlike a default initializer, the structure receives a memberwise initializer even if it has stored properties that do not have default values.</p>
<p>The memberwise initializer is a shorthand way to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name.</p>
<p>The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">Size</span></code> with two properties called <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code>. Both properties are inferred to be of type <code class="docutils literal notranslate"><span class="pre">Double</span></code> by assigning a default value of <code class="docutils literal notranslate"><span class="pre">0.0</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Size</span></code> structure automatically receives an <code class="docutils literal notranslate"><span class="pre">init(width:height:)</span></code> memberwise initializer, which you can use to initialize a new <code class="docutils literal notranslate"><span class="pre">Size</span></code> instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Size</span> {
</li><li> <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>
</li><li>}
</li><li><span class="k">let</span> <span class="nv">twoByTwo</span> = <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">2.0</span>, <span class="nv">height</span>: <span class="m">2.0</span>)
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID215">
<h2>Initializer Delegation for Value Types<a class="headerlink" href="Initialization.html#ID215" title="Permalink to this headline">¶</a></h2>
<p>Initializers can call other initializers to perform part of an instance’s initialization. This process, known as <em>initializer delegation</em>, avoids duplicating code across multiple initializers.</p>
<p>The rules for how initializer delegation works, and for what forms of delegation are allowed, are different for value types and class types. Value types (structures and enumerations) do not support inheritance, and so their initializer delegation process is relatively simple, because they can only delegate to another initializer that they provide themselves. Classes, however, can inherit from other classes, as described in <a class="reference internal" href="Inheritance.html"><span class="doc">Inheritance</span></a>. This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization. These responsibilities are described in <a class="reference internal" href="Initialization.html#ID216"><span class="std std-ref">Class Inheritance and Initialization</span></a> below.</p>
<p>For value types, you use <code class="docutils literal notranslate"><span class="pre">self.init</span></code> to refer to other initializers from the same value type when writing your own custom initializers. You can call <code class="docutils literal notranslate"><span class="pre">self.init</span></code> only from within an initializer.</p>
<p>Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it is a structure) for that type. This constraint prevents a situation in which additional essential setup provided in a more complex initializer is accidentally circumvented by someone using one of the automatic initializers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation. For more information, see <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>.</p>
</div>
<p>The following example defines a custom <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure to represent a geometric rectangle. The example requires two supporting structures called <code class="docutils literal notranslate"><span class="pre">Size</span></code> and <code class="docutils literal notranslate"><span class="pre">Point</span></code>, both of which provide default values of <code class="docutils literal notranslate"><span class="pre">0.0</span></code> for all of their properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Size</span> {
</li><li> <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li> <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>}
</li></ol></div></div></div>
<p>You can initialize the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure below in one of three ways—by using its default zero-initialized <code class="docutils literal notranslate"><span class="pre">origin</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> property values, by providing a specific origin point and size, or by providing a specific center point and size. These initialization options are represented by three custom initializers that are part of the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure’s definition:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Rect</span> {
</li><li> <span class="k">var</span> <span class="nv">origin</span> = <span class="nv">Point</span>()
</li><li> <span class="k">var</span> <span class="nv">size</span> = <span class="nv">Size</span>()
</li><li> <span class="k">init</span>() {}
</li><li> <span class="k">init</span>(<span class="nv">origin</span>: <span class="nc">Point</span>, <span class="nv">size</span>: <span class="nc">Size</span>) {
</li><li> <span class="k">self</span>.<span class="nv">origin</span> = <span class="nv">origin</span>
</li><li> <span class="k">self</span>.<span class="nv">size</span> = <span class="nv">size</span>
</li><li>    }
</li><li> <span class="k">init</span>(<span class="nv">center</span>: <span class="nc">Point</span>, <span class="nv">size</span>: <span class="nc">Size</span>) {
</li><li> <span class="k">let</span> <span class="nv">originX</span> = <span class="nv">center</span>.<span class="nv">x</span> - (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li> <span class="k">let</span> <span class="nv">originY</span> = <span class="nv">center</span>.<span class="nv">y</span> - (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li> <span class="k">self</span>.<span class="nv">init</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">originX</span>, <span class="nv">y</span>: <span class="nv">originY</span>), <span class="nv">size</span>: <span class="nv">size</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The first <code class="docutils literal notranslate"><span class="pre">Rect</span></code> initializer, <code class="docutils literal notranslate"><span class="pre">init()</span></code>, is functionally the same as the default initializer that the structure would have received if it did not have its own custom initializers. This initializer has an empty body, represented by an empty pair of curly braces <code class="docutils literal notranslate"><span class="pre">{}</span></code>. Calling this initializer returns a <code class="docutils literal notranslate"><span class="pre">Rect</span></code> instance whose <code class="docutils literal notranslate"><span class="pre">origin</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> properties are both initialized with the default values of <code class="docutils literal notranslate"><span class="pre">Point(x:</span> <span class="pre">0.0,</span> <span class="pre">y:</span> <span class="pre">0.0)</span></code> and <code class="docutils literal notranslate"><span class="pre">Size(width:</span> <span class="pre">0.0,</span> <span class="pre">height:</span> <span class="pre">0.0)</span></code> from their property definitions:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">basicRect</span> = <span class="nv">Rect</span>()
</li><li><span class="c">// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)</span>
</li></ol></div></div></div>
<p>The second <code class="docutils literal notranslate"><span class="pre">Rect</span></code> initializer, <code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code>, is functionally the same as the memberwise initializer that the structure would have received if it did not have its own custom initializers. This initializer simply assigns the <code class="docutils literal notranslate"><span class="pre">origin</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> argument values to the appropriate stored properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">originRect</span> = <span class="nv">Rect</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>),
</li><li> <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">5.0</span>, <span class="nv">height</span>: <span class="m">5.0</span>))
</li><li><span class="c">// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)</span>
</li></ol></div></div></div>
<p>The third <code class="docutils literal notranslate"><span class="pre">Rect</span></code> initializer, <code class="docutils literal notranslate"><span class="pre">init(center:size:)</span></code>, is slightly more complex. It starts by calculating an appropriate origin point based on a <code class="docutils literal notranslate"><span class="pre">center</span></code> point and a <code class="docutils literal notranslate"><span class="pre">size</span></code> value. It then calls (or <em>delegates</em>) to the <code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code> initializer, which stores the new origin and size values in the appropriate properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">centerRect</span> = <span class="nv">Rect</span>(<span class="nv">center</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">4.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>),
</li><li> <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">3.0</span>, <span class="nv">height</span>: <span class="m">3.0</span>))
</li><li><span class="c">// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">init(center:size:)</span></code> initializer could have assigned the new values of <code class="docutils literal notranslate"><span class="pre">origin</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> to the appropriate properties itself. However, it is more convenient (and clearer in intent) for the <code class="docutils literal notranslate"><span class="pre">init(center:size:)</span></code> initializer to take advantage of an existing initializer that already provides exactly that functionality.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For an alternative way to write this example without defining the <code class="docutils literal notranslate"><span class="pre">init()</span></code> and <code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code> initializers yourself, see <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>.</p>
</div>
</div>
<div class="section" id="ID216">
<h2>Class Inheritance and Initialization<a class="headerlink" href="Initialization.html#ID216" title="Permalink to this headline">¶</a></h2>
<p>All of a class’s stored properties—including any properties the class inherits from its superclass—<em>must</em> be assigned an initial value during initialization.</p>
<p>Swift defines two kinds of initializers for class types to help ensure all stored properties receive an initial value. These are known as designated initializers and convenience initializers.</p>
<div class="section" id="ID217">
<h3>Designated Initializers and Convenience Initializers<a class="headerlink" href="Initialization.html#ID217" title="Permalink to this headline">¶</a></h3>
<p><em>Designated initializers</em> are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</p>
<p>Classes tend to have very few designated initializers, and it is quite common for a class to have only one. Designated initializers are “funnel” points through which initialization takes place, and through which the initialization process continues up the superclass chain.</p>
<p>Every class must have at least one designated initializer. In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass, as described in <a class="reference internal" href="Initialization.html#ID222"><span class="std std-ref">Automatic Initializer Inheritance</span></a> below.</p>
<p><em>Convenience initializers</em> are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</p>
<p>You do not have to provide convenience initializers if your class does not require them. Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent.</p>
</div>
<div class="section" id="ID218">
<h3>Syntax for Designated and Convenience Initializers<a class="headerlink" href="Initialization.html#ID218" title="Permalink to this headline">¶</a></h3>
<p>Designated initializers for classes are written in the same way as simple initializers for value types:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">init</span>(<span class="gi">parameters</span>) {
</li><li> <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>Convenience initializers are written in the same style, but with the <code class="docutils literal notranslate"><span class="pre">convenience</span></code> modifier placed before the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword, separated by a space:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">convenience</span> <span class="k">init</span>(<span class="gi">parameters</span>) {
</li><li> <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID219">
<h3>Initializer Delegation for Class Types<a class="headerlink" href="Initialization.html#ID219" title="Permalink to this headline">¶</a></h3>
<p>To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:</p>
<dl class="docutils">
<dt><strong>Rule 1</strong></dt>
<dd>A designated initializer must call a designated initializer from its immediate superclass.</dd>
<dt><strong>Rule 2</strong></dt>
<dd>A convenience initializer must call another initializer from the <em>same</em> class.</dd>
<dt><strong>Rule 3</strong></dt>
<dd>A convenience initializer must ultimately call a designated initializer.</dd>
</dl>
<p>A simple way to remember this is:</p>
<ul class="simple">
<li>Designated initializers must always delegate <em>up</em>.</li>
<li>Convenience initializers must always delegate <em>across</em>.</li>
</ul>
<p>These rules are illustrated in the figure below:</p>
<img alt="../_images/initializerDelegation01_2x.png" class="align-center" src="../_images/initializerDelegation01_2x.png" style="width: 448px;"/>
<p>Here, the superclass has a single designated initializer and two convenience initializers. One convenience initializer calls another convenience initializer, which in turn calls the single designated initializer. This satisfies rules 2 and 3 from above. The superclass does not itself have a further superclass, and so rule 1 does not apply.</p>
<p>The subclass in this figure has two designated initializers and one convenience initializer. The convenience initializer must call one of the two designated initializers, because it can only call another initializer from the same class. This satisfies rules 2 and 3 from above. Both designated initializers must call the single designated initializer from the superclass, to satisfy rule 1 from above.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These rules don’t affect how users of your classes <em>create</em> instances of each class. Any initializer in the diagram above can be used to create a fully-initialized instance of the class they belong to. The rules only affect how you write the implementation of the class’s initializers.</p>
</div>
<p>The figure below shows a more complex class hierarchy for four classes. It illustrates how the designated initializers in this hierarchy act as “funnel” points for class initialization, simplifying the interrelationships among classes in the chain:</p>
<img alt="../_images/initializerDelegation02_2x.png" class="align-center" src="../_images/initializerDelegation02_2x.png" style="width: 448px;"/>
</div>
<div class="section" id="ID220">
<h3>Two-Phase Initialization<a class="headerlink" href="Initialization.html#ID220" title="Permalink to this headline">¶</a></h3>
<p>Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.</p>
<p>The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy. Two-phase initialization prevents property values from being accessed before they are initialized, and prevents property values from being set to a different value by another initializer unexpectedly.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Swift’s two-phase initialization process is similar to initialization in Objective-C. The main difference is that during phase 1, Objective-C assigns zero or null values (such as <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">nil</span></code>) to every property. Swift’s initialization flow is more flexible in that it lets you set custom initial values, and can cope with types for which <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">nil</span></code> is not a valid default value.</p>
</div>
<p>Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error:</p>
<dl class="docutils">
<dt><strong>Safety check 1</strong></dt>
<dd>A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.</dd>
</dl>
<p>As mentioned above, the memory for an object is only considered fully initialized once the initial state of all of its stored properties is known. In order for this rule to be satisfied, a designated initializer must make sure that all of its own properties are initialized before it hands off up the chain.</p>
<dl class="docutils">
<dt><strong>Safety check 2</strong></dt>
<dd>A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.</dd>
<dt><strong>Safety check 3</strong></dt>
<dd>A convenience initializer must delegate to another initializer before assigning a value to <em>any</em> property (including properties defined by the same class). If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.</dd>
<dt><strong>Safety check 4</strong></dt>
<dd>An initializer cannot call any instance methods, read the values of any instance properties, or refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> as a value until after the first phase of initialization is complete.</dd>
</dl>
<p>The class instance is not fully valid until the first phase ends. Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.</p>
<p>Here’s how two-phase initialization plays out, based on the four safety checks above:</p>
<p><strong>Phase 1</strong></p>
<ul class="simple">
<li>A designated or convenience initializer is called on a class.</li>
<li>Memory for a new instance of that class is allocated. The memory is not yet initialized.</li>
<li>A designated initializer for that class confirms that all stored properties introduced by that class have a value. The memory for these stored properties is now initialized.</li>
<li>The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties.</li>
<li>This continues up the class inheritance chain until the top of the chain is reached.</li>
<li>Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete.</li>
</ul>
<p><strong>Phase 2</strong></p>
<ul class="simple">
<li>Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access <code class="docutils literal notranslate"><span class="pre">self</span></code> and can modify its properties, call its instance methods, and so on.</li>
<li>Finally, any convenience initializers in the chain have the option to customize the instance and to work with <code class="docutils literal notranslate"><span class="pre">self</span></code>.</li>
</ul>
<p>Here’s how phase 1 looks for an initialization call for a hypothetical subclass and superclass:</p>
<img alt="../_images/twoPhaseInitialization01_2x.png" class="align-center" src="../_images/twoPhaseInitialization01_2x.png" style="width: 448px;"/>
<p>In this example, initialization begins with a call to a convenience initializer on the subclass. This convenience initializer cannot yet modify any properties. It delegates across to a designated initializer from the same class.</p>
<p>The designated initializer makes sure that all of the subclass’s properties have a value, as per safety check 1. It then calls a designated initializer on its superclass to continue the initialization up the chain.</p>
<p>The superclass’s designated initializer makes sure that all of the superclass properties have a value. There are no further superclasses to initialize, and so no further delegation is needed.</p>
<p>As soon as all properties of the superclass have an initial value, its memory is considered fully initialized, and phase 1 is complete.</p>
<p>Here’s how phase 2 looks for the same initialization call:</p>
<img alt="../_images/twoPhaseInitialization02_2x.png" class="align-center" src="../_images/twoPhaseInitialization02_2x.png" style="width: 448px;"/>
<p>The superclass’s designated initializer now has an opportunity to customize the instance further (although it does not have to).</p>
<p>Once the superclass’s designated initializer is finished, the subclass’s designated initializer can perform additional customization (although again, it does not have to).</p>
<p>Finally, once the subclass’s designated initializer is finished, the convenience initializer that was originally called can perform additional customization.</p>
</div>
<div class="section" id="ID221">
<h3>Initializer Inheritance and Overriding<a class="headerlink" href="Initialization.html#ID221" title="Permalink to this headline">¶</a></h3>
<p>Unlike subclasses in Objective-C, Swift subclasses do not inherit their superclass initializers by default. Swift’s approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that is not fully or correctly initialized.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Superclass initializers <em>are</em> inherited in certain circumstances, but only when it is safe and appropriate to do so. For more information, see <a class="reference internal" href="Initialization.html#ID222"><span class="std std-ref">Automatic Initializer Inheritance</span></a> below.</p>
</div>
<p>If you want a custom subclass to present one or more of the same initializers as its superclass, you can provide a custom implementation of those initializers within the subclass.</p>
<p>When you write a subclass initializer that matches a superclass <em>designated</em> initializer, you are effectively providing an override of that designated initializer. Therefore, you must write the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier before the subclass’s initializer definition. This is true even if you are overriding an automatically provided default initializer, as described in <a class="reference internal" href="Initialization.html#ID213"><span class="std std-ref">Default Initializers</span></a>.</p>
<p>As with an overridden property, method or subscript, the presence of the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier prompts Swift to check that the superclass has a matching designated initializer to be overridden, and validates that the parameters for your overriding initializer have been specified as intended.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You always write the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier when overriding a superclass designated initializer, even if your subclass’s implementation of the initializer is a convenience initializer.</p>
</div>
<p>Conversely, if you write a subclass initializer that matches a superclass <em>convenience</em> initializer, that superclass convenience initializer can never be called directly by your subclass, as per the rules described above in <a class="reference internal" href="Initialization.html#ID219"><span class="std std-ref">Initializer Delegation for Class Types</span></a>. Therefore, your subclass is not (strictly speaking) providing an override of the superclass initializer. As a result, you do not write the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier when providing a matching implementation of a superclass convenience initializer.</p>
<p>The example below defines a base class called <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>. This base class declares a stored property called <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code>, with a default <code class="docutils literal notranslate"><span class="pre">Int</span></code> value of <code class="docutils literal notranslate"><span class="pre">0</span></code>. The <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code> property is used by a computed property called <code class="docutils literal notranslate"><span class="pre">description</span></code> to create a <code class="docutils literal notranslate"><span class="pre">String</span></code> description of the vehicle’s characteristics:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Vehicle</span> {
</li><li> <span class="k">var</span> <span class="nv">numberOfWheels</span> = <span class="m">0</span>
</li><li> <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="s">"</span>\<span class="p">(</span><span class="nv">numberOfWheels</span><span class="p">)</span><span class="s"> wheel(s)"</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> class provides a default value for its only stored property, and does not provide any custom initializers itself. As a result, it automatically receives a default initializer, as described in <a class="reference internal" href="Initialization.html#ID213"><span class="std std-ref">Default Initializers</span></a>. The default initializer (when available) is always a designated initializer for a class, and can be used to create a new <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> instance with a <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code> of <code class="docutils literal notranslate"><span class="pre">0</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">vehicle</span> = <span class="nv">Vehicle</span>()
</li><li><span class="nv">print</span>(<span class="s">"Vehicle: </span>\<span class="p">(</span><span class="nv">vehicle</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Vehicle: 0 wheel(s)</span>
</li></ol></div></div></div>
<p>The next example defines a subclass of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> called <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Bicycle</span>: <span class="nc">Vehicle</span> {
</li><li> <span class="k">override</span> <span class="k">init</span>() {
</li><li> <span class="k">super</span>.<span class="nv">init</span>()
</li><li> <span class="nv">numberOfWheels</span> = <span class="m">2</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> subclass defines a custom designated initializer, <code class="docutils literal notranslate"><span class="pre">init()</span></code>. This designated initializer matches a designated initializer from the superclass of <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>, and so the <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> version of this initializer is marked with the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">init()</span></code> initializer for <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> starts by calling <code class="docutils literal notranslate"><span class="pre">super.init()</span></code>, which calls the default initializer for the <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> class’s superclass, <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>. This ensures that the <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code> inherited property is initialized by <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> before <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> has the opportunity to modify the property. After calling <code class="docutils literal notranslate"><span class="pre">super.init()</span></code>, the original value of <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code> is replaced with a new value of <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
<p>If you create an instance of <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>, you can call its inherited <code class="docutils literal notranslate"><span class="pre">description</span></code> computed property to see how its <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code> property has been updated:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">bicycle</span> = <span class="nv">Bicycle</span>()
</li><li><span class="nv">print</span>(<span class="s">"Bicycle: </span>\<span class="p">(</span><span class="nv">bicycle</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Bicycle: 2 wheel(s)</span>
</li></ol></div></div></div>
<p>If a subclass initializer performs no customization in phase 2 of the initialization process, and the superclass has a zero-argument designated initializer, you can omit a call to <code class="docutils literal notranslate"><span class="pre">super.init()</span></code> after assigning values to all of the subclass’s stored properties.</p>
<p>This example defines another subclass of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>, called <code class="docutils literal notranslate"><span class="pre">Hoverboard</span></code>. In its initializer, the <code class="docutils literal notranslate"><span class="pre">Hoverboard</span></code> class sets only its <code class="docutils literal notranslate"><span class="pre">color</span></code> property. Instead of making an explicit call to <code class="docutils literal notranslate"><span class="pre">super.init()</span></code>, this initializer relies on an implicit call to its superclass’s initializer to complete the process.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Hoverboard</span>: <span class="nc">Vehicle</span> {
</li><li> <span class="k">var</span> <span class="nv">color</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">color</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">color</span> = <span class="nv">color</span>
</li><li> <span class="c">// super.init() implicitly called here</span>
</li><li>    }
</li><li> <span class="k">override</span> <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="s">"</span>\<span class="p">(</span><span class="k">super</span>.<span class="nv">description</span><span class="p">)</span><span class="s"> in a beautiful </span>\<span class="p">(</span><span class="nv">color</span><span class="p">)</span><span class="s">"</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>An instance of <code class="docutils literal notranslate"><span class="pre">Hoverboard</span></code> uses the default number of wheels supplied by the <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> initializer.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">hoverboard</span> = <span class="nv">Hoverboard</span>(<span class="nv">color</span>: <span class="s">"silver"</span>)
</li><li><span class="nv">print</span>(<span class="s">"Hoverboard: </span>\<span class="p">(</span><span class="nv">hoverboard</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Hoverboard: 0 wheel(s) in a beautiful silver</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Subclasses can modify inherited variable properties during initialization, but can not modify inherited constant properties.</p>
</div>
</div>
<div class="section" id="ID222">
<h3>Automatic Initializer Inheritance<a class="headerlink" href="Initialization.html#ID222" title="Permalink to this headline">¶</a></h3>
<p>As mentioned above, subclasses do not inherit their superclass initializers by default. However, superclass initializers <em>are</em> automatically inherited if certain conditions are met. In practice, this means that you do not need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it is safe to do so.</p>
<p>Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:</p>
<dl class="docutils">
<dt><strong>Rule 1</strong></dt>
<dd>If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers.</dd>
<dt><strong>Rule 2</strong></dt>
<dd>If your subclass provides an implementation of <em>all</em> of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.</dd>
</dl>
<p>These rules apply even if your subclass adds further convenience initializers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.</p>
</div>
</div>
<div class="section" id="ID223">
<h3>Designated and Convenience Initializers in Action<a class="headerlink" href="Initialization.html#ID223" title="Permalink to this headline">¶</a></h3>
<p>The following example shows designated initializers, convenience initializers, and automatic initializer inheritance in action. This example defines a hierarchy of three classes called <code class="docutils literal notranslate"><span class="pre">Food</span></code>, <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>, and <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>, and demonstrates how their initializers interact.</p>
<p>The base class in the hierarchy is called <code class="docutils literal notranslate"><span class="pre">Food</span></code>, which is a simple class to encapsulate the name of a foodstuff. The <code class="docutils literal notranslate"><span class="pre">Food</span></code> class introduces a single <code class="docutils literal notranslate"><span class="pre">String</span></code> property called <code class="docutils literal notranslate"><span class="pre">name</span></code> and provides two initializers for creating <code class="docutils literal notranslate"><span class="pre">Food</span></code> instances:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Food</span> {
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>    }
</li><li> <span class="k">convenience</span> <span class="k">init</span>() {
</li><li> <span class="k">self</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="s">"[Unnamed]"</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The figure below shows the initializer chain for the <code class="docutils literal notranslate"><span class="pre">Food</span></code> class:</p>
<img alt="../_images/initializersExample01_2x.png" class="align-center" src="../_images/initializersExample01_2x.png" style="width: 482px;"/>
<p>Classes do not have a default memberwise initializer, and so the <code class="docutils literal notranslate"><span class="pre">Food</span></code> class provides a designated initializer that takes a single argument called <code class="docutils literal notranslate"><span class="pre">name</span></code>. This initializer can be used to create a new <code class="docutils literal notranslate"><span class="pre">Food</span></code> instance with a specific name:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">namedMeat</span> = <span class="nv">Food</span>(<span class="nv">name</span>: <span class="s">"Bacon"</span>)
</li><li><span class="c">// namedMeat's name is "Bacon"</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> initializer from the <code class="docutils literal notranslate"><span class="pre">Food</span></code> class is provided as a <em>designated</em> initializer, because it ensures that all stored properties of a new <code class="docutils literal notranslate"><span class="pre">Food</span></code> instance are fully initialized. The <code class="docutils literal notranslate"><span class="pre">Food</span></code> class does not have a superclass, and so the <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> initializer does not need to call <code class="docutils literal notranslate"><span class="pre">super.init()</span></code> to complete its initialization.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Food</span></code> class also provides a <em>convenience</em> initializer, <code class="docutils literal notranslate"><span class="pre">init()</span></code>, with no arguments. The <code class="docutils literal notranslate"><span class="pre">init()</span></code> initializer provides a default placeholder name for a new food by delegating across to the <code class="docutils literal notranslate"><span class="pre">Food</span></code> class’s <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> with a <code class="docutils literal notranslate"><span class="pre">name</span></code> value of <code class="docutils literal notranslate"><span class="pre">[Unnamed]</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">mysteryMeat</span> = <span class="nv">Food</span>()
</li><li><span class="c">// mysteryMeat's name is "[Unnamed]"</span>
</li></ol></div></div></div>
<p>The second class in the hierarchy is a subclass of <code class="docutils literal notranslate"><span class="pre">Food</span></code> called <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>. The <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> class models an ingredient in a cooking recipe. It introduces an <code class="docutils literal notranslate"><span class="pre">Int</span></code> property called <code class="docutils literal notranslate"><span class="pre">quantity</span></code> (in addition to the <code class="docutils literal notranslate"><span class="pre">name</span></code> property it inherits from <code class="docutils literal notranslate"><span class="pre">Food</span></code>) and defines two initializers for creating <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instances:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">RecipeIngredient</span>: <span class="nc">Food</span> {
</li><li> <span class="k">var</span> <span class="nv">quantity</span>: <span class="nc">Int</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">quantity</span>: <span class="nc">Int</span>) {
</li><li> <span class="k">self</span>.<span class="nv">quantity</span> = <span class="nv">quantity</span>
</li><li> <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="nv">name</span>)
</li><li>    }
</li><li> <span class="k">override</span> <span class="k">convenience</span> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="nv">name</span>, <span class="nv">quantity</span>: <span class="m">1</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The figure below shows the initializer chain for the <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> class:</p>
<img alt="../_images/initializersExample02_2x.png" class="align-center" src="../_images/initializersExample02_2x.png" style="width: 482px;"/>
<p>The <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> class has a single designated initializer, <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String,</span> <span class="pre">quantity:</span> <span class="pre">Int)</span></code>, which can be used to populate all of the properties of a new <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instance. This initializer starts by assigning the passed <code class="docutils literal notranslate"><span class="pre">quantity</span></code> argument to the <code class="docutils literal notranslate"><span class="pre">quantity</span></code> property, which is the only new property introduced by <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>. After doing so, the initializer delegates up to the <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> initializer of the <code class="docutils literal notranslate"><span class="pre">Food</span></code> class. This process satisfies safety check 1 from <a class="reference internal" href="Initialization.html#ID220"><span class="std std-ref">Two-Phase Initialization</span></a> above.</p>
<p><code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> also defines a convenience initializer, <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>, which is used to create a <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instance by name alone. This convenience initializer assumes a quantity of <code class="docutils literal notranslate"><span class="pre">1</span></code> for any <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instance that is created without an explicit quantity. The definition of this convenience initializer makes <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instances quicker and more convenient to create, and avoids code duplication when creating several single-quantity <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instances. This convenience initializer simply delegates across to the class’s designated initializer, passing in a <code class="docutils literal notranslate"><span class="pre">quantity</span></code> value of <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> convenience initializer provided by <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> takes the same parameters as the <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> <em>designated</em> initializer from <code class="docutils literal notranslate"><span class="pre">Food</span></code>. Because this convenience initializer overrides a designated initializer from its superclass, it must be marked with the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier (as described in <a class="reference internal" href="Initialization.html#ID221"><span class="std std-ref">Initializer Inheritance and Overriding</span></a>).</p>
<p>Even though <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> provides the <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> initializer as a convenience initializer, <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> has nonetheless provided an implementation of all of its superclass’s designated initializers. Therefore, <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> automatically inherits all of its superclass’s convenience initializers too.</p>
<p>In this example, the superclass for <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> is <code class="docutils literal notranslate"><span class="pre">Food</span></code>, which has a single convenience initializer called <code class="docutils literal notranslate"><span class="pre">init()</span></code>. This initializer is therefore inherited by <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>. The inherited version of <code class="docutils literal notranslate"><span class="pre">init()</span></code> functions in exactly the same way as the <code class="docutils literal notranslate"><span class="pre">Food</span></code> version, except that it delegates to the <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> version of <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> rather than the <code class="docutils literal notranslate"><span class="pre">Food</span></code> version.</p>
<p>All three of these initializers can be used to create new <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instances:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">oneMysteryItem</span> = <span class="nv">RecipeIngredient</span>()
</li><li><span class="k">let</span> <span class="nv">oneBacon</span> = <span class="nv">RecipeIngredient</span>(<span class="nv">name</span>: <span class="s">"Bacon"</span>)
</li><li><span class="k">let</span> <span class="nv">sixEggs</span> = <span class="nv">RecipeIngredient</span>(<span class="nv">name</span>: <span class="s">"Eggs"</span>, <span class="nv">quantity</span>: <span class="m">6</span>)
</li></ol></div></div></div>
<p>The third and final class in the hierarchy is a subclass of <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> called <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>. The <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> class models a recipe ingredient as it appears in a shopping list.</p>
<p>Every item in the shopping list starts out as “unpurchased”. To represent this fact, <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> introduces a Boolean property called <code class="docutils literal notranslate"><span class="pre">purchased</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">false</span></code>. <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> also adds a computed <code class="docutils literal notranslate"><span class="pre">description</span></code> property, which provides a textual description of a <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">ShoppingListItem</span>: <span class="nc">RecipeIngredient</span> {
</li><li> <span class="k">var</span> <span class="nv">purchased</span> = <span class="k">false</span>
</li><li> <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li><li> <span class="k">var</span> <span class="nv">output</span> = <span class="s">"</span>\<span class="p">(</span><span class="nv">quantity</span><span class="p">)</span><span class="s"> x </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">"</span>
</li><li> <span class="nv">output</span> += <span class="nv">purchased</span> ? <span class="s">" ✔"</span> : <span class="s">" ✘"</span>
</li><li> <span class="k">return</span> <span class="nv">output</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> does not define an initializer to provide an initial value for <code class="docutils literal notranslate"><span class="pre">purchased</span></code>, because items in a shopping list (as modeled here) always start out unpurchased.</p>
</div>
<p>Because it provides a default value for all of the properties it introduces and does not define any initializers itself, <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> automatically inherits <em>all</em> of the designated and convenience initializers from its superclass.</p>
<p>The figure below shows the overall initializer chain for all three classes:</p>
<img alt="../_images/initializersExample03_2x.png" class="align-center" src="../_images/initializersExample03_2x.png" style="width: 482px;"/>
<p>You can use all three of the inherited initializers to create a new <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">breakfastList</span> = [
</li><li> <span class="nv">ShoppingListItem</span>(),
</li><li> <span class="nv">ShoppingListItem</span>(<span class="nv">name</span>: <span class="s">"Bacon"</span>),
</li><li> <span class="nv">ShoppingListItem</span>(<span class="nv">name</span>: <span class="s">"Eggs"</span>, <span class="nv">quantity</span>: <span class="m">6</span>),
</li><li>]
</li><li><span class="nv">breakfastList</span>[<span class="m">0</span>].<span class="nv">name</span> = <span class="s">"Orange juice"</span>
</li><li><span class="nv">breakfastList</span>[<span class="m">0</span>].<span class="nv">purchased</span> = <span class="k">true</span>
</li><li><span class="k">for</span> <span class="nv">item</span> <span class="k">in</span> <span class="nv">breakfastList</span> {
</li><li> <span class="nv">print</span>(<span class="nv">item</span>.<span class="nv">description</span>)
</li><li>}
</li><li><span class="c">// 1 x Orange juice ✔</span>
</li><li><span class="c">// 1 x Bacon ✘</span>
</li><li><span class="c">// 6 x Eggs ✘</span>
</li></ol></div></div></div>
<p>Here, a new array called <code class="docutils literal notranslate"><span class="pre">breakfastList</span></code> is created from an array literal containing three new <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> instances. The type of the array is inferred to be <code class="docutils literal notranslate"><span class="pre">[ShoppingListItem]</span></code>. After the array is created, the name of the <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> at the start of the array is changed from <code class="docutils literal notranslate"><span class="pre">"[Unnamed]"</span></code> to <code class="docutils literal notranslate"><span class="pre">"Orange</span> <span class="pre">juice"</span></code> and it is marked as having been purchased. Printing the description of each item in the array shows that their default states have been set as expected.</p>
</div>
</div>
<div class="section" id="ID224">
<h2>Failable Initializers<a class="headerlink" href="Initialization.html#ID224" title="Permalink to this headline">¶</a></h2>
<p>It is sometimes useful to define a class, structure, or enumeration for which initialization can fail. This failure might be triggered by invalid initialization parameter values, the absence of a required external resource, or some other condition that prevents initialization from succeeding.</p>
<p>To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition. You write a failable initializer by placing a question mark after the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword (<code class="docutils literal notranslate"><span class="pre">init?</span></code>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You cannot define a failable and a nonfailable initializer with the same parameter types and names.</p>
</div>
<p>A failable initializer creates an <em>optional</em> value of the type it initializes. You write <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">nil</span></code> within a failable initializer to indicate a point at which initialization failure can be triggered.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Strictly speaking, initializers do not return a value. Rather, their role is to ensure that <code class="docutils literal notranslate"><span class="pre">self</span></code> is fully and correctly initialized by the time that initialization ends. Although you write <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">nil</span></code> to trigger an initialization failure, you do not use the <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword to indicate initialization success.</p>
</div>
<p>For instance, failable initializers are implemented for numeric type conversions. To ensure conversion between numeric types maintains the value exactly, use the <code class="docutils literal notranslate"><span class="pre">init(exactly:)</span></code> initializer. If the type conversion cannot maintain the value, the initializer fails.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">wholeNumber</span>: <span class="nc">Double</span> = <span class="m">12345.0</span>
</li><li><span class="k">let</span> <span class="nv">pi</span> = <span class="m">3.14159</span>
</li><li>
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">valueMaintained</span> = <span class="nv">Int</span>(<span class="nv">exactly</span>: <span class="nv">wholeNumber</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">wholeNumber</span><span class="p">)</span><span class="s"> conversion to Int maintains value of </span>\<span class="p">(</span><span class="nv">valueMaintained</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Prints "12345.0 conversion to Int maintains value of 12345"</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">valueChanged</span> = <span class="nv">Int</span>(<span class="nv">exactly</span>: <span class="nv">pi</span>)
</li><li><span class="c">// valueChanged is of type Int?, not Int</span>
</li><li>
</li><li><span class="k">if</span> <span class="nv">valueChanged</span> == <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">pi</span><span class="p">)</span><span class="s"> conversion to Int does not maintain value"</span>)
</li><li>}
</li><li><span class="c">// Prints "3.14159 conversion to Int does not maintain value"</span>
</li></ol></div></div></div>
<p>The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">Animal</span></code>, with a constant <code class="docutils literal notranslate"><span class="pre">String</span></code> property called <code class="docutils literal notranslate"><span class="pre">species</span></code>. The <code class="docutils literal notranslate"><span class="pre">Animal</span></code> structure also defines a failable initializer with a single parameter called <code class="docutils literal notranslate"><span class="pre">species</span></code>. This initializer checks if the <code class="docutils literal notranslate"><span class="pre">species</span></code> value passed to the initializer is an empty string. If an empty string is found, an initialization failure is triggered. Otherwise, the <code class="docutils literal notranslate"><span class="pre">species</span></code> property’s value is set, and initialization succeeds:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Animal</span> {
</li><li> <span class="k">let</span> <span class="nv">species</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>?(<span class="nv">species</span>: <span class="nc">String</span>) {
</li><li> <span class="k">if</span> <span class="nv">species</span>.<span class="nv">isEmpty</span> { <span class="k">return</span> <span class="k">nil</span> }
</li><li> <span class="k">self</span>.<span class="nv">species</span> = <span class="nv">species</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>You can use this failable initializer to try to initialize a new <code class="docutils literal notranslate"><span class="pre">Animal</span></code> instance and to check if initialization succeeded:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someCreature</span> = <span class="nv">Animal</span>(<span class="nv">species</span>: <span class="s">"Giraffe"</span>)
</li><li><span class="c">// someCreature is of type Animal?, not Animal</span>
</li><li>
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">giraffe</span> = <span class="nv">someCreature</span> {
</li><li> <span class="nv">print</span>(<span class="s">"An animal was initialized with a species of </span>\<span class="p">(</span><span class="nv">giraffe</span>.<span class="nv">species</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Prints "An animal was initialized with a species of Giraffe"</span>
</li></ol></div></div></div>
<p>If you pass an empty string value to the failable initializer’s <code class="docutils literal notranslate"><span class="pre">species</span></code> parameter, the initializer triggers an initialization failure:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">anonymousCreature</span> = <span class="nv">Animal</span>(<span class="nv">species</span>: <span class="s">""</span>)
</li><li><span class="c">// anonymousCreature is of type Animal?, not Animal</span>
</li><li>
</li><li><span class="k">if</span> <span class="nv">anonymousCreature</span> == <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The anonymous creature could not be initialized"</span>)
</li><li>}
</li><li><span class="c">// Prints "The anonymous creature could not be initialized"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Checking for an empty string value (such as <code class="docutils literal notranslate"><span class="pre">""</span></code> rather than <code class="docutils literal notranslate"><span class="pre">"Giraffe"</span></code>) is not the same as checking for <code class="docutils literal notranslate"><span class="pre">nil</span></code> to indicate the absence of an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">String</span></code> value. In the example above, an empty string (<code class="docutils literal notranslate"><span class="pre">""</span></code>) is a valid, nonoptional <code class="docutils literal notranslate"><span class="pre">String</span></code>. However, it is not appropriate for an animal to have an empty string as the value of its <code class="docutils literal notranslate"><span class="pre">species</span></code> property. To model this restriction, the failable initializer triggers an initialization failure if an empty string is found.</p>
</div>
<div class="section" id="ID225">
<h3>Failable Initializers for Enumerations<a class="headerlink" href="Initialization.html#ID225" title="Permalink to this headline">¶</a></h3>
<p>You can use a failable initializer to select an appropriate enumeration case based on one or more parameters. The initializer can then fail if the provided parameters do not match an appropriate enumeration case.</p>
<p>The example below defines an enumeration called <code class="docutils literal notranslate"><span class="pre">TemperatureUnit</span></code>, with three possible states (<code class="docutils literal notranslate"><span class="pre">kelvin</span></code>, <code class="docutils literal notranslate"><span class="pre">celsius</span></code>, and <code class="docutils literal notranslate"><span class="pre">fahrenheit</span></code>). A failable initializer is used to find an appropriate enumeration case for a <code class="docutils literal notranslate"><span class="pre">Character</span></code> value representing a temperature symbol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">TemperatureUnit</span> {
</li><li> <span class="k">case</span> <span class="nv">kelvin</span>, <span class="nv">celsius</span>, <span class="nv">fahrenheit</span>
</li><li> <span class="k">init</span>?(<span class="nv">symbol</span>: <span class="nc">Character</span>) {
</li><li> <span class="k">switch</span> <span class="nv">symbol</span> {
</li><li> <span class="k">case</span> <span class="s">"K"</span>:
</li><li> <span class="k">self</span> = .<span class="nv">kelvin</span>
</li><li> <span class="k">case</span> <span class="s">"C"</span>:
</li><li> <span class="k">self</span> = .<span class="nv">celsius</span>
</li><li> <span class="k">case</span> <span class="s">"F"</span>:
</li><li> <span class="k">self</span> = .<span class="nv">fahrenheit</span>
</li><li> <span class="k">default</span>:
</li><li> <span class="k">return</span> <span class="k">nil</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>You can use this failable initializer to choose an appropriate enumeration case for the three possible states and to cause initialization to fail if the parameter does not match one of these states:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">fahrenheitUnit</span> = <span class="nv">TemperatureUnit</span>(<span class="nv">symbol</span>: <span class="s">"F"</span>)
</li><li><span class="k">if</span> <span class="nv">fahrenheitUnit</span> != <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="s">"This is a defined temperature unit, so initialization succeeded."</span>)
</li><li>}
</li><li><span class="c">// Prints "This is a defined temperature unit, so initialization succeeded."</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">unknownUnit</span> = <span class="nv">TemperatureUnit</span>(<span class="nv">symbol</span>: <span class="s">"X"</span>)
</li><li><span class="k">if</span> <span class="nv">unknownUnit</span> == <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="s">"This is not a defined temperature unit, so initialization failed."</span>)
</li><li>}
</li><li><span class="c">// Prints "This is not a defined temperature unit, so initialization failed."</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID226">
<h3>Failable Initializers for Enumerations with Raw Values<a class="headerlink" href="Initialization.html#ID226" title="Permalink to this headline">¶</a></h3>
<p>Enumerations with raw values automatically receive a failable initializer, <code class="docutils literal notranslate"><span class="pre">init?(rawValue:)</span></code>, that takes a parameter called <code class="docutils literal notranslate"><span class="pre">rawValue</span></code> of the appropriate raw-value type and selects a matching enumeration case if one is found, or triggers an initialization failure if no matching value exists.</p>
<p>You can rewrite the <code class="docutils literal notranslate"><span class="pre">TemperatureUnit</span></code> example from above to use raw values of type <code class="docutils literal notranslate"><span class="pre">Character</span></code> and to take advantage of the <code class="docutils literal notranslate"><span class="pre">init?(rawValue:)</span></code> initializer:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">TemperatureUnit</span>: <span class="nc">Character</span> {
</li><li> <span class="k">case</span> <span class="nv">kelvin</span> = <span class="s">"K"</span>, <span class="nv">celsius</span> = <span class="s">"C"</span>, <span class="nv">fahrenheit</span> = <span class="s">"F"</span>
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">fahrenheitUnit</span> = <span class="nv">TemperatureUnit</span>(<span class="nv">rawValue</span>: <span class="s">"F"</span>)
</li><li><span class="k">if</span> <span class="nv">fahrenheitUnit</span> != <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="s">"This is a defined temperature unit, so initialization succeeded."</span>)
</li><li>}
</li><li><span class="c">// Prints "This is a defined temperature unit, so initialization succeeded."</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">unknownUnit</span> = <span class="nv">TemperatureUnit</span>(<span class="nv">rawValue</span>: <span class="s">"X"</span>)
</li><li><span class="k">if</span> <span class="nv">unknownUnit</span> == <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="s">"This is not a defined temperature unit, so initialization failed."</span>)
</li><li>}
</li><li><span class="c">// Prints "This is not a defined temperature unit, so initialization failed."</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID228">
<h3>Propagation of Initialization Failure<a class="headerlink" href="Initialization.html#ID228" title="Permalink to this headline">¶</a></h3>
<p>A failable initializer of a class, structure, or enumeration can delegate across to another failable initializer from the same class, structure, or enumeration. Similarly, a subclass failable initializer can delegate up to a superclass failable initializer.</p>
<p>In either case, if you delegate to another initializer that causes initialization to fail, the entire initialization process fails immediately, and no further initialization code is executed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A failable initializer can also delegate to a nonfailable initializer. Use this approach if you need to add a potential failure state to an existing initialization process that does not otherwise fail.</p>
</div>
<p>The example below defines a subclass of <code class="docutils literal notranslate"><span class="pre">Product</span></code> called <code class="docutils literal notranslate"><span class="pre">CartItem</span></code>. The <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> class models an item in an online shopping cart. <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> introduces a stored constant property called <code class="docutils literal notranslate"><span class="pre">quantity</span></code> and ensures that this property always has a value of at least <code class="docutils literal notranslate"><span class="pre">1</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Product</span> {
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>?(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li> <span class="k">if</span> <span class="nv">name</span>.<span class="nv">isEmpty</span> { <span class="k">return</span> <span class="k">nil</span> }
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">CartItem</span>: <span class="nc">Product</span> {
</li><li> <span class="k">let</span> <span class="nv">quantity</span>: <span class="nc">Int</span>
</li><li> <span class="k">init</span>?(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">quantity</span>: <span class="nc">Int</span>) {
</li><li> <span class="k">if</span> <span class="nv">quantity</span> &lt; <span class="m">1</span> { <span class="k">return</span> <span class="k">nil</span> }
</li><li> <span class="k">self</span>.<span class="nv">quantity</span> = <span class="nv">quantity</span>
</li><li> <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="nv">name</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The failable initializer for <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> starts by validating that it has received a <code class="docutils literal notranslate"><span class="pre">quantity</span></code> value of <code class="docutils literal notranslate"><span class="pre">1</span></code> or more. If the <code class="docutils literal notranslate"><span class="pre">quantity</span></code> is invalid, the entire initialization process fails immediately and no further initialization code is executed. Likewise, the failable initializer for <code class="docutils literal notranslate"><span class="pre">Product</span></code> checks the <code class="docutils literal notranslate"><span class="pre">name</span></code> value, and the initializer process fails immediately if <code class="docutils literal notranslate"><span class="pre">name</span></code> is the empty string.</p>
<p>If you create a <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> instance with a nonempty name and a quantity of <code class="docutils literal notranslate"><span class="pre">1</span></code> or more, initialization succeeds:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">twoSocks</span> = <span class="nv">CartItem</span>(<span class="nv">name</span>: <span class="s">"sock"</span>, <span class="nv">quantity</span>: <span class="m">2</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Item: </span>\<span class="p">(</span><span class="nv">twoSocks</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, quantity: </span>\<span class="p">(</span><span class="nv">twoSocks</span>.<span class="nv">quantity</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Prints "Item: sock, quantity: 2"</span>
</li></ol></div></div></div>
<p>If you try to create a <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> instance with a <code class="docutils literal notranslate"><span class="pre">quantity</span></code> value of <code class="docutils literal notranslate"><span class="pre">0</span></code>, the <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> initializer causes initialization to fail:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">zeroShirts</span> = <span class="nv">CartItem</span>(<span class="nv">name</span>: <span class="s">"shirt"</span>, <span class="nv">quantity</span>: <span class="m">0</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Item: </span>\<span class="p">(</span><span class="nv">zeroShirts</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, quantity: </span>\<span class="p">(</span><span class="nv">zeroShirts</span>.<span class="nv">quantity</span><span class="p">)</span><span class="s">"</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unable to initialize zero shirts"</span>)
</li><li>}
</li><li><span class="c">// Prints "Unable to initialize zero shirts"</span>
</li></ol></div></div></div>
<p>Similarly, if you try to create a <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> instance with an empty <code class="docutils literal notranslate"><span class="pre">name</span></code> value, the superclass <code class="docutils literal notranslate"><span class="pre">Product</span></code> initializer causes initialization to fail:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">oneUnnamed</span> = <span class="nv">CartItem</span>(<span class="nv">name</span>: <span class="s">""</span>, <span class="nv">quantity</span>: <span class="m">1</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Item: </span>\<span class="p">(</span><span class="nv">oneUnnamed</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, quantity: </span>\<span class="p">(</span><span class="nv">oneUnnamed</span>.<span class="nv">quantity</span><span class="p">)</span><span class="s">"</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unable to initialize one unnamed product"</span>)
</li><li>}
</li><li><span class="c">// Prints "Unable to initialize one unnamed product"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID229">
<h3>Overriding a Failable Initializer<a class="headerlink" href="Initialization.html#ID229" title="Permalink to this headline">¶</a></h3>
<p>You can override a superclass failable initializer in a subclass, just like any other initializer. Alternatively, you can override a superclass failable initializer with a subclass <em>nonfailable</em> initializer. This enables you to define a subclass for which initialization cannot fail, even though initialization of the superclass is allowed to fail.</p>
<p>Note that if you override a failable superclass initializer with a nonfailable subclass initializer, the only way to delegate up to the superclass initializer is to force-unwrap the result of the failable superclass initializer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can override a failable initializer with a nonfailable initializer but not the other way around.</p>
</div>
<p>The example below defines a class called <code class="docutils literal notranslate"><span class="pre">Document</span></code>. This class models a document that can be initialized with a <code class="docutils literal notranslate"><span class="pre">name</span></code> property that is either a nonempty string value or <code class="docutils literal notranslate"><span class="pre">nil</span></code>, but cannot be an empty string:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Document</span> {
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>?
</li><li> <span class="c">// this initializer creates a document with a nil name value</span>
</li><li> <span class="k">init</span>() {}
</li><li> <span class="c">// this initializer creates a document with a nonempty name value</span>
</li><li> <span class="k">init</span>?(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li> <span class="k">if</span> <span class="nv">name</span>.<span class="nv">isEmpty</span> { <span class="k">return</span> <span class="k">nil</span> }
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The next example defines a subclass of <code class="docutils literal notranslate"><span class="pre">Document</span></code> called <code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code>. The <code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code> subclass overrides both of the designated initializers introduced by <code class="docutils literal notranslate"><span class="pre">Document</span></code>. These overrides ensure that an <code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code> instance has an initial <code class="docutils literal notranslate"><span class="pre">name</span></code> value of <code class="docutils literal notranslate"><span class="pre">"[Untitled]"</span></code> if the instance is initialized without a name, or if an empty string is passed to the <code class="docutils literal notranslate"><span class="pre">init(name:)</span></code> initializer:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">AutomaticallyNamedDocument</span>: <span class="nc">Document</span> {
</li><li> <span class="k">override</span> <span class="k">init</span>() {
</li><li> <span class="k">super</span>.<span class="nv">init</span>()
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="s">"[Untitled]"</span>
</li><li>    }
</li><li> <span class="k">override</span> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li> <span class="k">super</span>.<span class="nv">init</span>()
</li><li> <span class="k">if</span> <span class="nv">name</span>.<span class="nv">isEmpty</span> {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="s">"[Untitled]"</span>
</li><li>        } <span class="k">else</span> {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code> overrides its superclass’s failable <code class="docutils literal notranslate"><span class="pre">init?(name:)</span></code> initializer with a nonfailable <code class="docutils literal notranslate"><span class="pre">init(name:)</span></code> initializer. Because <code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code> copes with the empty string case in a different way than its superclass, its initializer does not need to fail, and so it provides a nonfailable version of the initializer instead.</p>
<p>You can use forced unwrapping in an initializer to call a failable initializer from the superclass as part of the implementation of a subclass’s nonfailable initializer. For example, the <code class="docutils literal notranslate"><span class="pre">UntitledDocument</span></code> subclass below is always named <code class="docutils literal notranslate"><span class="pre">"[Untitled]"</span></code>, and it uses the failable <code class="docutils literal notranslate"><span class="pre">init(name:)</span></code> initializer from its superclass during initialization.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">UntitledDocument</span>: <span class="nc">Document</span> {
</li><li> <span class="k">override</span> <span class="k">init</span>() {
</li><li> <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="s">"[Untitled]"</span>)!
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>In this case, if the <code class="docutils literal notranslate"><span class="pre">init(name:)</span></code> initializer of the superclass were ever called with an empty string as the name, the forced unwrapping operation would result in a runtime error. However, because it’s called with a string constant, you can see that the initializer won’t fail, so no runtime error can occur in this case.</p>
</div>
<div class="section" id="ID230">
<h3>The init! Failable Initializer<a class="headerlink" href="Initialization.html#ID230" title="Permalink to this headline">¶</a></h3>
<p>You typically define a failable initializer that creates an optional instance of the appropriate type by placing a question mark after the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword (<code class="docutils literal notranslate"><span class="pre">init?</span></code>). Alternatively, you can define a failable initializer that creates an implicitly unwrapped optional instance of the appropriate type. Do this by placing an exclamation mark after the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword (<code class="docutils literal notranslate"><span class="pre">init!</span></code>) instead of a question mark.</p>
<p>You can delegate from <code class="docutils literal notranslate"><span class="pre">init?</span></code> to <code class="docutils literal notranslate"><span class="pre">init!</span></code> and vice versa, and you can override <code class="docutils literal notranslate"><span class="pre">init?</span></code> with <code class="docutils literal notranslate"><span class="pre">init!</span></code> and vice versa. You can also delegate from <code class="docutils literal notranslate"><span class="pre">init</span></code> to <code class="docutils literal notranslate"><span class="pre">init!</span></code>, although doing so will trigger an assertion if the <code class="docutils literal notranslate"><span class="pre">init!</span></code> initializer causes initialization to fail.</p>
</div>
</div>
<div class="section" id="ID231">
<h2>Required Initializers<a class="headerlink" href="Initialization.html#ID231" title="Permalink to this headline">¶</a></h2>
<p>Write the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li> <span class="k">required</span> <span class="k">init</span>() {
</li><li> <span class="c">// initializer implementation goes here</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>You must also write the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier before every subclass implementation of a required initializer, to indicate that the initializer requirement applies to further subclasses in the chain. You do not write the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier when overriding a required designated initializer:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeSubclass</span>: <span class="nc">SomeClass</span> {
</li><li> <span class="k">required</span> <span class="k">init</span>() {
</li><li> <span class="c">// subclass implementation of the required initializer goes here</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You do not have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer.</p>
</div>
</div>
<div class="section" id="ID232">
<h2>Setting a Default Property Value with a Closure or Function<a class="headerlink" href="Initialization.html#ID232" title="Permalink to this headline">¶</a></h2>
<p>If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property. Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value.</p>
<p>These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property’s default value.</p>
<p>Here’s a skeleton outline of how a closure can be used to provide a default property value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li> <span class="k">let</span> <span class="nv">someProperty</span>: <span class="nc">SomeType</span> = {
</li><li> <span class="c">// create a default value for someProperty inside this closure</span>
</li><li> <span class="c">// someValue must be of the same type as SomeType</span>
</li><li> <span class="k">return</span> <span class="nv">someValue</span>
</li><li>    }()
</li><li>}
</li></ol></div></div></div>
<p>Note that the closure’s end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately. If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you use a closure to initialize a property, remember that the rest of the instance has not yet been initialized at the point that the closure is executed. This means that you cannot access any other property values from within your closure, even if those properties have default values. You also cannot use the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> property, or call any of the instance’s methods.</p>
</div>
<p>The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">Chessboard</span></code>, which models a board for the game of chess. Chess is played on an 8 x 8 board, with alternating black and white squares.</p>
<img alt="../_images/chessBoard_2x.png" class="align-center" src="../_images/chessBoard_2x.png" style="width: 230px;"/>
<p>To represent this game board, the <code class="docutils literal notranslate"><span class="pre">Chessboard</span></code> structure has a single property called <code class="docutils literal notranslate"><span class="pre">boardColors</span></code>, which is an array of 64 <code class="docutils literal notranslate"><span class="pre">Bool</span></code> values. A value of <code class="docutils literal notranslate"><span class="pre">true</span></code> in the array represents a black square and a value of <code class="docutils literal notranslate"><span class="pre">false</span></code> represents a white square. The first item in the array represents the top left square on the board and the last item in the array represents the bottom right square on the board.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">boardColors</span></code> array is initialized with a closure to set up its color values:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Chessboard</span> {
</li><li> <span class="k">let</span> <span class="nv">boardColors</span>: [<span class="nc">Bool</span>] = {
</li><li> <span class="k">var</span> <span class="nv">temporaryBoard</span> = [<span class="nv">Bool</span>]()
</li><li> <span class="k">var</span> <span class="nv">isBlack</span> = <span class="k">false</span>
</li><li> <span class="k">for</span> <span class="nv">i</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">8</span> {
</li><li> <span class="k">for</span> <span class="nv">j</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">8</span> {
</li><li> <span class="nv">temporaryBoard</span>.<span class="nv">append</span>(<span class="nv">isBlack</span>)
</li><li> <span class="nv">isBlack</span> = !<span class="nv">isBlack</span>
</li><li>            }
</li><li> <span class="nv">isBlack</span> = !<span class="nv">isBlack</span>
</li><li>        }
</li><li> <span class="k">return</span> <span class="nv">temporaryBoard</span>
</li><li>    }()
</li><li> <span class="k">func</span> <span class="nv">squareIsBlackAt</span>(<span class="nv">row</span>: <span class="nc">Int</span>, <span class="nv">column</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">return</span> <span class="nv">boardColors</span>[(<span class="nv">row</span> * <span class="m">8</span>) + <span class="nv">column</span>]
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Whenever a new <code class="docutils literal notranslate"><span class="pre">Chessboard</span></code> instance is created, the closure is executed, and the default value of <code class="docutils literal notranslate"><span class="pre">boardColors</span></code> is calculated and returned. The closure in the example above calculates and sets the appropriate color for each square on the board in a temporary array called <code class="docutils literal notranslate"><span class="pre">temporaryBoard</span></code>, and returns this temporary array as the closure’s return value once its setup is complete. The returned array value is stored in <code class="docutils literal notranslate"><span class="pre">boardColors</span></code> and can be queried with the <code class="docutils literal notranslate"><span class="pre">squareIsBlackAt(row:column:)</span></code> utility function:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">board</span> = <span class="nv">Chessboard</span>()
</li><li><span class="nv">print</span>(<span class="nv">board</span>.<span class="nv">squareIsBlackAt</span>(<span class="nv">row</span>: <span class="m">0</span>, <span class="nv">column</span>: <span class="m">1</span>))
</li><li><span class="c">// Prints "true"</span>
</li><li><span class="nv">print</span>(<span class="nv">board</span>.<span class="nv">squareIsBlackAt</span>(<span class="nv">row</span>: <span class="m">7</span>, <span class="nv">column</span>: <span class="m">7</span>))
</li><li><span class="c">// Prints "false"</span>
</li></ol></div></div></div>
</div>
</div><div class="section" id="deinitialization">
<h1>Deinitialization<a class="headerlink" href="Deinitialization.html#deinitialization" title="Permalink to this headline">¶</a></h1>
<p>A <em>deinitializer</em> is called immediately before a class instance is deallocated. You write deinitializers with the <code class="docutils literal notranslate"><span class="pre">deinit</span></code> keyword, similar to how initializers are written with the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword. Deinitializers are only available on class types.</p>
<div class="section" id="ID143">
<h2>How Deinitialization Works<a class="headerlink" href="Deinitialization.html#ID143" title="Permalink to this headline">¶</a></h2>
<p>Swift automatically deallocates your instances when they are no longer needed, to free up resources. Swift handles the memory management of instances through <em>automatic reference counting</em> (<em>ARC</em>), as described in <a class="reference internal" href="AutomaticReferenceCounting.html"><span class="doc">Automatic Reference Counting</span></a>. Typically you don’t need to perform manual cleanup when your instances are deallocated. However, when you are working with your own resources, you might need to perform some additional cleanup yourself. For example, if you create a custom class to open a file and write some data to it, you might need to close the file before the class instance is deallocated.</p>
<p>Class definitions can have at most one deinitializer per class. The deinitializer does not take any parameters and is written without parentheses:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">deinit</span> {
</li><li> <span class="c">// perform the deinitialization</span>
</li><li>}
</li></ol></div></div></div>
<p>Deinitializers are called automatically, just before instance deallocation takes place. You are not allowed to call a deinitializer yourself. Superclass deinitializers are inherited by their subclasses, and the superclass deinitializer is called automatically at the end of a subclass deinitializer implementation. Superclass deinitializers are always called, even if a subclass does not provide its own deinitializer.</p>
<p>Because an instance is not deallocated until after its deinitializer is called, a deinitializer can access all properties of the instance it is called on and can modify its behavior based on those properties (such as looking up the name of a file that needs to be closed).</p>
</div>
<div class="section" id="ID144">
<h2>Deinitializers in Action<a class="headerlink" href="Deinitialization.html#ID144" title="Permalink to this headline">¶</a></h2>
<p>Here’s an example of a deinitializer in action. This example defines two new types, <code class="docutils literal notranslate"><span class="pre">Bank</span></code> and <code class="docutils literal notranslate"><span class="pre">Player</span></code>, for a simple game. The <code class="docutils literal notranslate"><span class="pre">Bank</span></code> class manages a made-up currency, which can never have more than 10,000 coins in circulation. There can only ever be one <code class="docutils literal notranslate"><span class="pre">Bank</span></code> in the game, and so the <code class="docutils literal notranslate"><span class="pre">Bank</span></code> is implemented as a class with type properties and methods to store and manage its current state:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Bank</span> {
</li><li> <span class="k">static</span> <span class="k">var</span> <span class="nv">coinsInBank</span> = <span class="m">10_000</span>
</li><li> <span class="k">static</span> <span class="k">func</span> <span class="nv">distribute</span>(<span class="nv">coins</span> <span class="nv">numberOfCoinsRequested</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">let</span> <span class="nv">numberOfCoinsToVend</span> = <span class="nv">min</span>(<span class="nv">numberOfCoinsRequested</span>, <span class="nv">coinsInBank</span>)
</li><li> <span class="nv">coinsInBank</span> -= <span class="nv">numberOfCoinsToVend</span>
</li><li> <span class="k">return</span> <span class="nv">numberOfCoinsToVend</span>
</li><li>    }
</li><li> <span class="k">static</span> <span class="k">func</span> <span class="nv">receive</span>(<span class="nv">coins</span>: <span class="nc">Int</span>) {
</li><li> <span class="nv">coinsInBank</span> += <span class="nv">coins</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">Bank</span></code> keeps track of the current number of coins it holds with its <code class="docutils literal notranslate"><span class="pre">coinsInBank</span></code> property. It also offers two methods—<code class="docutils literal notranslate"><span class="pre">distribute(coins:)</span></code> and <code class="docutils literal notranslate"><span class="pre">receive(coins:)</span></code>—to handle the distribution and collection of coins.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">distribute(coins:)</span></code> method checks that there are enough coins in the bank before distributing them. If there are not enough coins, <code class="docutils literal notranslate"><span class="pre">Bank</span></code> returns a smaller number than the number that was requested (and returns zero if no coins are left in the bank). It returns an integer value to indicate the actual number of coins that were provided.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">receive(coins:)</span></code> method simply adds the received number of coins back into the bank’s coin store.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Player</span></code> class describes a player in the game. Each player has a certain number of coins stored in their purse at any time. This is represented by the player’s <code class="docutils literal notranslate"><span class="pre">coinsInPurse</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Player</span> {
</li><li> <span class="k">var</span> <span class="nv">coinsInPurse</span>: <span class="nc">Int</span>
</li><li> <span class="k">init</span>(<span class="nv">coins</span>: <span class="nc">Int</span>) {
</li><li> <span class="nv">coinsInPurse</span> = <span class="nv">Bank</span>.<span class="nv">distribute</span>(<span class="nv">coins</span>: <span class="nv">coins</span>)
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">win</span>(<span class="nv">coins</span>: <span class="nc">Int</span>) {
</li><li> <span class="nv">coinsInPurse</span> += <span class="nv">Bank</span>.<span class="nv">distribute</span>(<span class="nv">coins</span>: <span class="nv">coins</span>)
</li><li>    }
</li><li> <span class="k">deinit</span> {
</li><li> <span class="nv">Bank</span>.<span class="nv">receive</span>(<span class="nv">coins</span>: <span class="nv">coinsInPurse</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Each <code class="docutils literal notranslate"><span class="pre">Player</span></code> instance is initialized with a starting allowance of a specified number of coins from the bank during initialization, although a <code class="docutils literal notranslate"><span class="pre">Player</span></code> instance may receive fewer than that number if not enough coins are available.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Player</span></code> class defines a <code class="docutils literal notranslate"><span class="pre">win(coins:)</span></code> method, which retrieves a certain number of coins from the bank and adds them to the player’s purse. The <code class="docutils literal notranslate"><span class="pre">Player</span></code> class also implements a deinitializer, which is called just before a <code class="docutils literal notranslate"><span class="pre">Player</span></code> instance is deallocated. Here, the deinitializer simply returns all of the player’s coins to the bank:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">playerOne</span>: <span class="nc">Player</span>? = <span class="nv">Player</span>(<span class="nv">coins</span>: <span class="m">100</span>)
</li><li><span class="nv">print</span>(<span class="s">"A new player has joined the game with </span>\<span class="p">(</span><span class="nv">playerOne</span>!.<span class="nv">coinsInPurse</span><span class="p">)</span><span class="s"> coins"</span>)
</li><li><span class="c">// Prints "A new player has joined the game with 100 coins"</span>
</li><li><span class="nv">print</span>(<span class="s">"There are now </span>\<span class="p">(</span><span class="nv">Bank</span>.<span class="nv">coinsInBank</span><span class="p">)</span><span class="s"> coins left in the bank"</span>)
</li><li><span class="c">// Prints "There are now 9900 coins left in the bank"</span>
</li></ol></div></div></div>
<p>A new <code class="docutils literal notranslate"><span class="pre">Player</span></code> instance is created, with a request for 100 coins if they are available. This <code class="docutils literal notranslate"><span class="pre">Player</span></code> instance is stored in an optional <code class="docutils literal notranslate"><span class="pre">Player</span></code> variable called <code class="docutils literal notranslate"><span class="pre">playerOne</span></code>. An optional variable is used here, because players can leave the game at any point. The optional lets you track whether there is currently a player in the game.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">playerOne</span></code> is an optional, it is qualified with an exclamation mark (<code class="docutils literal notranslate"><span class="pre">!</span></code>) when its <code class="docutils literal notranslate"><span class="pre">coinsInPurse</span></code> property is accessed to print its default number of coins, and whenever its <code class="docutils literal notranslate"><span class="pre">win(coins:)</span></code> method is called:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">playerOne</span>!.<span class="nv">win</span>(<span class="nv">coins</span>: <span class="m">2_000</span>)
</li><li><span class="nv">print</span>(<span class="s">"PlayerOne won 2000 coins &amp; now has </span>\<span class="p">(</span><span class="nv">playerOne</span>!.<span class="nv">coinsInPurse</span><span class="p">)</span><span class="s"> coins"</span>)
</li><li><span class="c">// Prints "PlayerOne won 2000 coins &amp; now has 2100 coins"</span>
</li><li><span class="nv">print</span>(<span class="s">"The bank now only has </span>\<span class="p">(</span><span class="nv">Bank</span>.<span class="nv">coinsInBank</span><span class="p">)</span><span class="s"> coins left"</span>)
</li><li><span class="c">// Prints "The bank now only has 7900 coins left"</span>
</li></ol></div></div></div>
<p>Here, the player has won 2,000 coins. The player’s purse now contains 2,100 coins, and the bank has only 7,900 coins left.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">playerOne</span> = <span class="k">nil</span>
</li><li><span class="nv">print</span>(<span class="s">"PlayerOne has left the game"</span>)
</li><li><span class="c">// Prints "PlayerOne has left the game"</span>
</li><li><span class="nv">print</span>(<span class="s">"The bank now has </span>\<span class="p">(</span><span class="nv">Bank</span>.<span class="nv">coinsInBank</span><span class="p">)</span><span class="s"> coins"</span>)
</li><li><span class="c">// Prints "The bank now has 10000 coins"</span>
</li></ol></div></div></div>
<p>The player has now left the game. This is indicated by setting the optional <code class="docutils literal notranslate"><span class="pre">playerOne</span></code> variable to <code class="docutils literal notranslate"><span class="pre">nil</span></code>, meaning “no <code class="docutils literal notranslate"><span class="pre">Player</span></code> instance.” At the point that this happens, the <code class="docutils literal notranslate"><span class="pre">playerOne</span></code> variable’s reference to the <code class="docutils literal notranslate"><span class="pre">Player</span></code> instance is broken. No other properties or variables are still referring to the <code class="docutils literal notranslate"><span class="pre">Player</span></code> instance, and so it is deallocated in order to free up its memory. Just before this happens, its deinitializer is called automatically, and its coins are returned to the bank.</p>
</div>
</div><div class="section" id="optional-chaining">
<h1>Optional Chaining<a class="headerlink" href="OptionalChaining.html#optional-chaining" title="Permalink to this headline">¶</a></h1>
<p><em>Optional chaining</em> is a process for querying and calling properties, methods, and subscripts on an optional that might currently be <code class="docutils literal notranslate"><span class="pre">nil</span></code>. If the optional contains a value, the property, method, or subscript call succeeds; if the optional is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the property, method, or subscript call returns <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Optional chaining in Swift is similar to messaging <code class="docutils literal notranslate"><span class="pre">nil</span></code> in Objective-C, but in a way that works for any type, and that can be checked for success or failure.</p>
</div>
<div class="section" id="ID246">
<h2>Optional Chaining as an Alternative to Forced Unwrapping<a class="headerlink" href="OptionalChaining.html#ID246" title="Permalink to this headline">¶</a></h2>
<p>You specify optional chaining by placing a question mark (<code class="docutils literal notranslate"><span class="pre">?</span></code>) after the optional value on which you wish to call a property, method or subscript if the optional is non-<code class="docutils literal notranslate"><span class="pre">nil</span></code>. This is very similar to placing an exclamation mark (<code class="docutils literal notranslate"><span class="pre">!</span></code>) after an optional value to force the unwrapping of its value. The main difference is that optional chaining fails gracefully when the optional is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, whereas forced unwrapping triggers a runtime error when the optional is <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>To reflect the fact that optional chaining can be called on a <code class="docutils literal notranslate"><span class="pre">nil</span></code> value, the result of an optional chaining call is always an optional value, even if the property, method, or subscript you are querying returns a nonoptional value. You can use this optional return value to check whether the optional chaining call was successful (the returned optional contains a value), or did not succeed due to a <code class="docutils literal notranslate"><span class="pre">nil</span></code> value in the chain (the returned optional value is <code class="docutils literal notranslate"><span class="pre">nil</span></code>).</p>
<p>Specifically, the result of an optional chaining call is of the same type as the expected return value, but wrapped in an optional. A property that normally returns an <code class="docutils literal notranslate"><span class="pre">Int</span></code> will return an <code class="docutils literal notranslate"><span class="pre">Int?</span></code> when accessed through optional chaining.</p>
<p>The next several code snippets demonstrate how optional chaining differs from forced unwrapping and enables you to check for success.</p>
<p>First, two classes called <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Residence</span></code> are defined:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Person</span> {
</li><li> <span class="k">var</span> <span class="nv">residence</span>: <span class="nc">Residence</span>?
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">Residence</span> {
</li><li> <span class="k">var</span> <span class="nv">numberOfRooms</span> = <span class="m">1</span>
</li><li>}
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">Residence</span></code> instances have a single <code class="docutils literal notranslate"><span class="pre">Int</span></code> property called <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">1</span></code>. <code class="docutils literal notranslate"><span class="pre">Person</span></code> instances have an optional <code class="docutils literal notranslate"><span class="pre">residence</span></code> property of type <code class="docutils literal notranslate"><span class="pre">Residence?</span></code>.</p>
<p>If you create a new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance, its <code class="docutils literal notranslate"><span class="pre">residence</span></code> property is default initialized to <code class="docutils literal notranslate"><span class="pre">nil</span></code>, by virtue of being optional. In the code below, <code class="docutils literal notranslate"><span class="pre">john</span></code> has a <code class="docutils literal notranslate"><span class="pre">residence</span></code> property value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">john</span> = <span class="nv">Person</span>()
</li></ol></div></div></div>
<p>If you try to access the <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code> property of this person’s <code class="docutils literal notranslate"><span class="pre">residence</span></code>, by placing an exclamation mark after <code class="docutils literal notranslate"><span class="pre">residence</span></code> to force the unwrapping of its value, you trigger a runtime error, because there is no <code class="docutils literal notranslate"><span class="pre">residence</span></code> value to unwrap:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">roomCount</span> = <span class="nv">john</span>.<span class="nv">residence</span>!.<span class="nv">numberOfRooms</span>
</li><li><span class="c">// this triggers a runtime error</span>
</li></ol></div></div></div>
<p>The code above succeeds when <code class="docutils literal notranslate"><span class="pre">john.residence</span></code> has a non-<code class="docutils literal notranslate"><span class="pre">nil</span></code> value and will set <code class="docutils literal notranslate"><span class="pre">roomCount</span></code> to an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value containing the appropriate number of rooms. However, this code always triggers a runtime error when <code class="docutils literal notranslate"><span class="pre">residence</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, as illustrated above.</p>
<p>Optional chaining provides an alternative way to access the value of <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code>. To use optional chaining, use a question mark in place of the exclamation mark:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">roomCount</span> = <span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">numberOfRooms</span> {
</li><li> <span class="nv">print</span>(<span class="s">"John's residence has </span>\<span class="p">(</span><span class="nv">roomCount</span><span class="p">)</span><span class="s"> room(s)."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unable to retrieve the number of rooms."</span>)
</li><li>}
</li><li><span class="c">// Prints "Unable to retrieve the number of rooms."</span>
</li></ol></div></div></div>
<p>This tells Swift to “chain” on the optional <code class="docutils literal notranslate"><span class="pre">residence</span></code> property and to retrieve the value of <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code> if <code class="docutils literal notranslate"><span class="pre">residence</span></code> exists.</p>
<p>Because the attempt to access <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code> has the potential to fail, the optional chaining attempt returns a value of type <code class="docutils literal notranslate"><span class="pre">Int?</span></code>, or “optional <code class="docutils literal notranslate"><span class="pre">Int</span></code>”. When <code class="docutils literal notranslate"><span class="pre">residence</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, as in the example above, this optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> will also be <code class="docutils literal notranslate"><span class="pre">nil</span></code>, to reflect the fact that it was not possible to access <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code>. The optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> is accessed through optional binding to unwrap the integer and assign the nonoptional value to the <code class="docutils literal notranslate"><span class="pre">roomCount</span></code> variable.</p>
<p>Note that this is true even though <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code> is a nonoptional <code class="docutils literal notranslate"><span class="pre">Int</span></code>. The fact that it is queried through an optional chain means that the call to <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code> will always return an <code class="docutils literal notranslate"><span class="pre">Int?</span></code> instead of an <code class="docutils literal notranslate"><span class="pre">Int</span></code>.</p>
<p>You can assign a <code class="docutils literal notranslate"><span class="pre">Residence</span></code> instance to <code class="docutils literal notranslate"><span class="pre">john.residence</span></code>, so that it no longer has a <code class="docutils literal notranslate"><span class="pre">nil</span></code> value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span>.<span class="nv">residence</span> = <span class="nv">Residence</span>()
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">john.residence</span></code> now contains an actual <code class="docutils literal notranslate"><span class="pre">Residence</span></code> instance, rather than <code class="docutils literal notranslate"><span class="pre">nil</span></code>. If you try to access <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code> with the same optional chaining as before, it will now return an <code class="docutils literal notranslate"><span class="pre">Int?</span></code> that contains the default <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code> value of <code class="docutils literal notranslate"><span class="pre">1</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">roomCount</span> = <span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">numberOfRooms</span> {
</li><li> <span class="nv">print</span>(<span class="s">"John's residence has </span>\<span class="p">(</span><span class="nv">roomCount</span><span class="p">)</span><span class="s"> room(s)."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unable to retrieve the number of rooms."</span>)
</li><li>}
</li><li><span class="c">// Prints "John's residence has 1 room(s)."</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID247">
<h2>Defining Model Classes for Optional Chaining<a class="headerlink" href="OptionalChaining.html#ID247" title="Permalink to this headline">¶</a></h2>
<p>You can use optional chaining with calls to properties, methods, and subscripts that are more than one level deep. This enables you to drill down into subproperties within complex models of interrelated types, and to check whether it is possible to access properties, methods, and subscripts on those subproperties.</p>
<p>The code snippets below define four model classes for use in several subsequent examples, including examples of multilevel optional chaining. These classes expand upon the <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Residence</span></code> model from above by adding a <code class="docutils literal notranslate"><span class="pre">Room</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code> class, with associated properties, methods, and subscripts.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Person</span></code> class is defined in the same way as before:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Person</span> {
</li><li> <span class="k">var</span> <span class="nv">residence</span>: <span class="nc">Residence</span>?
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Residence</span></code> class is more complex than before. This time, the <code class="docutils literal notranslate"><span class="pre">Residence</span></code> class defines a variable property called <code class="docutils literal notranslate"><span class="pre">rooms</span></code>, which is initialized with an empty array of type <code class="docutils literal notranslate"><span class="pre">[Room]</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Residence</span> {
</li><li> <span class="k">var</span> <span class="nv">rooms</span> = [<span class="nv">Room</span>]()
</li><li> <span class="k">var</span> <span class="nv">numberOfRooms</span>: <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">rooms</span>.<span class="nv">count</span>
</li><li>    }
</li><li> <span class="k">subscript</span>(<span class="nv">i</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Room</span> {
</li><li> <span class="k">get</span> {
</li><li> <span class="k">return</span> <span class="nv">rooms</span>[<span class="nv">i</span>]
</li><li>        }
</li><li> <span class="k">set</span> {
</li><li> <span class="nv">rooms</span>[<span class="nv">i</span>] = <span class="nv">newValue</span>
</li><li>        }
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">printNumberOfRooms</span>() {
</li><li> <span class="nv">print</span>(<span class="s">"The number of rooms is </span>\<span class="p">(</span><span class="nv">numberOfRooms</span><span class="p">)</span><span class="s">"</span>)
</li><li>    }
</li><li> <span class="k">var</span> <span class="nv">address</span>: <span class="nc">Address</span>?
</li><li>}
</li></ol></div></div></div>
<p>Because this version of <code class="docutils literal notranslate"><span class="pre">Residence</span></code> stores an array of <code class="docutils literal notranslate"><span class="pre">Room</span></code> instances, its <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code> property is implemented as a computed property, not a stored property. The computed <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code> property simply returns the value of the <code class="docutils literal notranslate"><span class="pre">count</span></code> property from the <code class="docutils literal notranslate"><span class="pre">rooms</span></code> array.</p>
<p>As a shortcut to accessing its <code class="docutils literal notranslate"><span class="pre">rooms</span></code> array, this version of <code class="docutils literal notranslate"><span class="pre">Residence</span></code> provides a read-write subscript that provides access to the room at the requested index in the <code class="docutils literal notranslate"><span class="pre">rooms</span></code> array.</p>
<p>This version of <code class="docutils literal notranslate"><span class="pre">Residence</span></code> also provides a method called <code class="docutils literal notranslate"><span class="pre">printNumberOfRooms</span></code>, which simply prints the number of rooms in the residence.</p>
<p>Finally, <code class="docutils literal notranslate"><span class="pre">Residence</span></code> defines an optional property called <code class="docutils literal notranslate"><span class="pre">address</span></code>, with a type of <code class="docutils literal notranslate"><span class="pre">Address?</span></code>. The <code class="docutils literal notranslate"><span class="pre">Address</span></code> class type for this property is defined below.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Room</span></code> class used for the <code class="docutils literal notranslate"><span class="pre">rooms</span></code> array is a simple class with one property called <code class="docutils literal notranslate"><span class="pre">name</span></code>, and an initializer to set that property to a suitable room name:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Room</span> {
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span> }
</li><li>}
</li></ol></div></div></div>
<p>The final class in this model is called <code class="docutils literal notranslate"><span class="pre">Address</span></code>. This class has three optional properties of type <code class="docutils literal notranslate"><span class="pre">String?</span></code>. The first two properties, <code class="docutils literal notranslate"><span class="pre">buildingName</span></code> and <code class="docutils literal notranslate"><span class="pre">buildingNumber</span></code>, are alternative ways to identify a particular building as part of an address. The third property, <code class="docutils literal notranslate"><span class="pre">street</span></code>, is used to name the street for that address:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Address</span> {
</li><li> <span class="k">var</span> <span class="nv">buildingName</span>: <span class="nc">String</span>?
</li><li> <span class="k">var</span> <span class="nv">buildingNumber</span>: <span class="nc">String</span>?
</li><li> <span class="k">var</span> <span class="nv">street</span>: <span class="nc">String</span>?
</li><li> <span class="k">func</span> <span class="nv">buildingIdentifier</span>() -&gt; <span class="nc">String</span>? {
</li><li> <span class="k">if</span> <span class="k">let</span> <span class="nv">buildingNumber</span> = <span class="nv">buildingNumber</span>, <span class="k">let</span> <span class="nv">street</span> = <span class="nv">street</span> {
</li><li> <span class="k">return</span> <span class="s">"</span>\<span class="p">(</span><span class="nv">buildingNumber</span><span class="p">)</span><span class="s"> </span>\<span class="p">(</span><span class="nv">street</span><span class="p">)</span><span class="s">"</span>
</li><li>        } <span class="k">else</span> <span class="k">if</span> <span class="nv">buildingName</span> != <span class="k">nil</span> {
</li><li> <span class="k">return</span> <span class="nv">buildingName</span>
</li><li>        } <span class="k">else</span> {
</li><li> <span class="k">return</span> <span class="k">nil</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Address</span></code> class also provides a method called <code class="docutils literal notranslate"><span class="pre">buildingIdentifier()</span></code>, which has a return type of <code class="docutils literal notranslate"><span class="pre">String?</span></code>. This method checks the properties of the address and returns <code class="docutils literal notranslate"><span class="pre">buildingName</span></code> if it has a value, or <code class="docutils literal notranslate"><span class="pre">buildingNumber</span></code> concatenated with <code class="docutils literal notranslate"><span class="pre">street</span></code> if both have values, or <code class="docutils literal notranslate"><span class="pre">nil</span></code> otherwise.</p>
</div>
<div class="section" id="ID248">
<h2>Accessing Properties Through Optional Chaining<a class="headerlink" href="OptionalChaining.html#ID248" title="Permalink to this headline">¶</a></h2>
<p>As demonstrated in <a class="reference internal" href="OptionalChaining.html#ID246"><span class="std std-ref">Optional Chaining as an Alternative to Forced Unwrapping</span></a>, you can use optional chaining to access a property on an optional value, and to check if that property access is successful.</p>
<p>Use the classes defined above to create a new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance, and try to access its <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code> property as before:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">john</span> = <span class="nv">Person</span>()
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">roomCount</span> = <span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">numberOfRooms</span> {
</li><li> <span class="nv">print</span>(<span class="s">"John's residence has </span>\<span class="p">(</span><span class="nv">roomCount</span><span class="p">)</span><span class="s"> room(s)."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unable to retrieve the number of rooms."</span>)
</li><li>}
</li><li><span class="c">// Prints "Unable to retrieve the number of rooms."</span>
</li></ol></div></div></div>
<p>Because <code class="docutils literal notranslate"><span class="pre">john.residence</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, this optional chaining call fails in the same way as before.</p>
<p>You can also attempt to set a property’s value through optional chaining:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someAddress</span> = <span class="nv">Address</span>()
</li><li><span class="nv">someAddress</span>.<span class="nv">buildingNumber</span> = <span class="s">"29"</span>
</li><li><span class="nv">someAddress</span>.<span class="nv">street</span> = <span class="s">"Acacia Road"</span>
</li><li><span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">address</span> = <span class="nv">someAddress</span>
</li></ol></div></div></div>
<p>In this example, the attempt to set the <code class="docutils literal notranslate"><span class="pre">address</span></code> property of <code class="docutils literal notranslate"><span class="pre">john.residence</span></code> will fail, because <code class="docutils literal notranslate"><span class="pre">john.residence</span></code> is currently <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>The assignment is part of the optional chaining, which means none of the code on the right-hand side of the <code class="docutils literal notranslate"><span class="pre">=</span></code> operator is evaluated. In the previous example, it’s not easy to see that <code class="docutils literal notranslate"><span class="pre">someAddress</span></code> is never evaluated, because accessing a constant doesn’t have any side effects. The listing below does the same assignment, but it uses a function to create the address. The function prints “Function was called” before returning a value, which lets you see whether the right-hand side of the <code class="docutils literal notranslate"><span class="pre">=</span></code> operator was evaluated.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">createAddress</span>() -&gt; <span class="nc">Address</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Function was called."</span>)
</li><li>
</li><li> <span class="k">let</span> <span class="nv">someAddress</span> = <span class="nv">Address</span>()
</li><li> <span class="nv">someAddress</span>.<span class="nv">buildingNumber</span> = <span class="s">"29"</span>
</li><li> <span class="nv">someAddress</span>.<span class="nv">street</span> = <span class="s">"Acacia Road"</span>
</li><li>
</li><li> <span class="k">return</span> <span class="nv">someAddress</span>
</li><li>}
</li><li><span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">address</span> = <span class="nv">createAddress</span>()
</li></ol></div></div></div>
<p>You can tell that the <code class="docutils literal notranslate"><span class="pre">createAddress()</span></code> function isn’t called, because nothing is printed.</p>
</div>
<div class="section" id="ID249">
<h2>Calling Methods Through Optional Chaining<a class="headerlink" href="OptionalChaining.html#ID249" title="Permalink to this headline">¶</a></h2>
<p>You can use optional chaining to call a method on an optional value, and to check whether that method call is successful. You can do this even if that method does not define a return value.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">printNumberOfRooms()</span></code> method on the <code class="docutils literal notranslate"><span class="pre">Residence</span></code> class prints the current value of <code class="docutils literal notranslate"><span class="pre">numberOfRooms</span></code>. Here’s how the method looks:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">printNumberOfRooms</span>() {
</li><li> <span class="nv">print</span>(<span class="s">"The number of rooms is </span>\<span class="p">(</span><span class="nv">numberOfRooms</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li></ol></div></div></div>
<p>This method does not specify a return type. However, functions and methods with no return type have an implicit return type of <code class="docutils literal notranslate"><span class="pre">Void</span></code>, as described in <a class="reference internal" href="Functions.html#ID163"><span class="std std-ref">Functions Without Return Values</span></a>. This means that they return a value of <code class="docutils literal notranslate"><span class="pre">()</span></code>, or an empty tuple.</p>
<p>If you call this method on an optional value with optional chaining, the method’s return type will be <code class="docutils literal notranslate"><span class="pre">Void?</span></code>, not <code class="docutils literal notranslate"><span class="pre">Void</span></code>, because return values are always of an optional type when called through optional chaining. This enables you to use an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement to check whether it was possible to call the <code class="docutils literal notranslate"><span class="pre">printNumberOfRooms()</span></code> method, even though the method does not itself define a return value. Compare the return value from the <code class="docutils literal notranslate"><span class="pre">printNumberOfRooms</span></code> call against <code class="docutils literal notranslate"><span class="pre">nil</span></code> to see if the method call was successful:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">printNumberOfRooms</span>() != <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It was possible to print the number of rooms."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It was not possible to print the number of rooms."</span>)
</li><li>}
</li><li><span class="c">// Prints "It was not possible to print the number of rooms."</span>
</li></ol></div></div></div>
<p>The same is true if you attempt to set a property through optional chaining. The example above in <a class="reference internal" href="OptionalChaining.html#ID248"><span class="std std-ref">Accessing Properties Through Optional Chaining</span></a> attempts to set an <code class="docutils literal notranslate"><span class="pre">address</span></code> value for <code class="docutils literal notranslate"><span class="pre">john.residence</span></code>, even though the <code class="docutils literal notranslate"><span class="pre">residence</span></code> property is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Any attempt to set a property through optional chaining returns a value of type <code class="docutils literal notranslate"><span class="pre">Void?</span></code>, which enables you to compare against <code class="docutils literal notranslate"><span class="pre">nil</span></code> to see if the property was set successfully:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> (<span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">address</span> = <span class="nv">someAddress</span>) != <span class="k">nil</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It was possible to set the address."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"It was not possible to set the address."</span>)
</li><li>}
</li><li><span class="c">// Prints "It was not possible to set the address."</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID250">
<h2>Accessing Subscripts Through Optional Chaining<a class="headerlink" href="OptionalChaining.html#ID250" title="Permalink to this headline">¶</a></h2>
<p>You can use optional chaining to try to retrieve and set a value from a subscript on an optional value, and to check whether that subscript call is successful.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When you access a subscript on an optional value through optional chaining, you place the question mark <em>before</em> the subscript’s brackets, not after. The optional chaining question mark always follows immediately after the part of the expression that is optional.</p>
</div>
<p>The example below tries to retrieve the name of the first room in the <code class="docutils literal notranslate"><span class="pre">rooms</span></code> array of the <code class="docutils literal notranslate"><span class="pre">john.residence</span></code> property using the subscript defined on the <code class="docutils literal notranslate"><span class="pre">Residence</span></code> class. Because <code class="docutils literal notranslate"><span class="pre">john.residence</span></code> is currently <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the subscript call fails:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">firstRoomName</span> = <span class="nv">john</span>.<span class="nv">residence</span>?[<span class="m">0</span>].<span class="nv">name</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The first room name is </span>\<span class="p">(</span><span class="nv">firstRoomName</span><span class="p">)</span><span class="s">."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unable to retrieve the first room name."</span>)
</li><li>}
</li><li><span class="c">// Prints "Unable to retrieve the first room name."</span>
</li></ol></div></div></div>
<p>The optional chaining question mark in this subscript call is placed immediately after <code class="docutils literal notranslate"><span class="pre">john.residence</span></code>, before the subscript brackets, because <code class="docutils literal notranslate"><span class="pre">john.residence</span></code> is the optional value on which optional chaining is being attempted.</p>
<p>Similarly, you can try to set a new value through a subscript with optional chaining:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span>.<span class="nv">residence</span>?[<span class="m">0</span>] = <span class="nv">Room</span>(<span class="nv">name</span>: <span class="s">"Bathroom"</span>)
</li></ol></div></div></div>
<p>This subscript setting attempt also fails, because <code class="docutils literal notranslate"><span class="pre">residence</span></code> is currently <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>If you create and assign an actual <code class="docutils literal notranslate"><span class="pre">Residence</span></code> instance to <code class="docutils literal notranslate"><span class="pre">john.residence</span></code>, with one or more <code class="docutils literal notranslate"><span class="pre">Room</span></code> instances in its <code class="docutils literal notranslate"><span class="pre">rooms</span></code> array, you can use the <code class="docutils literal notranslate"><span class="pre">Residence</span></code> subscript to access the actual items in the <code class="docutils literal notranslate"><span class="pre">rooms</span></code> array through optional chaining:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">johnsHouse</span> = <span class="nv">Residence</span>()
</li><li><span class="nv">johnsHouse</span>.<span class="nv">rooms</span>.<span class="nv">append</span>(<span class="nv">Room</span>(<span class="nv">name</span>: <span class="s">"Living Room"</span>))
</li><li><span class="nv">johnsHouse</span>.<span class="nv">rooms</span>.<span class="nv">append</span>(<span class="nv">Room</span>(<span class="nv">name</span>: <span class="s">"Kitchen"</span>))
</li><li><span class="nv">john</span>.<span class="nv">residence</span> = <span class="nv">johnsHouse</span>
</li><li>
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">firstRoomName</span> = <span class="nv">john</span>.<span class="nv">residence</span>?[<span class="m">0</span>].<span class="nv">name</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The first room name is </span>\<span class="p">(</span><span class="nv">firstRoomName</span><span class="p">)</span><span class="s">."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unable to retrieve the first room name."</span>)
</li><li>}
</li><li><span class="c">// Prints "The first room name is Living Room."</span>
</li></ol></div></div></div>
<div class="section" id="ID251">
<h3>Accessing Subscripts of Optional Type<a class="headerlink" href="OptionalChaining.html#ID251" title="Permalink to this headline">¶</a></h3>
<p>If a subscript returns a value of optional type—such as the key subscript of Swift’s <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> type—place a question mark <em>after</em> the subscript’s closing bracket to chain on its optional return value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">testScores</span> = [<span class="s">"Dave"</span>: [<span class="m">86</span>, <span class="m">82</span>, <span class="m">84</span>], <span class="s">"Bev"</span>: [<span class="m">79</span>, <span class="m">94</span>, <span class="m">81</span>]]
</li><li><span class="nv">testScores</span>[<span class="s">"Dave"</span>]?[<span class="m">0</span>] = <span class="m">91</span>
</li><li><span class="nv">testScores</span>[<span class="s">"Bev"</span>]?[<span class="m">0</span>] += <span class="m">1</span>
</li><li><span class="nv">testScores</span>[<span class="s">"Brian"</span>]?[<span class="m">0</span>] = <span class="m">72</span>
</li><li><span class="c">// the "Dave" array is now [91, 82, 84] and the "Bev" array is now [80, 94, 81]</span>
</li></ol></div></div></div>
<p>The example above defines a dictionary called <code class="docutils literal notranslate"><span class="pre">testScores</span></code>, which contains two key-value pairs that map a <code class="docutils literal notranslate"><span class="pre">String</span></code> key to an array of <code class="docutils literal notranslate"><span class="pre">Int</span></code> values. The example uses optional chaining to set the first item in the <code class="docutils literal notranslate"><span class="pre">"Dave"</span></code> array to <code class="docutils literal notranslate"><span class="pre">91</span></code>; to increment the first item in the <code class="docutils literal notranslate"><span class="pre">"Bev"</span></code> array by <code class="docutils literal notranslate"><span class="pre">1</span></code>; and to try to set the first item in an array for a key of <code class="docutils literal notranslate"><span class="pre">"Brian"</span></code>. The first two calls succeed, because the <code class="docutils literal notranslate"><span class="pre">testScores</span></code> dictionary contains keys for <code class="docutils literal notranslate"><span class="pre">"Dave"</span></code> and <code class="docutils literal notranslate"><span class="pre">"Bev"</span></code>. The third call fails, because the <code class="docutils literal notranslate"><span class="pre">testScores</span></code> dictionary does not contain a key for <code class="docutils literal notranslate"><span class="pre">"Brian"</span></code>.</p>
</div>
</div>
<div class="section" id="ID252">
<h2>Linking Multiple Levels of Chaining<a class="headerlink" href="OptionalChaining.html#ID252" title="Permalink to this headline">¶</a></h2>
<p>You can link together multiple levels of optional chaining to drill down to properties, methods, and subscripts deeper within a model. However, multiple levels of optional chaining do not add more levels of optionality to the returned value.</p>
<p>To put it another way:</p>
<ul class="simple">
<li>If the type you are trying to retrieve is not optional, it will become optional because of the optional chaining.</li>
<li>If the type you are trying to retrieve is <em>already</em> optional, it will not become <em>more</em> optional because of the chaining.</li>
</ul>
<p>Therefore:</p>
<ul class="simple">
<li>If you try to retrieve an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value through optional chaining, an <code class="docutils literal notranslate"><span class="pre">Int?</span></code> is always returned, no matter how many levels of chaining are used.</li>
<li>Similarly, if you try to retrieve an <code class="docutils literal notranslate"><span class="pre">Int?</span></code> value through optional chaining, an <code class="docutils literal notranslate"><span class="pre">Int?</span></code> is always returned, no matter how many levels of chaining are used.</li>
</ul>
<p>The example below tries to access the <code class="docutils literal notranslate"><span class="pre">street</span></code> property of the <code class="docutils literal notranslate"><span class="pre">address</span></code> property of the <code class="docutils literal notranslate"><span class="pre">residence</span></code> property of <code class="docutils literal notranslate"><span class="pre">john</span></code>. There are <em>two</em> levels of optional chaining in use here, to chain through the <code class="docutils literal notranslate"><span class="pre">residence</span></code> and <code class="docutils literal notranslate"><span class="pre">address</span></code> properties, both of which are of optional type:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">johnsStreet</span> = <span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">address</span>?.<span class="nv">street</span> {
</li><li> <span class="nv">print</span>(<span class="s">"John's street name is </span>\<span class="p">(</span><span class="nv">johnsStreet</span><span class="p">)</span><span class="s">."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unable to retrieve the address."</span>)
</li><li>}
</li><li><span class="c">// Prints "Unable to retrieve the address."</span>
</li></ol></div></div></div>
<p>The value of <code class="docutils literal notranslate"><span class="pre">john.residence</span></code> currently contains a valid <code class="docutils literal notranslate"><span class="pre">Residence</span></code> instance. However, the value of <code class="docutils literal notranslate"><span class="pre">john.residence.address</span></code> is currently <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Because of this, the call to <code class="docutils literal notranslate"><span class="pre">john.residence?.address?.street</span></code> fails.</p>
<p>Note that in the example above, you are trying to retrieve the value of the <code class="docutils literal notranslate"><span class="pre">street</span></code> property. The type of this property is <code class="docutils literal notranslate"><span class="pre">String?</span></code>. The return value of <code class="docutils literal notranslate"><span class="pre">john.residence?.address?.street</span></code> is therefore also <code class="docutils literal notranslate"><span class="pre">String?</span></code>, even though two levels of optional chaining are applied in addition to the underlying optional type of the property.</p>
<p>If you set an actual <code class="docutils literal notranslate"><span class="pre">Address</span></code> instance as the value for <code class="docutils literal notranslate"><span class="pre">john.residence.address</span></code>, and set an actual value for the address’s <code class="docutils literal notranslate"><span class="pre">street</span></code> property, you can access the value of the <code class="docutils literal notranslate"><span class="pre">street</span></code> property through multilevel optional chaining:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">johnsAddress</span> = <span class="nv">Address</span>()
</li><li><span class="nv">johnsAddress</span>.<span class="nv">buildingName</span> = <span class="s">"The Larches"</span>
</li><li><span class="nv">johnsAddress</span>.<span class="nv">street</span> = <span class="s">"Laurel Street"</span>
</li><li><span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">address</span> = <span class="nv">johnsAddress</span>
</li><li>
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">johnsStreet</span> = <span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">address</span>?.<span class="nv">street</span> {
</li><li> <span class="nv">print</span>(<span class="s">"John's street name is </span>\<span class="p">(</span><span class="nv">johnsStreet</span><span class="p">)</span><span class="s">."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unable to retrieve the address."</span>)
</li><li>}
</li><li><span class="c">// Prints "John's street name is Laurel Street."</span>
</li></ol></div></div></div>
<p>In this example, the attempt to set the <code class="docutils literal notranslate"><span class="pre">address</span></code> property of <code class="docutils literal notranslate"><span class="pre">john.residence</span></code> will succeed, because the value of <code class="docutils literal notranslate"><span class="pre">john.residence</span></code> currently contains a valid <code class="docutils literal notranslate"><span class="pre">Residence</span></code> instance.</p>
</div>
<div class="section" id="ID253">
<h2>Chaining on Methods with Optional Return Values<a class="headerlink" href="OptionalChaining.html#ID253" title="Permalink to this headline">¶</a></h2>
<p>The previous example shows how to retrieve the value of a property of optional type through optional chaining. You can also use optional chaining to call a method that returns a value of optional type, and to chain on that method’s return value if needed.</p>
<p>The example below calls the <code class="docutils literal notranslate"><span class="pre">Address</span></code> class’s <code class="docutils literal notranslate"><span class="pre">buildingIdentifier()</span></code> method through optional chaining. This method returns a value of type <code class="docutils literal notranslate"><span class="pre">String?</span></code>. As described above, the ultimate return type of this method call after optional chaining is also <code class="docutils literal notranslate"><span class="pre">String?</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">buildingIdentifier</span> = <span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">address</span>?.<span class="nv">buildingIdentifier</span>() {
</li><li> <span class="nv">print</span>(<span class="s">"John's building identifier is </span>\<span class="p">(</span><span class="nv">buildingIdentifier</span><span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li><span class="c">// Prints "John's building identifier is The Larches."</span>
</li></ol></div></div></div>
<p>If you want to perform further optional chaining on this method’s return value, place the optional chaining question mark <em>after</em> the method’s parentheses:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">beginsWithThe</span> =
</li><li> <span class="nv">john</span>.<span class="nv">residence</span>?.<span class="nv">address</span>?.<span class="nv">buildingIdentifier</span>()?.<span class="nv">hasPrefix</span>(<span class="s">"The"</span>) {
</li><li> <span class="k">if</span> <span class="nv">beginsWithThe</span> {
</li><li> <span class="nv">print</span>(<span class="s">"John's building identifier begins with \"The\"."</span>)
</li><li>    } <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"John's building identifier does not begin with \"The\"."</span>)
</li><li>    }
</li><li>}
</li><li><span class="c">// Prints "John's building identifier begins with "The"."</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the example above, you place the optional chaining question mark <em>after</em> the parentheses, because the optional value you are chaining on is the <code class="docutils literal notranslate"><span class="pre">buildingIdentifier()</span></code> method’s return value, and not the <code class="docutils literal notranslate"><span class="pre">buildingIdentifier()</span></code> method itself.</p>
</div>
</div>
</div><div class="section" id="error-handling">
<h1>Error Handling<a class="headerlink" href="ErrorHandling.html#error-handling" title="Permalink to this headline">¶</a></h1>
<p><em>Error handling</em> is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.</p>
<p>Some operations aren’t guaranteed to always complete execution or produce a useful output. Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.</p>
<p>As an example, consider the task of reading and processing data from a file on disk. There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Error handling in Swift interoperates with error handling patterns that use the <code class="docutils literal notranslate"><span class="pre">NSError</span></code> class in Cocoa and Objective-C. For more information about this class, see <a class="reference external" href="https://developer.apple.com/documentation/swift/cocoa_design_patterns/handling_cocoa_errors_in_swift">Handling Cocoa Errors in Swift</a>.</p>
</div>
<div class="section" id="ID509">
<h2>Representing and Throwing Errors<a class="headerlink" href="ErrorHandling.html#ID509" title="Permalink to this headline">¶</a></h2>
<p>In Swift, errors are represented by values of types that conform to the <code class="docutils literal notranslate"><span class="pre">Error</span></code> protocol. This empty protocol indicates that a type can be used for error handling.</p>
<p>Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated. For example, here’s how you might represent the error conditions of operating a vending machine inside a game:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">VendingMachineError</span>: <span class="nc">Error</span> {
</li><li> <span class="k">case</span> <span class="nv">invalidSelection</span>
</li><li> <span class="k">case</span> <span class="nv">insufficientFunds</span>(<span class="nv">coinsNeeded</span>: <span class="nv">Int</span>)
</li><li> <span class="k">case</span> <span class="nv">outOfStock</span>
</li><li>}
</li></ol></div></div></div>
<p>Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue. You use a <code class="docutils literal notranslate"><span class="pre">throw</span></code> statement to throw an error. For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">throw</span> <span class="nv">VendingMachineError</span>.<span class="nv">insufficientFunds</span>(<span class="nv">coinsNeeded</span>: <span class="m">5</span>)
</li></ol></div></div></div>
</div>
<div class="section" id="ID512">
<h2>Handling Errors<a class="headerlink" href="ErrorHandling.html#ID512" title="Permalink to this headline">¶</a></h2>
<p>When an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure.</p>
<p>There are four ways to handle errors in Swift. You can propagate the error from a function to the code that calls that function, handle the error using a <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code> statement, handle the error as an optional value, or assert that the error will not occur. Each approach is described in a section below.</p>
<p>When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors. To identify these places in your code, write the <code class="docutils literal notranslate"><span class="pre">try</span></code> keyword—or the <code class="docutils literal notranslate"><span class="pre">try?</span></code> or <code class="docutils literal notranslate"><span class="pre">try!</span></code> variation—before a piece of code that calls a function, method, or initializer that can throw an error. These keywords are described in the sections below.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Error handling in Swift resembles exception handling in other languages, with the use of the <code class="docutils literal notranslate"><span class="pre">try</span></code>, <code class="docutils literal notranslate"><span class="pre">catch</span></code> and <code class="docutils literal notranslate"><span class="pre">throw</span></code> keywords. Unlike exception handling in many languages—including Objective-C—error handling in Swift does not involve unwinding the call stack, a process that can be computationally expensive. As such, the performance characteristics of a <code class="docutils literal notranslate"><span class="pre">throw</span></code> statement are comparable to those of a <code class="docutils literal notranslate"><span class="pre">return</span></code> statement.</p>
</div>
<div class="section" id="ID510">
<h3>Propagating Errors Using Throwing Functions<a class="headerlink" href="ErrorHandling.html#ID510" title="Permalink to this headline">¶</a></h3>
<p>To indicate that a function, method, or initializer can throw an error, you write the <code class="docutils literal notranslate"><span class="pre">throws</span></code> keyword in the function’s declaration after its parameters. A function marked with <code class="docutils literal notranslate"><span class="pre">throws</span></code> is called a <em>throwing function</em>. If the function specifies a return type, you write the <code class="docutils literal notranslate"><span class="pre">throws</span></code> keyword before the return arrow (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>).</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">canThrowErrors</span>() <span class="k">throws</span> -&gt; <span class="nc">String</span>
</li><li>
</li><li><span class="k">func</span> <span class="nv">cannotThrowErrors</span>() -&gt; <span class="nc">String</span>
</li></ol></div></div></div>
<p>A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only throwing functions can propagate errors. Any errors thrown inside a nonthrowing function must be handled inside the function.</p>
</div>
<p>In the example below, the <code class="docutils literal notranslate"><span class="pre">VendingMachine</span></code> class has a <code class="docutils literal notranslate"><span class="pre">vend(itemNamed:)</span></code> method that throws an appropriate <code class="docutils literal notranslate"><span class="pre">VendingMachineError</span></code> if the requested item is not available, is out of stock, or has a cost that exceeds the current deposited amount:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Item</span> {
</li><li> <span class="k">var</span> <span class="nv">price</span>: <span class="nc">Int</span>
</li><li> <span class="k">var</span> <span class="nv">count</span>: <span class="nc">Int</span>
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">VendingMachine</span> {
</li><li> <span class="k">var</span> <span class="nv">inventory</span> = [
</li><li> <span class="s">"Candy Bar"</span>: <span class="nv">Item</span>(<span class="nv">price</span>: <span class="m">12</span>, <span class="nv">count</span>: <span class="m">7</span>),
</li><li> <span class="s">"Chips"</span>: <span class="nv">Item</span>(<span class="nv">price</span>: <span class="m">10</span>, <span class="nv">count</span>: <span class="m">4</span>),
</li><li> <span class="s">"Pretzels"</span>: <span class="nv">Item</span>(<span class="nv">price</span>: <span class="m">7</span>, <span class="nv">count</span>: <span class="m">11</span>)
</li><li>    ]
</li><li> <span class="k">var</span> <span class="nv">coinsDeposited</span> = <span class="m">0</span>
</li><li>
</li><li> <span class="k">func</span> <span class="nv">vend</span>(<span class="nv">itemNamed</span> <span class="nv">name</span>: <span class="nc">String</span>) <span class="k">throws</span> {
</li><li> <span class="k">guard</span> <span class="k">let</span> <span class="nv">item</span> = <span class="nv">inventory</span>[<span class="nv">name</span>] <span class="k">else</span> {
</li><li> <span class="k">throw</span> <span class="nv">VendingMachineError</span>.<span class="nv">invalidSelection</span>
</li><li>        }
</li><li>
</li><li> <span class="k">guard</span> <span class="nv">item</span>.<span class="nv">count</span> &gt; <span class="m">0</span> <span class="k">else</span> {
</li><li> <span class="k">throw</span> <span class="nv">VendingMachineError</span>.<span class="nv">outOfStock</span>
</li><li>        }
</li><li>
</li><li> <span class="k">guard</span> <span class="nv">item</span>.<span class="nv">price</span> &lt;= <span class="nv">coinsDeposited</span> <span class="k">else</span> {
</li><li> <span class="k">throw</span> <span class="nv">VendingMachineError</span>.<span class="nv">insufficientFunds</span>(<span class="nv">coinsNeeded</span>: <span class="nv">item</span>.<span class="nv">price</span> - <span class="nv">coinsDeposited</span>)
</li><li>        }
</li><li>
</li><li> <span class="nv">coinsDeposited</span> -= <span class="nv">item</span>.<span class="nv">price</span>
</li><li>
</li><li> <span class="k">var</span> <span class="nv">newItem</span> = <span class="nv">item</span>
</li><li> <span class="nv">newItem</span>.<span class="nv">count</span> -= <span class="m">1</span>
</li><li> <span class="nv">inventory</span>[<span class="nv">name</span>] = <span class="nv">newItem</span>
</li><li>
</li><li> <span class="nv">print</span>(<span class="s">"Dispensing </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">"</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The implementation of the <code class="docutils literal notranslate"><span class="pre">vend(itemNamed:)</span></code> method uses <code class="docutils literal notranslate"><span class="pre">guard</span></code> statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met. Because a <code class="docutils literal notranslate"><span class="pre">throw</span></code> statement immediately transfers program control, an item will be vended only if all of these requirements are met.</p>
<p>Because the <code class="docutils literal notranslate"><span class="pre">vend(itemNamed:)</span></code> method propagates any errors it throws, any code that calls this method must either handle the errors—using a <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code> statement, <code class="docutils literal notranslate"><span class="pre">try?</span></code>, or <code class="docutils literal notranslate"><span class="pre">try!</span></code>—or continue to propagate them. For example, the <code class="docutils literal notranslate"><span class="pre">buyFavoriteSnack(person:vendingMachine:)</span></code> in the example below is also a throwing function, and any errors that the <code class="docutils literal notranslate"><span class="pre">vend(itemNamed:)</span></code> method throws will propagate up to the point where the <code class="docutils literal notranslate"><span class="pre">buyFavoriteSnack(person:vendingMachine:)</span></code> function is called.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">favoriteSnacks</span> = [
</li><li> <span class="s">"Alice"</span>: <span class="s">"Chips"</span>,
</li><li> <span class="s">"Bob"</span>: <span class="s">"Licorice"</span>,
</li><li> <span class="s">"Eve"</span>: <span class="s">"Pretzels"</span>,
</li><li>]
</li><li><span class="k">func</span> <span class="nv">buyFavoriteSnack</span>(<span class="nv">person</span>: <span class="nc">String</span>, <span class="nv">vendingMachine</span>: <span class="nc">VendingMachine</span>) <span class="k">throws</span> {
</li><li> <span class="k">let</span> <span class="nv">snackName</span> = <span class="nv">favoriteSnacks</span>[<span class="nv">person</span>] ?? <span class="s">"Candy Bar"</span>
</li><li> <span class="k">try</span> <span class="nv">vendingMachine</span>.<span class="nv">vend</span>(<span class="nv">itemNamed</span>: <span class="nv">snackName</span>)
</li><li>}
</li></ol></div></div></div>
<p>In this example, the <code class="docutils literal notranslate"><span class="pre">buyFavoriteSnack(person:</span> <span class="pre">vendingMachine:)</span></code> function looks up a given person’s favorite snack and tries to buy it for them by calling the <code class="docutils literal notranslate"><span class="pre">vend(itemNamed:)</span></code> method. Because the <code class="docutils literal notranslate"><span class="pre">vend(itemNamed:)</span></code> method can throw an error, it’s called with the <code class="docutils literal notranslate"><span class="pre">try</span></code> keyword in front of it.</p>
<p>Throwing initializers can propagate errors in the same way as throwing functions. For example, the initializer for the <code class="docutils literal notranslate"><span class="pre">PurchasedSnack</span></code> structure in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">PurchasedSnack</span> {
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">vendingMachine</span>: <span class="nc">VendingMachine</span>) <span class="k">throws</span> {
</li><li> <span class="k">try</span> <span class="nv">vendingMachine</span>.<span class="nv">vend</span>(<span class="nv">itemNamed</span>: <span class="nv">name</span>)
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID541">
<h3>Handling Errors Using Do-Catch<a class="headerlink" href="ErrorHandling.html#ID541" title="Permalink to this headline">¶</a></h3>
<p>You use a <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code> statement to handle errors by running a block of code. If an error is thrown by the code in the <code class="docutils literal notranslate"><span class="pre">do</span></code> clause, it is matched against the <code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses to determine which one of them can handle the error.</p>
<p>Here is the general form of a <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code> statement:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">do</span> {
</li><li> <span class="k">try</span> <span class="gi">expression</span>
</li><li> <span class="gi">statements</span>
</li><li>} <span class="k">catch</span> <span class="gi">pattern 1</span> {
</li><li> <span class="gi">statements</span>
</li><li>} <span class="k">catch</span> <span class="gi">pattern 2</span> <span class="k">where</span> <span class="gi">condition</span> {
</li><li> <span class="gi">statements</span>
</li><li>} <span class="k">catch</span> {
</li><li> <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>You write a pattern after <code class="docutils literal notranslate"><span class="pre">catch</span></code> to indicate what errors that clause can handle. If a <code class="docutils literal notranslate"><span class="pre">catch</span></code> clause doesn’t have a pattern, the clause matches any error and binds the error to a local constant named <code class="docutils literal notranslate"><span class="pre">error</span></code>. For more information about pattern matching, see <a class="reference internal" href="../ReferenceManual/Patterns.html"><span class="doc">Patterns</span></a>.</p>
<p>For example, the following code matches against all three cases of the <code class="docutils literal notranslate"><span class="pre">VendingMachineError</span></code> enumeration.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">vendingMachine</span> = <span class="nv">VendingMachine</span>()
</li><li><span class="nv">vendingMachine</span>.<span class="nv">coinsDeposited</span> = <span class="m">8</span>
</li><li><span class="k">do</span> {
</li><li> <span class="k">try</span> <span class="nv">buyFavoriteSnack</span>(<span class="nv">person</span>: <span class="s">"Alice"</span>, <span class="nv">vendingMachine</span>: <span class="nv">vendingMachine</span>)
</li><li> <span class="nv">print</span>(<span class="s">"Success! Yum."</span>)
</li><li>} <span class="k">catch</span> <span class="nv">VendingMachineError</span>.<span class="nv">invalidSelection</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Invalid Selection."</span>)
</li><li>} <span class="k">catch</span> <span class="nv">VendingMachineError</span>.<span class="nv">outOfStock</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Out of Stock."</span>)
</li><li>} <span class="k">catch</span> <span class="nv">VendingMachineError</span>.<span class="nv">insufficientFunds</span>(<span class="k">let</span> <span class="nv">coinsNeeded</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Insufficient funds. Please insert an additional </span>\<span class="p">(</span><span class="nv">coinsNeeded</span><span class="p">)</span><span class="s"> coins."</span>)
</li><li>} <span class="k">catch</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unexpected error: </span>\<span class="p">(</span><span class="nv">error</span><span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li><span class="c">// Prints "Insufficient funds. Please insert an additional 2 coins."</span>
</li></ol></div></div></div>
<p>In the above example, the <code class="docutils literal notranslate"><span class="pre">buyFavoriteSnack(person:vendingMachine:)</span></code> function is called in a <code class="docutils literal notranslate"><span class="pre">try</span></code> expression, because it can throw an error. If an error is thrown, execution immediately transfers to the <code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses, which decide whether to allow propagation to continue. If no pattern is matched, the error gets caught by the final <code class="docutils literal notranslate"><span class="pre">catch</span></code> clause and is bound to a local <code class="docutils literal notranslate"><span class="pre">error</span></code> constant. If no error is thrown, the remaining statements in the <code class="docutils literal notranslate"><span class="pre">do</span></code> statement are executed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses don’t have to handle every possible error that the code in the <code class="docutils literal notranslate"><span class="pre">do</span></code> clause can throw. If none of the <code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses handle the error, the error propagates to the surrounding scope. However, the propagated error must be handled by <em>some</em> surrounding scope. In a nonthrowing function, an enclosing <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code> clause must handle the error. In a throwing function, either an enclosing <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code> clause or the caller must handle the error. If the error propagates to the top-level scope without being handled, you’ll get a runtime error.</p>
<p>For example, the above example can be written so any error that isn’t a <code class="docutils literal notranslate"><span class="pre">VendingMachineError</span></code> is instead caught by the calling function:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">nourish</span>(<span class="nv">with</span> <span class="nv">item</span>: <span class="nc">String</span>) <span class="k">throws</span> {
</li><li> <span class="k">do</span> {
</li><li> <span class="k">try</span> <span class="nv">vendingMachine</span>.<span class="nv">vend</span>(<span class="nv">itemNamed</span>: <span class="nv">item</span>)
</li><li>    } <span class="k">catch</span> <span class="k">is</span> <span class="nc">VendingMachineError</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Invalid selection, out of stock, or not enough money."</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">do</span> {
</li><li> <span class="k">try</span> <span class="nv">nourish</span>(<span class="nv">with</span>: <span class="s">"Beet-Flavored Chips"</span>)
</li><li>} <span class="k">catch</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Unexpected non-vending-machine-related error: </span>\<span class="p">(</span><span class="nv">error</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Prints "Invalid selection, out of stock, or not enough money."</span>
</li></ol></div></div></div>
<p>In the <code class="docutils literal notranslate"><span class="pre">nourish(with:)</span></code> function, if <code class="docutils literal notranslate"><span class="pre">vend(itemNamed:)</span></code> throws an error that’s one of the cases of the <code class="docutils literal notranslate"><span class="pre">VendingMachineError</span></code> enumeration, <code class="docutils literal notranslate"><span class="pre">nourish(with:)</span></code> handles the error by printing a message. Otherwise, <code class="docutils literal notranslate"><span class="pre">nourish(with:)</span></code> propagates the error to its call site. The error is then caught by the general <code class="docutils literal notranslate"><span class="pre">catch</span></code> clause.</p>
</div>
<div class="section" id="ID542">
<h3>Converting Errors to Optional Values<a class="headerlink" href="ErrorHandling.html#ID542" title="Permalink to this headline">¶</a></h3>
<p>You use <code class="docutils literal notranslate"><span class="pre">try?</span></code> to handle an error by converting it to an optional value. If an error is thrown while evaluating the <code class="docutils literal notranslate"><span class="pre">try?</span></code> expression, the value of the expression is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. For example, in the following code <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> have the same value and behavior:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someThrowingFunction</span>() <span class="k">throws</span> -&gt; <span class="nc">Int</span> {
</li><li> <span class="c">// ...</span>
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">x</span> = <span class="k">try</span>? <span class="nv">someThrowingFunction</span>()
</li><li>
</li><li><span class="k">let</span> <span class="nv">y</span>: <span class="nc">Int</span>?
</li><li><span class="k">do</span> {
</li><li> <span class="nv">y</span> = <span class="k">try</span> <span class="nv">someThrowingFunction</span>()
</li><li>} <span class="k">catch</span> {
</li><li> <span class="nv">y</span> = <span class="k">nil</span>
</li><li>}
</li></ol></div></div></div>
<p>If <code class="docutils literal notranslate"><span class="pre">someThrowingFunction()</span></code> throws an error, the value of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Otherwise, the value of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> is the value that the function returned. Note that <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are an optional of whatever type <code class="docutils literal notranslate"><span class="pre">someThrowingFunction()</span></code> returns. Here the function returns an integer, so <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are optional integers.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">try?</span></code> lets you write concise error handling code when you want to handle all errors in the same way. For example, the following code uses several approaches to fetch data, or returns <code class="docutils literal notranslate"><span class="pre">nil</span></code> if all of the approaches fail.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">fetchData</span>() -&gt; <span class="nc">Data</span>? {
</li><li> <span class="k">if</span> <span class="k">let</span> <span class="nv">data</span> = <span class="k">try</span>? <span class="nv">fetchDataFromDisk</span>() { <span class="k">return</span> <span class="nv">data</span> }
</li><li> <span class="k">if</span> <span class="k">let</span> <span class="nv">data</span> = <span class="k">try</span>? <span class="nv">fetchDataFromServer</span>() { <span class="k">return</span> <span class="nv">data</span> }
</li><li> <span class="k">return</span> <span class="k">nil</span>
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID513">
<h3>Disabling Error Propagation<a class="headerlink" href="ErrorHandling.html#ID513" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime. On those occasions, you can write <code class="docutils literal notranslate"><span class="pre">try!</span></code> before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown. If an error actually is thrown, you’ll get a runtime error.</p>
<p>For example, the following code uses a <code class="docutils literal notranslate"><span class="pre">loadImage(atPath:)</span></code> function, which loads the image resource at a given path or throws an error if the image can’t be loaded. In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">photo</span> = <span class="k">try</span>! <span class="nv">loadImage</span>(<span class="nv">atPath</span>: <span class="s">"./Resources/John Appleseed.jpg"</span>)
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID514">
<h2>Specifying Cleanup Actions<a class="headerlink" href="ErrorHandling.html#ID514" title="Permalink to this headline">¶</a></h2>
<p>You use a <code class="docutils literal notranslate"><span class="pre">defer</span></code> statement to execute a set of statements just before code execution leaves the current block of code. This statement lets you do any necessary cleanup that should be performed regardless of <em>how</em> execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as <code class="docutils literal notranslate"><span class="pre">return</span></code> or <code class="docutils literal notranslate"><span class="pre">break</span></code>. For example, you can use a <code class="docutils literal notranslate"><span class="pre">defer</span></code> statement to ensure that file descriptors are closed and manually allocated memory is freed.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">defer</span></code> statement defers execution until the current scope is exited. This statement consists of the <code class="docutils literal notranslate"><span class="pre">defer</span></code> keyword and the statements to be executed later. The deferred statements may not contain any code that would transfer control out of the statements, such as a <code class="docutils literal notranslate"><span class="pre">break</span></code> or a <code class="docutils literal notranslate"><span class="pre">return</span></code> statement, or by throwing an error. Deferred actions are executed in the reverse of the order that they’re written in your source code. That is, the code in the first <code class="docutils literal notranslate"><span class="pre">defer</span></code> statement executes last, the code in the second <code class="docutils literal notranslate"><span class="pre">defer</span></code> statement executes second to last, and so on. The last <code class="docutils literal notranslate"><span class="pre">defer</span></code> statement in source code order executes first.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">processFile</span>(<span class="nv">filename</span>: <span class="nc">String</span>) <span class="k">throws</span> {
</li><li> <span class="k">if</span> <span class="nv">exists</span>(<span class="nv">filename</span>) {
</li><li> <span class="k">let</span> <span class="nv">file</span> = <span class="nv">open</span>(<span class="nv">filename</span>)
</li><li> <span class="k">defer</span> {
</li><li> <span class="nv">close</span>(<span class="nv">file</span>)
</li><li>        }
</li><li> <span class="k">while</span> <span class="k">let</span> <span class="nv">line</span> = <span class="k">try</span> <span class="nv">file</span>.<span class="nv">readline</span>() {
</li><li> <span class="c">// Work with the file.</span>
</li><li>        }
</li><li> <span class="c">// close(file) is called here, at the end of the scope.</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The above example uses a <code class="docutils literal notranslate"><span class="pre">defer</span></code> statement to ensure that the <code class="docutils literal notranslate"><span class="pre">open(_:)</span></code> function has a corresponding call to <code class="docutils literal notranslate"><span class="pre">close(_:)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can use a <code class="docutils literal notranslate"><span class="pre">defer</span></code> statement even when no error handling code is involved.</p>
</div>
</div>
</div><div class="section" id="type-casting">
<h1>Type Casting<a class="headerlink" href="TypeCasting.html#type-casting" title="Permalink to this headline">¶</a></h1>
<p><em>Type casting</em> is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.</p>
<p>Type casting in Swift is implemented with the <code class="docutils literal notranslate"><span class="pre">is</span></code> and <code class="docutils literal notranslate"><span class="pre">as</span></code> operators. These two operators provide a simple and expressive way to check the type of a value or cast a value to a different type.</p>
<p>You can also use type casting to check whether a type conforms to a protocol, as described in <a class="reference internal" href="Protocols.html#ID283"><span class="std std-ref">Checking for Protocol Conformance</span></a>.</p>
<div class="section" id="ID339">
<h2>Defining a Class Hierarchy for Type Casting<a class="headerlink" href="TypeCasting.html#ID339" title="Permalink to this headline">¶</a></h2>
<p>You can use type casting with a hierarchy of classes and subclasses to check the type of a particular class instance and to cast that instance to another class within the same hierarchy. The three code snippets below define a hierarchy of classes and an array containing instances of those classes, for use in an example of type casting.</p>
<p>The first snippet defines a new base class called <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code>. This class provides basic functionality for any kind of item that appears in a digital media library. Specifically, it declares a <code class="docutils literal notranslate"><span class="pre">name</span></code> property of type <code class="docutils literal notranslate"><span class="pre">String</span></code>, and an <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">name</span></code> initializer. (It is assumed that all media items, including all movies and songs, will have a name.)</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">MediaItem</span> {
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The next snippet defines two subclasses of <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code>. The first subclass, <code class="docutils literal notranslate"><span class="pre">Movie</span></code>, encapsulates additional information about a movie or film. It adds a <code class="docutils literal notranslate"><span class="pre">director</span></code> property on top of the base <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code> class, with a corresponding initializer. The second subclass, <code class="docutils literal notranslate"><span class="pre">Song</span></code>, adds an <code class="docutils literal notranslate"><span class="pre">artist</span></code> property and initializer on top of the base class:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Movie</span>: <span class="nc">MediaItem</span> {
</li><li> <span class="k">var</span> <span class="nv">director</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">director</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">director</span> = <span class="nv">director</span>
</li><li> <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="nv">name</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">Song</span>: <span class="nc">MediaItem</span> {
</li><li> <span class="k">var</span> <span class="nv">artist</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">artist</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">artist</span> = <span class="nv">artist</span>
</li><li> <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="nv">name</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The final snippet creates a constant array called <code class="docutils literal notranslate"><span class="pre">library</span></code>, which contains two <code class="docutils literal notranslate"><span class="pre">Movie</span></code> instances and three <code class="docutils literal notranslate"><span class="pre">Song</span></code> instances. The type of the <code class="docutils literal notranslate"><span class="pre">library</span></code> array is inferred by initializing it with the contents of an array literal. Swift’s type checker is able to deduce that <code class="docutils literal notranslate"><span class="pre">Movie</span></code> and <code class="docutils literal notranslate"><span class="pre">Song</span></code> have a common superclass of <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code>, and so it infers a type of <code class="docutils literal notranslate"><span class="pre">[MediaItem]</span></code> for the <code class="docutils literal notranslate"><span class="pre">library</span></code> array:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">library</span> = [
</li><li> <span class="nv">Movie</span>(<span class="nv">name</span>: <span class="s">"Casablanca"</span>, <span class="nv">director</span>: <span class="s">"Michael Curtiz"</span>),
</li><li> <span class="nv">Song</span>(<span class="nv">name</span>: <span class="s">"Blue Suede Shoes"</span>, <span class="nv">artist</span>: <span class="s">"Elvis Presley"</span>),
</li><li> <span class="nv">Movie</span>(<span class="nv">name</span>: <span class="s">"Citizen Kane"</span>, <span class="nv">director</span>: <span class="s">"Orson Welles"</span>),
</li><li> <span class="nv">Song</span>(<span class="nv">name</span>: <span class="s">"The One And Only"</span>, <span class="nv">artist</span>: <span class="s">"Chesney Hawkes"</span>),
</li><li> <span class="nv">Song</span>(<span class="nv">name</span>: <span class="s">"Never Gonna Give You Up"</span>, <span class="nv">artist</span>: <span class="s">"Rick Astley"</span>)
</li><li>]
</li><li><span class="c">// the type of "library" is inferred to be [MediaItem]</span>
</li></ol></div></div></div>
<p>The items stored in <code class="docutils literal notranslate"><span class="pre">library</span></code> are still <code class="docutils literal notranslate"><span class="pre">Movie</span></code> and <code class="docutils literal notranslate"><span class="pre">Song</span></code> instances behind the scenes. However, if you iterate over the contents of this array, the items you receive back are typed as <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code>, and not as <code class="docutils literal notranslate"><span class="pre">Movie</span></code> or <code class="docutils literal notranslate"><span class="pre">Song</span></code>. In order to work with them as their native type, you need to <em>check</em> their type, or <em>downcast</em> them to a different type, as described below.</p>
</div>
<div class="section" id="ID340">
<h2>Checking Type<a class="headerlink" href="TypeCasting.html#ID340" title="Permalink to this headline">¶</a></h2>
<p>Use the <em>type check operator</em> (<code class="docutils literal notranslate"><span class="pre">is</span></code>) to check whether an instance is of a certain subclass type. The type check operator returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the instance is of that subclass type and <code class="docutils literal notranslate"><span class="pre">false</span></code> if it is not.</p>
<p>The example below defines two variables, <code class="docutils literal notranslate"><span class="pre">movieCount</span></code> and <code class="docutils literal notranslate"><span class="pre">songCount</span></code>, which count the number of <code class="docutils literal notranslate"><span class="pre">Movie</span></code> and <code class="docutils literal notranslate"><span class="pre">Song</span></code> instances in the <code class="docutils literal notranslate"><span class="pre">library</span></code> array:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">movieCount</span> = <span class="m">0</span>
</li><li><span class="k">var</span> <span class="nv">songCount</span> = <span class="m">0</span>
</li><li>
</li><li><span class="k">for</span> <span class="nv">item</span> <span class="k">in</span> <span class="nv">library</span> {
</li><li> <span class="k">if</span> <span class="nv">item</span> <span class="k">is</span> <span class="nc">Movie</span> {
</li><li> <span class="nv">movieCount</span> += <span class="m">1</span>
</li><li>    } <span class="k">else</span> <span class="k">if</span> <span class="nv">item</span> <span class="k">is</span> <span class="nc">Song</span> {
</li><li> <span class="nv">songCount</span> += <span class="m">1</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="nv">print</span>(<span class="s">"Media library contains </span>\<span class="p">(</span><span class="nv">movieCount</span><span class="p">)</span><span class="s"> movies and </span>\<span class="p">(</span><span class="nv">songCount</span><span class="p">)</span><span class="s"> songs"</span>)
</li><li><span class="c">// Prints "Media library contains 2 movies and 3 songs"</span>
</li></ol></div></div></div>
<p>This example iterates through all items in the <code class="docutils literal notranslate"><span class="pre">library</span></code> array. On each pass, the <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop sets the <code class="docutils literal notranslate"><span class="pre">item</span></code> constant to the next <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code> in the array.</p>
<p><code class="docutils literal notranslate"><span class="pre">item</span> <span class="pre">is</span> <span class="pre">Movie</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the current <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code> is a <code class="docutils literal notranslate"><span class="pre">Movie</span></code> instance and <code class="docutils literal notranslate"><span class="pre">false</span></code> if it is not. Similarly, <code class="docutils literal notranslate"><span class="pre">item</span> <span class="pre">is</span> <span class="pre">Song</span></code> checks whether the item is a <code class="docutils literal notranslate"><span class="pre">Song</span></code> instance. At the end of the <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop, the values of <code class="docutils literal notranslate"><span class="pre">movieCount</span></code> and <code class="docutils literal notranslate"><span class="pre">songCount</span></code> contain a count of how many <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code> instances were found of each type.</p>
</div>
<div class="section" id="ID341">
<h2>Downcasting<a class="headerlink" href="TypeCasting.html#ID341" title="Permalink to this headline">¶</a></h2>
<p>A constant or variable of a certain class type may actually refer to an instance of a subclass behind the scenes. Where you believe this is the case, you can try to <em>downcast</em> to the subclass type with a <em>type cast operator</em> (<code class="docutils literal notranslate"><span class="pre">as?</span></code> or <code class="docutils literal notranslate"><span class="pre">as!</span></code>).</p>
<p>Because downcasting can fail, the type cast operator comes in two different forms. The conditional form, <code class="docutils literal notranslate"><span class="pre">as?</span></code>, returns an optional value of the type you are trying to downcast to. The forced form, <code class="docutils literal notranslate"><span class="pre">as!</span></code>, attempts the downcast and force-unwraps the result as a single compound action.</p>
<p>Use the conditional form of the type cast operator (<code class="docutils literal notranslate"><span class="pre">as?</span></code>) when you are not sure if the downcast will succeed. This form of the operator will always return an optional value, and the value will be <code class="docutils literal notranslate"><span class="pre">nil</span></code> if the downcast was not possible. This enables you to check for a successful downcast.</p>
<p>Use the forced form of the type cast operator (<code class="docutils literal notranslate"><span class="pre">as!</span></code>) only when you are sure that the downcast will always succeed. This form of the operator will trigger a runtime error if you try to downcast to an incorrect class type.</p>
<p>The example below iterates over each <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code> in <code class="docutils literal notranslate"><span class="pre">library</span></code>, and prints an appropriate description for each item. To do this, it needs to access each item as a true <code class="docutils literal notranslate"><span class="pre">Movie</span></code> or <code class="docutils literal notranslate"><span class="pre">Song</span></code>, and not just as a <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code>. This is necessary in order for it to be able to access the <code class="docutils literal notranslate"><span class="pre">director</span></code> or <code class="docutils literal notranslate"><span class="pre">artist</span></code> property of a <code class="docutils literal notranslate"><span class="pre">Movie</span></code> or <code class="docutils literal notranslate"><span class="pre">Song</span></code> for use in the description.</p>
<p>In this example, each item in the array might be a <code class="docutils literal notranslate"><span class="pre">Movie</span></code>, or it might be a <code class="docutils literal notranslate"><span class="pre">Song</span></code>. You don’t know in advance which actual class to use for each item, and so it is appropriate to use the conditional form of the type cast operator (<code class="docutils literal notranslate"><span class="pre">as?</span></code>) to check the downcast each time through the loop:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">item</span> <span class="k">in</span> <span class="nv">library</span> {
</li><li> <span class="k">if</span> <span class="k">let</span> <span class="nv">movie</span> = <span class="nv">item</span> <span class="k">as</span>? <span class="nc">Movie</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Movie: </span>\<span class="p">(</span><span class="nv">movie</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, dir. </span>\<span class="p">(</span><span class="nv">movie</span>.<span class="nv">director</span><span class="p">)</span><span class="s">"</span>)
</li><li>    } <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nv">song</span> = <span class="nv">item</span> <span class="k">as</span>? <span class="nc">Song</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Song: </span>\<span class="p">(</span><span class="nv">song</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, by </span>\<span class="p">(</span><span class="nv">song</span>.<span class="nv">artist</span><span class="p">)</span><span class="s">"</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="c">// Movie: Casablanca, dir. Michael Curtiz</span>
</li><li><span class="c">// Song: Blue Suede Shoes, by Elvis Presley</span>
</li><li><span class="c">// Movie: Citizen Kane, dir. Orson Welles</span>
</li><li><span class="c">// Song: The One And Only, by Chesney Hawkes</span>
</li><li><span class="c">// Song: Never Gonna Give You Up, by Rick Astley</span>
</li></ol></div></div></div>
<p>The example starts by trying to downcast the current <code class="docutils literal notranslate"><span class="pre">item</span></code> as a <code class="docutils literal notranslate"><span class="pre">Movie</span></code>. Because <code class="docutils literal notranslate"><span class="pre">item</span></code> is a <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code> instance, it’s possible that it <em>might</em> be a <code class="docutils literal notranslate"><span class="pre">Movie</span></code>; equally, it’s also possible that it might be a <code class="docutils literal notranslate"><span class="pre">Song</span></code>, or even just a base <code class="docutils literal notranslate"><span class="pre">MediaItem</span></code>. Because of this uncertainty, the <code class="docutils literal notranslate"><span class="pre">as?</span></code> form of the type cast operator returns an <em>optional</em> value when attempting to downcast to a subclass type. The result of <code class="docutils literal notranslate"><span class="pre">item</span> <span class="pre">as?</span> <span class="pre">Movie</span></code> is of type <code class="docutils literal notranslate"><span class="pre">Movie?</span></code>, or “optional <code class="docutils literal notranslate"><span class="pre">Movie</span></code>”.</p>
<p>Downcasting to <code class="docutils literal notranslate"><span class="pre">Movie</span></code> fails when applied to the <code class="docutils literal notranslate"><span class="pre">Song</span></code> instances in the library array. To cope with this, the example above uses optional binding to check whether the optional <code class="docutils literal notranslate"><span class="pre">Movie</span></code> actually contains a value (that is, to find out whether the downcast succeeded.) This optional binding is written “<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">let</span> <span class="pre">movie</span> <span class="pre">=</span> <span class="pre">item</span> <span class="pre">as?</span> <span class="pre">Movie</span></code>”, which can be read as:</p>
<p>“Try to access <code class="docutils literal notranslate"><span class="pre">item</span></code> as a <code class="docutils literal notranslate"><span class="pre">Movie</span></code>. If this is successful, set a new temporary constant called <code class="docutils literal notranslate"><span class="pre">movie</span></code> to the value stored in the returned optional <code class="docutils literal notranslate"><span class="pre">Movie</span></code>.”</p>
<p>If the downcasting succeeds, the properties of <code class="docutils literal notranslate"><span class="pre">movie</span></code> are then used to print a description for that <code class="docutils literal notranslate"><span class="pre">Movie</span></code> instance, including the name of its <code class="docutils literal notranslate"><span class="pre">director</span></code>. A similar principle is used to check for <code class="docutils literal notranslate"><span class="pre">Song</span></code> instances, and to print an appropriate description (including <code class="docutils literal notranslate"><span class="pre">artist</span></code> name) whenever a <code class="docutils literal notranslate"><span class="pre">Song</span></code> is found in the library.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Casting does not actually modify the instance or change its values. The underlying instance remains the same; it is simply treated and accessed as an instance of the type to which it has been cast.</p>
</div>
</div>
<div class="section" id="ID342">
<h2>Type Casting for Any and AnyObject<a class="headerlink" href="TypeCasting.html#ID342" title="Permalink to this headline">¶</a></h2>
<p>Swift provides two special types for working with nonspecific types:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Any</span></code> can represent an instance of any type at all, including function types.</li>
<li><code class="docutils literal notranslate"><span class="pre">AnyObject</span></code> can represent an instance of any class type.</li>
</ul>
<p>Use <code class="docutils literal notranslate"><span class="pre">Any</span></code> and <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code> only when you explicitly need the behavior and capabilities they provide. It is always better to be specific about the types you expect to work with in your code.</p>
<p>Here’s an example of using <code class="docutils literal notranslate"><span class="pre">Any</span></code> to work with a mix of different types, including function types and nonclass types. The example creates an array called <code class="docutils literal notranslate"><span class="pre">things</span></code>, which can store values of type <code class="docutils literal notranslate"><span class="pre">Any</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">things</span> = [<span class="k">Any</span>]()
</li><li>
</li><li><span class="nv">things</span>.<span class="nv">append</span>(<span class="m">0</span>)
</li><li><span class="nv">things</span>.<span class="nv">append</span>(<span class="m">0.0</span>)
</li><li><span class="nv">things</span>.<span class="nv">append</span>(<span class="m">42</span>)
</li><li><span class="nv">things</span>.<span class="nv">append</span>(<span class="m">3.14159</span>)
</li><li><span class="nv">things</span>.<span class="nv">append</span>(<span class="s">"hello"</span>)
</li><li><span class="nv">things</span>.<span class="nv">append</span>((<span class="m">3.0</span>, <span class="m">5.0</span>))
</li><li><span class="nv">things</span>.<span class="nv">append</span>(<span class="nv">Movie</span>(<span class="nv">name</span>: <span class="s">"Ghostbusters"</span>, <span class="nv">director</span>: <span class="s">"Ivan Reitman"</span>))
</li><li><span class="nv">things</span>.<span class="nv">append</span>({ (<span class="nv">name</span>: <span class="nc">String</span>) -&gt; <span class="nc">String</span> <span class="k">in</span> <span class="s">"Hello, </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">"</span> })
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">things</span></code> array contains two <code class="docutils literal notranslate"><span class="pre">Int</span></code> values, two <code class="docutils literal notranslate"><span class="pre">Double</span></code> values, a <code class="docutils literal notranslate"><span class="pre">String</span></code> value, a tuple of type <code class="docutils literal notranslate"><span class="pre">(Double,</span> <span class="pre">Double)</span></code>, the movie “Ghostbusters”, and a closure expression that takes a <code class="docutils literal notranslate"><span class="pre">String</span></code> value and returns another <code class="docutils literal notranslate"><span class="pre">String</span></code> value.</p>
<p>To discover the specific type of a constant or variable that is known only to be of type <code class="docutils literal notranslate"><span class="pre">Any</span></code> or <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>, you can use an <code class="docutils literal notranslate"><span class="pre">is</span></code> or <code class="docutils literal notranslate"><span class="pre">as</span></code> pattern in a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement’s cases. The example below iterates over the items in the <code class="docutils literal notranslate"><span class="pre">things</span></code> array and queries the type of each item with a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement. Several of the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement’s cases bind their matched value to a constant of the specified type to enable its value to be printed:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">thing</span> <span class="k">in</span> <span class="nv">things</span> {
</li><li> <span class="k">switch</span> <span class="nv">thing</span> {
</li><li> <span class="k">case</span> <span class="m">0</span> <span class="k">as</span> <span class="nc">Int</span>:
</li><li> <span class="nv">print</span>(<span class="s">"zero as an Int"</span>)
</li><li> <span class="k">case</span> <span class="m">0</span> <span class="k">as</span> <span class="nc">Double</span>:
</li><li> <span class="nv">print</span>(<span class="s">"zero as a Double"</span>)
</li><li> <span class="k">case</span> <span class="k">let</span> <span class="nv">someInt</span> <span class="k">as</span> <span class="nc">Int</span>:
</li><li> <span class="nv">print</span>(<span class="s">"an integer value of </span>\<span class="p">(</span><span class="nv">someInt</span><span class="p">)</span><span class="s">"</span>)
</li><li> <span class="k">case</span> <span class="k">let</span> <span class="nv">someDouble</span> <span class="k">as</span> <span class="nc">Double</span> <span class="k">where</span> <span class="nv">someDouble</span> &gt; <span class="m">0</span>:
</li><li> <span class="nv">print</span>(<span class="s">"a positive double value of </span>\<span class="p">(</span><span class="nv">someDouble</span><span class="p">)</span><span class="s">"</span>)
</li><li> <span class="k">case</span> <span class="k">is</span> <span class="nc">Double</span>:
</li><li> <span class="nv">print</span>(<span class="s">"some other double value that I don't want to print"</span>)
</li><li> <span class="k">case</span> <span class="k">let</span> <span class="nv">someString</span> <span class="k">as</span> <span class="nc">String</span>:
</li><li> <span class="nv">print</span>(<span class="s">"a string value of \"</span>\<span class="p">(</span><span class="nv">someString</span><span class="p">)</span><span class="s">\""</span>)
</li><li> <span class="k">case</span> <span class="k">let</span> (<span class="nv">x</span>, <span class="nv">y</span>) <span class="k">as</span> (<span class="nc">Double</span>, <span class="nc">Double</span>):
</li><li> <span class="nv">print</span>(<span class="s">"an (x, y) point at </span>\<span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">y</span><span class="p">)</span><span class="s">"</span>)
</li><li> <span class="k">case</span> <span class="k">let</span> <span class="nv">movie</span> <span class="k">as</span> <span class="nc">Movie</span>:
</li><li> <span class="nv">print</span>(<span class="s">"a movie called </span>\<span class="p">(</span><span class="nv">movie</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, dir. </span>\<span class="p">(</span><span class="nv">movie</span>.<span class="nv">director</span><span class="p">)</span><span class="s">"</span>)
</li><li> <span class="k">case</span> <span class="k">let</span> <span class="nv">stringConverter</span> <span class="k">as</span> (<span class="nc">String</span>) -&gt; <span class="nc">String</span>:
</li><li> <span class="nv">print</span>(<span class="nv">stringConverter</span>(<span class="s">"Michael"</span>))
</li><li> <span class="k">default</span>:
</li><li> <span class="nv">print</span>(<span class="s">"something else"</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="c">// zero as an Int</span>
</li><li><span class="c">// zero as a Double</span>
</li><li><span class="c">// an integer value of 42</span>
</li><li><span class="c">// a positive double value of 3.14159</span>
</li><li><span class="c">// a string value of "hello"</span>
</li><li><span class="c">// an (x, y) point at 3.0, 5.0</span>
</li><li><span class="c">// a movie called Ghostbusters, dir. Ivan Reitman</span>
</li><li><span class="c">// Hello, Michael</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Any</span></code> type represents values of any type, including optional types. Swift gives you a warning if you use an optional value where a value of type <code class="docutils literal notranslate"><span class="pre">Any</span></code> is expected. If you really do need to use an optional value as an <code class="docutils literal notranslate"><span class="pre">Any</span></code> value, you can use the <code class="docutils literal notranslate"><span class="pre">as</span></code> operator to explicitly cast the optional to <code class="docutils literal notranslate"><span class="pre">Any</span></code>, as shown below.</p>
<div class="last highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">optionalNumber</span>: <span class="nc">Int</span>? = <span class="m">3</span>
</li><li><span class="nv">things</span>.<span class="nv">append</span>(<span class="nv">optionalNumber</span>)        <span class="c">// Warning</span>
</li><li><span class="nv">things</span>.<span class="nv">append</span>(<span class="nv">optionalNumber</span> <span class="k">as</span> <span class="k">Any</span>) <span class="c">// No warning</span>
</li></ol></div></div></div>
</div>
</div>
</div><div class="section" id="nested-types">
<h1>Nested Types<a class="headerlink" href="NestedTypes.html#nested-types" title="Permalink to this headline">¶</a></h1>
<p>Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define <em>nested types</em>, whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.</p>
<p>To nest a type within another type, write its definition within the outer braces of the type it supports. Types can be nested to as many levels as are required.</p>
<div class="section" id="ID243">
<h2>Nested Types in Action<a class="headerlink" href="NestedTypes.html#ID243" title="Permalink to this headline">¶</a></h2>
<p>The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">BlackjackCard</span></code>, which models a playing card as used in the game of Blackjack. The <code class="docutils literal notranslate"><span class="pre">BlackjackCard</span></code> structure contains two nested enumeration types called <code class="docutils literal notranslate"><span class="pre">Suit</span></code> and <code class="docutils literal notranslate"><span class="pre">Rank</span></code>.</p>
<p>In Blackjack, the Ace cards have a value of either one or eleven. This feature is represented by a structure called <code class="docutils literal notranslate"><span class="pre">Values</span></code>, which is nested within the <code class="docutils literal notranslate"><span class="pre">Rank</span></code> enumeration:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">BlackjackCard</span> {
</li><li>
</li><li> <span class="c">// nested Suit enumeration</span>
</li><li> <span class="k">enum</span> <span class="nv">Suit</span>: <span class="nc">Character</span> {
</li><li> <span class="k">case</span> <span class="nv">spades</span> = <span class="s">"♠"</span>, <span class="nv">hearts</span> = <span class="s">"♡"</span>, <span class="nv">diamonds</span> = <span class="s">"♢"</span>, <span class="nv">clubs</span> = <span class="s">"♣"</span>
</li><li>    }
</li><li>
</li><li> <span class="c">// nested Rank enumeration</span>
</li><li> <span class="k">enum</span> <span class="nv">Rank</span>: <span class="nc">Int</span> {
</li><li> <span class="k">case</span> <span class="nv">two</span> = <span class="m">2</span>, <span class="nv">three</span>, <span class="nv">four</span>, <span class="nv">five</span>, <span class="nv">six</span>, <span class="nv">seven</span>, <span class="nv">eight</span>, <span class="nv">nine</span>, <span class="nv">ten</span>
</li><li> <span class="k">case</span> <span class="nv">jack</span>, <span class="nv">queen</span>, <span class="nv">king</span>, <span class="nv">ace</span>
</li><li> <span class="k">struct</span> <span class="nv">Values</span> {
</li><li> <span class="k">let</span> <span class="nv">first</span>: <span class="nc">Int</span>, <span class="nv">second</span>: <span class="nc">Int</span>?
</li><li>        }
</li><li> <span class="k">var</span> <span class="nv">values</span>: <span class="nc">Values</span> {
</li><li> <span class="k">switch</span> <span class="k">self</span> {
</li><li> <span class="k">case</span> .<span class="nv">ace</span>:
</li><li> <span class="k">return</span> <span class="nv">Values</span>(<span class="nv">first</span>: <span class="m">1</span>, <span class="nv">second</span>: <span class="m">11</span>)
</li><li> <span class="k">case</span> .<span class="nv">jack</span>, .<span class="nv">queen</span>, .<span class="nv">king</span>:
</li><li> <span class="k">return</span> <span class="nv">Values</span>(<span class="nv">first</span>: <span class="m">10</span>, <span class="nv">second</span>: <span class="k">nil</span>)
</li><li> <span class="k">default</span>:
</li><li> <span class="k">return</span> <span class="nv">Values</span>(<span class="nv">first</span>: <span class="k">self</span>.<span class="nv">rawValue</span>, <span class="nv">second</span>: <span class="k">nil</span>)
</li><li>            }
</li><li>        }
</li><li>    }
</li><li>
</li><li> <span class="c">// BlackjackCard properties and methods</span>
</li><li> <span class="k">let</span> <span class="nv">rank</span>: <span class="nc">Rank</span>, <span class="nv">suit</span>: <span class="nc">Suit</span>
</li><li> <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li><li> <span class="k">var</span> <span class="nv">output</span> = <span class="s">"suit is </span>\<span class="p">(</span><span class="nv">suit</span>.<span class="nv">rawValue</span><span class="p">)</span><span class="s">,"</span>
</li><li> <span class="nv">output</span> += <span class="s">" value is </span>\<span class="p">(</span><span class="nv">rank</span>.<span class="nv">values</span>.<span class="nv">first</span><span class="p">)</span><span class="s">"</span>
</li><li> <span class="k">if</span> <span class="k">let</span> <span class="nv">second</span> = <span class="nv">rank</span>.<span class="nv">values</span>.<span class="nv">second</span> {
</li><li> <span class="nv">output</span> += <span class="s">" or </span>\<span class="p">(</span><span class="nv">second</span><span class="p">)</span><span class="s">"</span>
</li><li>        }
</li><li> <span class="k">return</span> <span class="nv">output</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Suit</span></code> enumeration describes the four common playing card suits, together with a raw <code class="docutils literal notranslate"><span class="pre">Character</span></code> value to represent their symbol.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Rank</span></code> enumeration describes the thirteen possible playing card ranks, together with a raw <code class="docutils literal notranslate"><span class="pre">Int</span></code> value to represent their face value. (This raw <code class="docutils literal notranslate"><span class="pre">Int</span></code> value is not used for the Jack, Queen, King, and Ace cards.)</p>
<p>As mentioned above, the <code class="docutils literal notranslate"><span class="pre">Rank</span></code> enumeration defines a further nested structure of its own, called <code class="docutils literal notranslate"><span class="pre">Values</span></code>. This structure encapsulates the fact that most cards have one value, but the Ace card has two values. The <code class="docutils literal notranslate"><span class="pre">Values</span></code> structure defines two properties to represent this:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>, of type <code class="docutils literal notranslate"><span class="pre">Int</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">second</span></code>, of type <code class="docutils literal notranslate"><span class="pre">Int?</span></code>, or “optional <code class="docutils literal notranslate"><span class="pre">Int</span></code>”</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Rank</span></code> also defines a computed property, <code class="docutils literal notranslate"><span class="pre">values</span></code>, which returns an instance of the <code class="docutils literal notranslate"><span class="pre">Values</span></code> structure. This computed property considers the rank of the card and initializes a new <code class="docutils literal notranslate"><span class="pre">Values</span></code> instance with appropriate values based on its rank. It uses special values for <code class="docutils literal notranslate"><span class="pre">jack</span></code>, <code class="docutils literal notranslate"><span class="pre">queen</span></code>, <code class="docutils literal notranslate"><span class="pre">king</span></code>, and <code class="docutils literal notranslate"><span class="pre">ace</span></code>. For the numeric cards, it uses the rank’s raw <code class="docutils literal notranslate"><span class="pre">Int</span></code> value.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">BlackjackCard</span></code> structure itself has two properties—<code class="docutils literal notranslate"><span class="pre">rank</span></code> and <code class="docutils literal notranslate"><span class="pre">suit</span></code>. It also defines a computed property called <code class="docutils literal notranslate"><span class="pre">description</span></code>, which uses the values stored in <code class="docutils literal notranslate"><span class="pre">rank</span></code> and <code class="docutils literal notranslate"><span class="pre">suit</span></code> to build a description of the name and value of the card. The <code class="docutils literal notranslate"><span class="pre">description</span></code> property uses optional binding to check whether there is a second value to display, and if so, inserts additional description detail for that second value.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">BlackjackCard</span></code> is a structure with no custom initializers, it has an implicit memberwise initializer, as described in <a class="reference internal" href="Initialization.html#ID214"><span class="std std-ref">Memberwise Initializers for Structure Types</span></a>. You can use this initializer to initialize a new constant called <code class="docutils literal notranslate"><span class="pre">theAceOfSpades</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">theAceOfSpades</span> = <span class="nv">BlackjackCard</span>(<span class="nv">rank</span>: .<span class="nv">ace</span>, <span class="nv">suit</span>: .<span class="nv">spades</span>)
</li><li><span class="nv">print</span>(<span class="s">"theAceOfSpades: </span>\<span class="p">(</span><span class="nv">theAceOfSpades</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "theAceOfSpades: suit is ♠, value is 1 or 11"</span>
</li></ol></div></div></div>
<p>Even though <code class="docutils literal notranslate"><span class="pre">Rank</span></code> and <code class="docutils literal notranslate"><span class="pre">Suit</span></code> are nested within <code class="docutils literal notranslate"><span class="pre">BlackjackCard</span></code>, their type can be inferred from context, and so the initialization of this instance is able to refer to the enumeration cases by their case names (<code class="docutils literal notranslate"><span class="pre">.ace</span></code> and <code class="docutils literal notranslate"><span class="pre">.spades</span></code>) alone. In the example above, the <code class="docutils literal notranslate"><span class="pre">description</span></code> property correctly reports that the Ace of Spades has a value of <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">11</span></code>.</p>
</div>
<div class="section" id="ID244">
<h2>Referring to Nested Types<a class="headerlink" href="NestedTypes.html#ID244" title="Permalink to this headline">¶</a></h2>
<p>To use a nested type outside of its definition context, prefix its name with the name of the type it is nested within:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">heartsSymbol</span> = <span class="nv">BlackjackCard</span>.<span class="nv">Suit</span>.<span class="nv">hearts</span>.<span class="nv">rawValue</span>
</li><li><span class="c">// heartsSymbol is "♡"</span>
</li></ol></div></div></div>
<p>For the example above, this enables the names of <code class="docutils literal notranslate"><span class="pre">Suit</span></code>, <code class="docutils literal notranslate"><span class="pre">Rank</span></code>, and <code class="docutils literal notranslate"><span class="pre">Values</span></code> to be kept deliberately short, because their names are naturally qualified by the context in which they are defined.</p>
</div>
</div><div class="section" id="extensions">
<h1>Extensions<a class="headerlink" href="Extensions.html#extensions" title="Permalink to this headline">¶</a></h1>
<p><em>Extensions</em> add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you do not have access to the original source code (known as <em>retroactive modeling</em>). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions do not have names.)</p>
<p>Extensions in Swift can:</p>
<ul class="simple">
<li>Add computed instance properties and computed type properties</li>
<li>Define instance methods and type methods</li>
<li>Provide new initializers</li>
<li>Define subscripts</li>
<li>Define and use new nested types</li>
<li>Make an existing type conform to a protocol</li>
</ul>
<p>In Swift, you can even extend a protocol to provide implementations of its requirements or add additional functionality that conforming types can take advantage of. For more details, see <a class="reference internal" href="Protocols.html#ID521"><span class="std std-ref">Protocol Extensions</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Extensions can add new functionality to a type, but they cannot override existing functionality.</p>
</div>
<div class="section" id="ID470">
<h2>Extension Syntax<a class="headerlink" href="Extensions.html#ID470" title="Permalink to this headline">¶</a></h2>
<p>Declare extensions with the <code class="docutils literal notranslate"><span class="pre">extension</span></code> keyword:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">SomeType</span> {
</li><li> <span class="c">// new functionality to add to SomeType goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>An extension can extend an existing type to make it adopt one or more protocols. To add protocol conformance, you write the protocol names the same way as you write them for a class or structure:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">SomeType</span>: <span class="nc">SomeProtocol</span>, <span class="nc">AnotherProtocol</span> {
</li><li> <span class="c">// implementation of protocol requirements goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>Adding protocol conformance in this way is described in <a class="reference internal" href="Protocols.html#ID277"><span class="std std-ref">Adding Protocol Conformance with an Extension</span></a>.</p>
<p>An extension can be used to extend an existing generic type, as described in <a class="reference internal" href="Generics.html#ID185"><span class="std std-ref">Extending a Generic Type</span></a>. You can also extend a generic type to conditionally add functionality, as described in <a class="reference internal" href="Generics.html#ID553"><span class="std std-ref">Extensions with a Generic Where Clause</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.</p>
</div>
</div>
<div class="section" id="ID152">
<h2>Computed Properties<a class="headerlink" href="Extensions.html#ID152" title="Permalink to this headline">¶</a></h2>
<p>Extensions can add computed instance properties and computed type properties to existing types. This example adds five computed instance properties to Swift’s built-in <code class="docutils literal notranslate"><span class="pre">Double</span></code> type, to provide basic support for working with distance units:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Double</span> {
</li><li> <span class="k">var</span> <span class="nv">km</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> * <span class="m">1_000.0</span> }
</li><li> <span class="k">var</span> <span class="nv">m</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> }
</li><li> <span class="k">var</span> <span class="nv">cm</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> / <span class="m">100.0</span> }
</li><li> <span class="k">var</span> <span class="nv">mm</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> / <span class="m">1_000.0</span> }
</li><li> <span class="k">var</span> <span class="nv">ft</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> / <span class="m">3.28084</span> }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">oneInch</span> = <span class="m">25.4</span>.<span class="nv">mm</span>
</li><li><span class="nv">print</span>(<span class="s">"One inch is </span>\<span class="p">(</span><span class="nv">oneInch</span><span class="p">)</span><span class="s"> meters"</span>)
</li><li><span class="c">// Prints "One inch is 0.0254 meters"</span>
</li><li><span class="k">let</span> <span class="nv">threeFeet</span> = <span class="m">3</span>.<span class="nv">ft</span>
</li><li><span class="nv">print</span>(<span class="s">"Three feet is </span>\<span class="p">(</span><span class="nv">threeFeet</span><span class="p">)</span><span class="s"> meters"</span>)
</li><li><span class="c">// Prints "Three feet is 0.914399970739201 meters"</span>
</li></ol></div></div></div>
<p>These computed properties express that a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value should be considered as a certain unit of length. Although they are implemented as computed properties, the names of these properties can be appended to a floating-point literal value with dot syntax, as a way to use that literal value to perform distance conversions.</p>
<p>In this example, a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value of <code class="docutils literal notranslate"><span class="pre">1.0</span></code> is considered to represent “one meter”. This is why the <code class="docutils literal notranslate"><span class="pre">m</span></code> computed property returns <code class="docutils literal notranslate"><span class="pre">self</span></code>—the expression <code class="docutils literal notranslate"><span class="pre">1.m</span></code> is considered to calculate a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value of <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.</p>
<p>Other units require some conversion to be expressed as a value measured in meters. One kilometer is the same as 1,000 meters, so the <code class="docutils literal notranslate"><span class="pre">km</span></code> computed property multiplies the value by <code class="docutils literal notranslate"><span class="pre">1_000.00</span></code> to convert into a number expressed in meters. Similarly, there are 3.28084 feet in a meter, and so the <code class="docutils literal notranslate"><span class="pre">ft</span></code> computed property divides the underlying <code class="docutils literal notranslate"><span class="pre">Double</span></code> value by <code class="docutils literal notranslate"><span class="pre">3.28084</span></code>, to convert it from feet to meters.</p>
<p>These properties are read-only computed properties, and so they are expressed without the <code class="docutils literal notranslate"><span class="pre">get</span></code> keyword, for brevity. Their return value is of type <code class="docutils literal notranslate"><span class="pre">Double</span></code>, and can be used within mathematical calculations wherever a <code class="docutils literal notranslate"><span class="pre">Double</span></code> is accepted:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">aMarathon</span> = <span class="m">42</span>.<span class="nv">km</span> + <span class="m">195</span>.<span class="nv">m</span>
</li><li><span class="nv">print</span>(<span class="s">"A marathon is </span>\<span class="p">(</span><span class="nv">aMarathon</span><span class="p">)</span><span class="s"> meters long"</span>)
</li><li><span class="c">// Prints "A marathon is 42195.0 meters long"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Extensions can add new computed properties, but they cannot add stored properties, or add property observers to existing properties.</p>
</div>
</div>
<div class="section" id="ID153">
<h2>Initializers<a class="headerlink" href="Extensions.html#ID153" title="Permalink to this headline">¶</a></h2>
<p>Extensions can add new initializers to existing types. This enables you to extend other types to accept your own custom types as initializer parameters, or to provide additional initialization options that were not included as part of the type’s original implementation.</p>
<p>Extensions can add new convenience initializers to a class, but they cannot add new designated initializers or deinitializers to a class. Designated initializers and deinitializers must always be provided by the original class implementation.</p>
<p>If you use an extension to add an initializer to a value type that provides default values for all of its stored properties and does not define any custom initializers, you can call the default initializer and memberwise initializer for that value type from within your extension’s initializer. This wouldn’t be the case if you had written the initializer as part of the value type’s original implementation, as described in <a class="reference internal" href="Initialization.html#ID215"><span class="std std-ref">Initializer Delegation for Value Types</span></a>.</p>
<p>If you use an extension to add an initializer to a structure that was declared in another module, the new initializer can’t access <code class="docutils literal notranslate"><span class="pre">self</span></code> until it calls an initializer from the defining module.</p>
<p>The example below defines a custom <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure to represent a geometric rectangle. The example also defines two supporting structures called <code class="docutils literal notranslate"><span class="pre">Size</span></code> and <code class="docutils literal notranslate"><span class="pre">Point</span></code>, both of which provide default values of <code class="docutils literal notranslate"><span class="pre">0.0</span></code> for all of their properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Size</span> {
</li><li> <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li> <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Rect</span> {
</li><li> <span class="k">var</span> <span class="nv">origin</span> = <span class="nv">Point</span>()
</li><li> <span class="k">var</span> <span class="nv">size</span> = <span class="nv">Size</span>()
</li><li>}
</li></ol></div></div></div>
<p>Because the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure provides default values for all of its properties, it receives a default initializer and a memberwise initializer automatically, as described in <a class="reference internal" href="Initialization.html#ID213"><span class="std std-ref">Default Initializers</span></a>. These initializers can be used to create new <code class="docutils literal notranslate"><span class="pre">Rect</span></code> instances:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">defaultRect</span> = <span class="nv">Rect</span>()
</li><li><span class="k">let</span> <span class="nv">memberwiseRect</span> = <span class="nv">Rect</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>),
</li><li> <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">5.0</span>, <span class="nv">height</span>: <span class="m">5.0</span>))
</li></ol></div></div></div>
<p>You can extend the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure to provide an additional initializer that takes a specific center point and size:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Rect</span> {
</li><li> <span class="k">init</span>(<span class="nv">center</span>: <span class="nc">Point</span>, <span class="nv">size</span>: <span class="nc">Size</span>) {
</li><li> <span class="k">let</span> <span class="nv">originX</span> = <span class="nv">center</span>.<span class="nv">x</span> - (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li> <span class="k">let</span> <span class="nv">originY</span> = <span class="nv">center</span>.<span class="nv">y</span> - (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li> <span class="k">self</span>.<span class="nv">init</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">originX</span>, <span class="nv">y</span>: <span class="nv">originY</span>), <span class="nv">size</span>: <span class="nv">size</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This new initializer starts by calculating an appropriate origin point based on the provided <code class="docutils literal notranslate"><span class="pre">center</span></code> point and <code class="docutils literal notranslate"><span class="pre">size</span></code> value. The initializer then calls the structure’s automatic memberwise initializer <code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code>, which stores the new origin and size values in the appropriate properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">centerRect</span> = <span class="nv">Rect</span>(<span class="nv">center</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">4.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>),
</li><li> <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">3.0</span>, <span class="nv">height</span>: <span class="m">3.0</span>))
</li><li><span class="c">// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you provide a new initializer with an extension, you are still responsible for making sure that each instance is fully initialized once the initializer completes.</p>
</div>
</div>
<div class="section" id="ID154">
<h2>Methods<a class="headerlink" href="Extensions.html#ID154" title="Permalink to this headline">¶</a></h2>
<p>Extensions can add new instance methods and type methods to existing types. The following example adds a new instance method called <code class="docutils literal notranslate"><span class="pre">repetitions</span></code> to the <code class="docutils literal notranslate"><span class="pre">Int</span></code> type:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Int</span> {
</li><li> <span class="k">func</span> <span class="nv">repetitions</span>(<span class="nv">task</span>: () -&gt; <span class="nc">Void</span>) {
</li><li> <span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="k">self</span> {
</li><li> <span class="nv">task</span>()
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">repetitions(task:)</span></code> method takes a single argument of type <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code>, which indicates a function that has no parameters and does not return a value.</p>
<p>After defining this extension, you can call the <code class="docutils literal notranslate"><span class="pre">repetitions(task:)</span></code> method on any integer to perform a task that many number of times:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">3</span>.<span class="nv">repetitions</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Hello!"</span>)
</li><li>}
</li><li><span class="c">// Hello!</span>
</li><li><span class="c">// Hello!</span>
</li><li><span class="c">// Hello!</span>
</li></ol></div></div></div>
<div class="section" id="ID155">
<h3>Mutating Instance Methods<a class="headerlink" href="Extensions.html#ID155" title="Permalink to this headline">¶</a></h3>
<p>Instance methods added with an extension can also modify (or <em>mutate</em>) the instance itself. Structure and enumeration methods that modify <code class="docutils literal notranslate"><span class="pre">self</span></code> or its properties must mark the instance method as <code class="docutils literal notranslate"><span class="pre">mutating</span></code>, just like mutating methods from an original implementation.</p>
<p>The example below adds a new mutating method called <code class="docutils literal notranslate"><span class="pre">square</span></code> to Swift’s <code class="docutils literal notranslate"><span class="pre">Int</span></code> type, which squares the original value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Int</span> {
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">square</span>() {
</li><li> <span class="k">self</span> = <span class="k">self</span> * <span class="k">self</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">someInt</span> = <span class="m">3</span>
</li><li><span class="nv">someInt</span>.<span class="nv">square</span>()
</li><li><span class="c">// someInt is now 9</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID156">
<h2>Subscripts<a class="headerlink" href="Extensions.html#ID156" title="Permalink to this headline">¶</a></h2>
<p>Extensions can add new subscripts to an existing type. This example adds an integer subscript to Swift’s built-in <code class="docutils literal notranslate"><span class="pre">Int</span></code> type. This subscript <code class="docutils literal notranslate"><span class="pre">[n]</span></code> returns the decimal digit <code class="docutils literal notranslate"><span class="pre">n</span></code> places in from the right of the number:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">123456789[0]</span></code> returns <code class="docutils literal notranslate"><span class="pre">9</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">123456789[1]</span></code> returns <code class="docutils literal notranslate"><span class="pre">8</span></code></li>
</ul>
<p>…and so on:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Int</span> {
</li><li> <span class="k">subscript</span>(<span class="nv">digitIndex</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">var</span> <span class="nv">decimalBase</span> = <span class="m">1</span>
</li><li> <span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="nv">digitIndex</span> {
</li><li> <span class="nv">decimalBase</span> *= <span class="m">10</span>
</li><li>        }
</li><li> <span class="k">return</span> (<span class="k">self</span> / <span class="nv">decimalBase</span>) % <span class="m">10</span>
</li><li>    }
</li><li>}
</li><li><span class="m">746381295</span>[<span class="m">0</span>]
</li><li><span class="c">// returns 5</span>
</li><li><span class="m">746381295</span>[<span class="m">1</span>]
</li><li><span class="c">// returns 9</span>
</li><li><span class="m">746381295</span>[<span class="m">2</span>]
</li><li><span class="c">// returns 2</span>
</li><li><span class="m">746381295</span>[<span class="m">8</span>]
</li><li><span class="c">// returns 7</span>
</li></ol></div></div></div>
<p>If the <code class="docutils literal notranslate"><span class="pre">Int</span></code> value does not have enough digits for the requested index, the subscript implementation returns <code class="docutils literal notranslate"><span class="pre">0</span></code>, as if the number had been padded with zeros to the left:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">746381295</span>[<span class="m">9</span>]
</li><li><span class="c">// returns 0, as if you had requested:</span>
</li><li><span class="m">0746381295</span>[<span class="m">9</span>]
</li></ol></div></div></div>
</div>
<div class="section" id="ID157">
<h2>Nested Types<a class="headerlink" href="Extensions.html#ID157" title="Permalink to this headline">¶</a></h2>
<p>Extensions can add new nested types to existing classes, structures, and enumerations:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Int</span> {
</li><li> <span class="k">enum</span> <span class="nv">Kind</span> {
</li><li> <span class="k">case</span> <span class="nv">negative</span>, <span class="nv">zero</span>, <span class="nv">positive</span>
</li><li>    }
</li><li> <span class="k">var</span> <span class="nv">kind</span>: <span class="nc">Kind</span> {
</li><li> <span class="k">switch</span> <span class="k">self</span> {
</li><li> <span class="k">case</span> <span class="m">0</span>:
</li><li> <span class="k">return</span> .<span class="nv">zero</span>
</li><li> <span class="k">case</span> <span class="k">let</span> <span class="nv">x</span> <span class="k">where</span> <span class="nv">x</span> &gt; <span class="m">0</span>:
</li><li> <span class="k">return</span> .<span class="nv">positive</span>
</li><li> <span class="k">default</span>:
</li><li> <span class="k">return</span> .<span class="nv">negative</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This example adds a new nested enumeration to <code class="docutils literal notranslate"><span class="pre">Int</span></code>. This enumeration, called <code class="docutils literal notranslate"><span class="pre">Kind</span></code>, expresses the kind of number that a particular integer represents. Specifically, it expresses whether the number is negative, zero, or positive.</p>
<p>This example also adds a new computed instance property to <code class="docutils literal notranslate"><span class="pre">Int</span></code>, called <code class="docutils literal notranslate"><span class="pre">kind</span></code>, which returns the appropriate <code class="docutils literal notranslate"><span class="pre">Kind</span></code> enumeration case for that integer.</p>
<p>The nested enumeration can now be used with any <code class="docutils literal notranslate"><span class="pre">Int</span></code> value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">printIntegerKinds</span>(<span class="k">_</span> <span class="nv">numbers</span>: [<span class="nc">Int</span>]) {
</li><li> <span class="k">for</span> <span class="nv">number</span> <span class="k">in</span> <span class="nv">numbers</span> {
</li><li> <span class="k">switch</span> <span class="nv">number</span>.<span class="nv">kind</span> {
</li><li> <span class="k">case</span> .<span class="nv">negative</span>:
</li><li> <span class="nv">print</span>(<span class="s">"- "</span>, <span class="nv">terminator</span>: <span class="s">""</span>)
</li><li> <span class="k">case</span> .<span class="nv">zero</span>:
</li><li> <span class="nv">print</span>(<span class="s">"0 "</span>, <span class="nv">terminator</span>: <span class="s">""</span>)
</li><li> <span class="k">case</span> .<span class="nv">positive</span>:
</li><li> <span class="nv">print</span>(<span class="s">"+ "</span>, <span class="nv">terminator</span>: <span class="s">""</span>)
</li><li>        }
</li><li>    }
</li><li> <span class="nv">print</span>(<span class="s">""</span>)
</li><li>}
</li><li><span class="nv">printIntegerKinds</span>([<span class="m">3</span>, <span class="m">19</span>, <span class="m">-27</span>, <span class="m">0</span>, <span class="m">-6</span>, <span class="m">0</span>, <span class="m">7</span>])
</li><li><span class="c">// Prints "+ + - 0 - 0 + "</span>
</li></ol></div></div></div>
<p>This function, <code class="docutils literal notranslate"><span class="pre">printIntegerKinds(_:)</span></code>, takes an input array of <code class="docutils literal notranslate"><span class="pre">Int</span></code> values and iterates over those values in turn. For each integer in the array, the function considers the <code class="docutils literal notranslate"><span class="pre">kind</span></code> computed property for that integer, and prints an appropriate description.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">number.kind</span></code> is already known to be of type <code class="docutils literal notranslate"><span class="pre">Int.Kind</span></code>. Because of this, all of the <code class="docutils literal notranslate"><span class="pre">Int.Kind</span></code> case values can be written in shorthand form inside the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement, such as <code class="docutils literal notranslate"><span class="pre">.negative</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Int.Kind.negative</span></code>.</p>
</div>
</div>
</div><div class="section" id="protocols">
<h1>Protocols<a class="headerlink" href="Protocols.html#protocols" title="Permalink to this headline">¶</a></h1>
<p>A <em>protocol</em> defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be <em>adopted</em> by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to <em>conform</em> to that protocol.</p>
<p>In addition to specifying requirements that conforming types must implement, you can extend a protocol to implement some of these requirements or to implement additional functionality that conforming types can take advantage of.</p>
<div class="section" id="ID268">
<h2>Protocol Syntax<a class="headerlink" href="Protocols.html#ID268" title="Permalink to this headline">¶</a></h2>
<p>You define protocols in a very similar way to classes, structures, and enumerations:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li><li> <span class="c">// protocol definition goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>Custom types state that they adopt a particular protocol by placing the protocol’s name after the type’s name, separated by a colon, as part of their definition. Multiple protocols can be listed, and are separated by commas:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">SomeStructure</span>: <span class="nc">FirstProtocol</span>, <span class="nc">AnotherProtocol</span> {
</li><li> <span class="c">// structure definition goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>If a class has a superclass, list the superclass name before any protocols it adopts, followed by a comma:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span>: <span class="nc">SomeSuperclass</span>, <span class="nc">FirstProtocol</span>, <span class="nc">AnotherProtocol</span> {
</li><li> <span class="c">// class definition goes here</span>
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID269">
<h2>Property Requirements<a class="headerlink" href="Protocols.html#ID269" title="Permalink to this headline">¶</a></h2>
<p>A protocol can require any conforming type to provide an instance property or type property with a particular name and type. The protocol doesn’t specify whether the property should be a stored property or a computed property—it only specifies the required property name and type. The protocol also specifies whether each property must be gettable or gettable <em>and</em> settable.</p>
<p>If a protocol requires a property to be gettable and settable, that property requirement can’t be fulfilled by a constant stored property or a read-only computed property. If the protocol only requires a property to be gettable, the requirement can be satisfied by any kind of property, and it’s valid for the property to be also settable if this is useful for your own code.</p>
<p>Property requirements are always declared as variable properties, prefixed with the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword. Gettable and settable properties are indicated by writing <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">get</span> <span class="pre">set</span> <span class="pre">}</span></code> after their type declaration, and gettable properties are indicated by writing <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">get</span> <span class="pre">}</span></code>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li><li> <span class="k">var</span> <span class="nv">mustBeSettable</span>: <span class="nc">Int</span> { <span class="k">get</span> <span class="k">set</span> }
</li><li> <span class="k">var</span> <span class="nv">doesNotNeedToBeSettable</span>: <span class="nc">Int</span> { <span class="k">get</span> }
</li><li>}
</li></ol></div></div></div>
<p>Always prefix type property requirements with the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword when you define them in a protocol. This rule pertains even though type property requirements can be prefixed with the <code class="docutils literal notranslate"><span class="pre">class</span></code> or <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword when implemented by a class:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">AnotherProtocol</span> {
</li><li> <span class="k">static</span> <span class="k">var</span> <span class="nv">someTypeProperty</span>: <span class="nc">Int</span> { <span class="k">get</span> <span class="k">set</span> }
</li><li>}
</li></ol></div></div></div>
<p>Here’s an example of a protocol with a single instance property requirement:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">FullyNamed</span> {
</li><li> <span class="k">var</span> <span class="nv">fullName</span>: <span class="nc">String</span> { <span class="k">get</span> }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> protocol requires a conforming type to provide a fully-qualified name. The protocol doesn’t specify anything else about the nature of the conforming type—it only specifies that the type must be able to provide a full name for itself. The protocol states that any <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> type must have a gettable instance property called <code class="docutils literal notranslate"><span class="pre">fullName</span></code>, which is of type <code class="docutils literal notranslate"><span class="pre">String</span></code>.</p>
<p>Here’s an example of a simple structure that adopts and conforms to the <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Person</span>: <span class="nc">FullyNamed</span> {
</li><li> <span class="k">var</span> <span class="nv">fullName</span>: <span class="nc">String</span>
</li><li>}
</li><li><span class="k">let</span> <span class="nv">john</span> = <span class="nv">Person</span>(<span class="nv">fullName</span>: <span class="s">"John Appleseed"</span>)
</li><li><span class="c">// john.fullName is "John Appleseed"</span>
</li></ol></div></div></div>
<p>This example defines a structure called <code class="docutils literal notranslate"><span class="pre">Person</span></code>, which represents a specific named person. It states that it adopts the <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> protocol as part of the first line of its definition.</p>
<p>Each instance of <code class="docutils literal notranslate"><span class="pre">Person</span></code> has a single stored property called <code class="docutils literal notranslate"><span class="pre">fullName</span></code>, which is of type <code class="docutils literal notranslate"><span class="pre">String</span></code>. This matches the single requirement of the <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> protocol, and means that <code class="docutils literal notranslate"><span class="pre">Person</span></code> has correctly conformed to the protocol. (Swift reports an error at compile-time if a protocol requirement is not fulfilled.)</p>
<p>Here’s a more complex class, which also adopts and conforms to the <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Starship</span>: <span class="nc">FullyNamed</span> {
</li><li> <span class="k">var</span> <span class="nv">prefix</span>: <span class="nc">String</span>?
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">prefix</span>: <span class="nc">String</span>? = <span class="k">nil</span>) {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li> <span class="k">self</span>.<span class="nv">prefix</span> = <span class="nv">prefix</span>
</li><li>    }
</li><li> <span class="k">var</span> <span class="nv">fullName</span>: <span class="nc">String</span> {
</li><li> <span class="k">return</span> (<span class="nv">prefix</span> != <span class="k">nil</span> ? <span class="nv">prefix</span>! + <span class="s">" "</span> : <span class="s">""</span>) + <span class="nv">name</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">ncc1701</span> = <span class="nv">Starship</span>(<span class="nv">name</span>: <span class="s">"Enterprise"</span>, <span class="nv">prefix</span>: <span class="s">"USS"</span>)
</li><li><span class="c">// ncc1701.fullName is "USS Enterprise"</span>
</li></ol></div></div></div>
<p>This class implements the <code class="docutils literal notranslate"><span class="pre">fullName</span></code> property requirement as a computed read-only property for a starship. Each <code class="docutils literal notranslate"><span class="pre">Starship</span></code> class instance stores a mandatory <code class="docutils literal notranslate"><span class="pre">name</span></code> and an optional <code class="docutils literal notranslate"><span class="pre">prefix</span></code>. The <code class="docutils literal notranslate"><span class="pre">fullName</span></code> property uses the <code class="docutils literal notranslate"><span class="pre">prefix</span></code> value if it exists, and prepends it to the beginning of <code class="docutils literal notranslate"><span class="pre">name</span></code> to create a full name for the starship.</p>
</div>
<div class="section" id="ID270">
<h2>Method Requirements<a class="headerlink" href="Protocols.html#ID270" title="Permalink to this headline">¶</a></h2>
<p>Protocols can require specific instance methods and type methods to be implemented by conforming types. These methods are written as part of the protocol’s definition in exactly the same way as for normal instance and type methods, but without curly braces or a method body. Variadic parameters are allowed, subject to the same rules as for normal methods. Default values, however, can’t be specified for method parameters within a protocol’s definition.</p>
<p>As with type property requirements, you always prefix type method requirements with the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword when they’re defined in a protocol. This is true even though type method requirements are prefixed with the <code class="docutils literal notranslate"><span class="pre">class</span></code> or <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword when implemented by a class:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li><li> <span class="k">static</span> <span class="k">func</span> <span class="nv">someTypeMethod</span>()
</li><li>}
</li></ol></div></div></div>
<p>The following example defines a protocol with a single instance method requirement:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">RandomNumberGenerator</span> {
</li><li> <span class="k">func</span> <span class="nv">random</span>() -&gt; <span class="nc">Double</span>
</li><li>}
</li></ol></div></div></div>
<p>This protocol, <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>, requires any conforming type to have an instance method called <code class="docutils literal notranslate"><span class="pre">random</span></code>, which returns a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value whenever it’s called. Although it’s not specified as part of the protocol, it’s assumed that this value will be a number from <code class="docutils literal notranslate"><span class="pre">0.0</span></code> up to (but not including) <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code> protocol doesn’t make any assumptions about how each random number will be generated—it simply requires the generator to provide a standard way to generate a new random number.</p>
<p>Here’s an implementation of a class that adopts and conforms to the <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code> protocol. This class implements a pseudorandom number generator algorithm known as a <em>linear congruential generator</em>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">LinearCongruentialGenerator</span>: <span class="nc">RandomNumberGenerator</span> {
</li><li> <span class="k">var</span> <span class="nv">lastRandom</span> = <span class="m">42.0</span>
</li><li> <span class="k">let</span> <span class="nv">m</span> = <span class="m">139968.0</span>
</li><li> <span class="k">let</span> <span class="nv">a</span> = <span class="m">3877.0</span>
</li><li> <span class="k">let</span> <span class="nv">c</span> = <span class="m">29573.0</span>
</li><li> <span class="k">func</span> <span class="nv">random</span>() -&gt; <span class="nc">Double</span> {
</li><li> <span class="nv">lastRandom</span> = ((<span class="nv">lastRandom</span> * <span class="nv">a</span> + <span class="nv">c</span>).<span class="nv">truncatingRemainder</span>(<span class="nv">dividingBy</span>:<span class="nv">m</span>))
</li><li> <span class="k">return</span> <span class="nv">lastRandom</span> / <span class="nv">m</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">generator</span> = <span class="nv">LinearCongruentialGenerator</span>()
</li><li><span class="nv">print</span>(<span class="s">"Here's a random number: </span>\<span class="p">(</span><span class="nv">generator</span>.<span class="nv">random</span>()<span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "Here's a random number: 0.3746499199817101"</span>
</li><li><span class="nv">print</span>(<span class="s">"And another one: </span>\<span class="p">(</span><span class="nv">generator</span>.<span class="nv">random</span>()<span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "And another one: 0.729023776863283"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID271">
<h2>Mutating Method Requirements<a class="headerlink" href="Protocols.html#ID271" title="Permalink to this headline">¶</a></h2>
<p>It’s sometimes necessary for a method to modify (or <em>mutate</em>) the instance it belongs to. For instance methods on value types (that is, structures and enumerations) you place the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword before a method’s <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword to indicate that the method is allowed to modify the instance it belongs to and any properties of that instance. This process is described in <a class="reference internal" href="Methods.html#ID239"><span class="std std-ref">Modifying Value Types from Within Instance Methods</span></a>.</p>
<p>If you define a protocol instance method requirement that is intended to mutate instances of any type that adopts the protocol, mark the method with the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword as part of the protocol’s definition. This enables structures and enumerations to adopt the protocol and satisfy that method requirement.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you mark a protocol instance method requirement as <code class="docutils literal notranslate"><span class="pre">mutating</span></code>, you don’t need to write the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword when writing an implementation of that method for a class. The <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword is only used by structures and enumerations.</p>
</div>
<p>The example below defines a protocol called <code class="docutils literal notranslate"><span class="pre">Togglable</span></code>, which defines a single instance method requirement called <code class="docutils literal notranslate"><span class="pre">toggle</span></code>. As its name suggests, the <code class="docutils literal notranslate"><span class="pre">toggle()</span></code> method is intended to toggle or invert the state of any conforming type, typically by modifying a property of that type.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">toggle()</span></code> method is marked with the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword as part of the <code class="docutils literal notranslate"><span class="pre">Togglable</span></code> protocol definition, to indicate that the method is expected to mutate the state of a conforming instance when it’s called:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Togglable</span> {
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">toggle</span>()
</li><li>}
</li></ol></div></div></div>
<p>If you implement the <code class="docutils literal notranslate"><span class="pre">Togglable</span></code> protocol for a structure or enumeration, that structure or enumeration can conform to the protocol by providing an implementation of the <code class="docutils literal notranslate"><span class="pre">toggle()</span></code> method that is also marked as <code class="docutils literal notranslate"><span class="pre">mutating</span></code>.</p>
<p>The example below defines an enumeration called <code class="docutils literal notranslate"><span class="pre">OnOffSwitch</span></code>. This enumeration toggles between two states, indicated by the enumeration cases <code class="docutils literal notranslate"><span class="pre">on</span></code> and <code class="docutils literal notranslate"><span class="pre">off</span></code>. The enumeration’s <code class="docutils literal notranslate"><span class="pre">toggle</span></code> implementation is marked as <code class="docutils literal notranslate"><span class="pre">mutating</span></code>, to match the <code class="docutils literal notranslate"><span class="pre">Togglable</span></code> protocol’s requirements:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">OnOffSwitch</span>: <span class="nc">Togglable</span> {
</li><li> <span class="k">case</span> <span class="nv">off</span>, <span class="nv">on</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">toggle</span>() {
</li><li> <span class="k">switch</span> <span class="k">self</span> {
</li><li> <span class="k">case</span> .<span class="nv">off</span>:
</li><li> <span class="k">self</span> = .<span class="nv">on</span>
</li><li> <span class="k">case</span> .<span class="nv">on</span>:
</li><li> <span class="k">self</span> = .<span class="nv">off</span>
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">lightSwitch</span> = <span class="nv">OnOffSwitch</span>.<span class="nv">off</span>
</li><li><span class="nv">lightSwitch</span>.<span class="nv">toggle</span>()
</li><li><span class="c">// lightSwitch is now equal to .on</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID272">
<h2>Initializer Requirements<a class="headerlink" href="Protocols.html#ID272" title="Permalink to this headline">¶</a></h2>
<p>Protocols can require specific initializers to be implemented by conforming types. You write these initializers as part of the protocol’s definition in exactly the same way as for normal initializers, but without curly braces or an initializer body:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li><li> <span class="k">init</span>(<span class="nv">someParameter</span>: <span class="nc">Int</span>)
</li><li>}
</li></ol></div></div></div>
<div class="section" id="ID273">
<h3>Class Implementations of Protocol Initializer Requirements<a class="headerlink" href="Protocols.html#ID273" title="Permalink to this headline">¶</a></h3>
<p>You can implement a protocol initializer requirement on a conforming class as either a designated initializer or a convenience initializer. In both cases, you must mark the initializer implementation with the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span>: <span class="nc">SomeProtocol</span> {
</li><li> <span class="k">required</span> <span class="k">init</span>(<span class="nv">someParameter</span>: <span class="nc">Int</span>) {
</li><li> <span class="c">// initializer implementation goes here</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The use of the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier ensures that you provide an explicit or inherited implementation of the initializer requirement on all subclasses of the conforming class, such that they also conform to the protocol.</p>
<p>For more information on required initializers, see <a class="reference internal" href="Initialization.html#ID231"><span class="std std-ref">Required Initializers</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You don’t need to mark protocol initializer implementations with the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier on classes that are marked with the <code class="docutils literal notranslate"><span class="pre">final</span></code> modifier, because final classes can’t subclassed. For more about the <code class="docutils literal notranslate"><span class="pre">final</span></code> modifier, see <a class="reference internal" href="Inheritance.html#ID202"><span class="std std-ref">Preventing Overrides</span></a>.</p>
</div>
<p>If a subclass overrides a designated initializer from a superclass, and also implements a matching initializer requirement from a protocol, mark the initializer implementation with both the <code class="docutils literal notranslate"><span class="pre">required</span></code> and <code class="docutils literal notranslate"><span class="pre">override</span></code> modifiers:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li><li> <span class="k">init</span>()
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">SomeSuperClass</span> {
</li><li> <span class="k">init</span>() {
</li><li> <span class="c">// initializer implementation goes here</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">SomeSubClass</span>: <span class="nc">SomeSuperClass</span>, <span class="nc">SomeProtocol</span> {
</li><li> <span class="c">// "required" from SomeProtocol conformance; "override" from SomeSuperClass</span>
</li><li> <span class="k">required</span> <span class="k">override</span> <span class="k">init</span>() {
</li><li> <span class="c">// initializer implementation goes here</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID274">
<h3>Failable Initializer Requirements<a class="headerlink" href="Protocols.html#ID274" title="Permalink to this headline">¶</a></h3>
<p>Protocols can define failable initializer requirements for conforming types, as defined in <a class="reference internal" href="Initialization.html#ID224"><span class="std std-ref">Failable Initializers</span></a>.</p>
<p>A failable initializer requirement can be satisfied by a failable or nonfailable initializer on a conforming type. A nonfailable initializer requirement can be satisfied by a nonfailable initializer or an implicitly unwrapped failable initializer.</p>
</div>
</div>
<div class="section" id="ID275">
<h2>Protocols as Types<a class="headerlink" href="Protocols.html#ID275" title="Permalink to this headline">¶</a></h2>
<p>Protocols don’t actually implement any functionality themselves. Nonetheless, any protocol you create will become a fully-fledged type for use in your code.</p>
<p>Because it’s a type, you can use a protocol in many places where other types are allowed, including:</p>
<ul class="simple">
<li>As a parameter type or return type in a function, method, or initializer</li>
<li>As the type of a constant, variable, or property</li>
<li>As the type of items in an array, dictionary, or other container</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because protocols are types, begin their names with a capital letter (such as <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> and <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>) to match the names of other types in Swift (such as <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">String</span></code>, and <code class="docutils literal notranslate"><span class="pre">Double</span></code>).</p>
</div>
<p>Here’s an example of a protocol used as a type:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Dice</span> {
</li><li> <span class="k">let</span> <span class="nv">sides</span>: <span class="nc">Int</span>
</li><li> <span class="k">let</span> <span class="nv">generator</span>: <span class="nc">RandomNumberGenerator</span>
</li><li> <span class="k">init</span>(<span class="nv">sides</span>: <span class="nc">Int</span>, <span class="nv">generator</span>: <span class="nc">RandomNumberGenerator</span>) {
</li><li> <span class="k">self</span>.<span class="nv">sides</span> = <span class="nv">sides</span>
</li><li> <span class="k">self</span>.<span class="nv">generator</span> = <span class="nv">generator</span>
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">roll</span>() -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">Int</span>(<span class="nv">generator</span>.<span class="nv">random</span>() * <span class="nv">Double</span>(<span class="nv">sides</span>)) + <span class="m">1</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This example defines a new class called <code class="docutils literal notranslate"><span class="pre">Dice</span></code>, which represents an <em>n</em>-sided dice for use in a board game. <code class="docutils literal notranslate"><span class="pre">Dice</span></code> instances have an integer property called <code class="docutils literal notranslate"><span class="pre">sides</span></code>, which represents how many sides they have, and a property called <code class="docutils literal notranslate"><span class="pre">generator</span></code>, which provides a random number generator from which to create dice roll values.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">generator</span></code> property is of type <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>. Therefore, you can set it to an instance of <em>any</em> type that adopts the <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code> protocol. Nothing else is required of the instance you assign to this property, except that the instance must adopt the <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code> protocol.</p>
<p><code class="docutils literal notranslate"><span class="pre">Dice</span></code> also has an initializer, to set up its initial state. This initializer has a parameter called <code class="docutils literal notranslate"><span class="pre">generator</span></code>, which is also of type <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>. You can pass a value of any conforming type in to this parameter when initializing a new <code class="docutils literal notranslate"><span class="pre">Dice</span></code> instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">Dice</span></code> provides one instance method, <code class="docutils literal notranslate"><span class="pre">roll</span></code>, which returns an integer value between 1 and the number of sides on the dice. This method calls the generator’s <code class="docutils literal notranslate"><span class="pre">random()</span></code> method to create a new random number between <code class="docutils literal notranslate"><span class="pre">0.0</span></code> and <code class="docutils literal notranslate"><span class="pre">1.0</span></code>, and uses this random number to create a dice roll value within the correct range. Because <code class="docutils literal notranslate"><span class="pre">generator</span></code> is known to adopt <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>, it’s guaranteed to have a <code class="docutils literal notranslate"><span class="pre">random()</span></code> method to call.</p>
<p>Here’s how the <code class="docutils literal notranslate"><span class="pre">Dice</span></code> class can be used to create a six-sided dice with a <code class="docutils literal notranslate"><span class="pre">LinearCongruentialGenerator</span></code> instance as its random number generator:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">d6</span> = <span class="nv">Dice</span>(<span class="nv">sides</span>: <span class="m">6</span>, <span class="nv">generator</span>: <span class="nv">LinearCongruentialGenerator</span>())
</li><li><span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">5</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Random dice roll is </span>\<span class="p">(</span><span class="nv">d6</span>.<span class="nv">roll</span>()<span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Random dice roll is 3</span>
</li><li><span class="c">// Random dice roll is 5</span>
</li><li><span class="c">// Random dice roll is 4</span>
</li><li><span class="c">// Random dice roll is 5</span>
</li><li><span class="c">// Random dice roll is 4</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID276">
<h2>Delegation<a class="headerlink" href="Protocols.html#ID276" title="Permalink to this headline">¶</a></h2>
<p><em>Delegation</em> is a design pattern that enables a class or structure to hand off (or <em>delegate</em>) some of its responsibilities to an instance of another type. This design pattern is implemented by defining a protocol that encapsulates the delegated responsibilities, such that a conforming type (known as a delegate) is guaranteed to provide the functionality that has been delegated. Delegation can be used to respond to a particular action, or to retrieve data from an external source without needing to know the underlying type of that source.</p>
<p>The example below defines two protocols for use with dice-based board games:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">DiceGame</span> {
</li><li> <span class="k">var</span> <span class="nv">dice</span>: <span class="nc">Dice</span> { <span class="k">get</span> }
</li><li> <span class="k">func</span> <span class="nv">play</span>()
</li><li>}
</li><li><span class="k">protocol</span> <span class="nv">DiceGameDelegate</span>: <span class="nc">AnyObject</span> {
</li><li> <span class="k">func</span> <span class="nv">gameDidStart</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>)
</li><li> <span class="k">func</span> <span class="nv">game</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>, <span class="nv">didStartNewTurnWithDiceRoll</span> <span class="nv">diceRoll</span>: <span class="nc">Int</span>)
</li><li> <span class="k">func</span> <span class="nv">gameDidEnd</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>)
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code> protocol is a protocol that can be adopted by any game that involves dice.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code> protocol can be adopted to track the progress of a <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>. To prevent strong reference cycles, delegates are declared as weak references. For information about weak references, see <a class="reference internal" href="AutomaticReferenceCounting.html#ID51"><span class="std std-ref">Strong Reference Cycles Between Class Instances</span></a>. Marking the protocol as class-only lets the <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> class later in this chapter declare that its delegate must use a weak reference. A class-only protocol is marked by its inheritance from <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code> as discussed in <a class="reference internal" href="Protocols.html#ID281"><span class="std std-ref">Class-Only Protocols</span></a>.</p>
<p>Here’s a version of the <em>Snakes and Ladders</em> game originally introduced in <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>. This version is adapted to use a <code class="docutils literal notranslate"><span class="pre">Dice</span></code> instance for its dice-rolls; to adopt the <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code> protocol; and to notify a <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code> about its progress:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SnakesAndLadders</span>: <span class="nc">DiceGame</span> {
</li><li> <span class="k">let</span> <span class="nv">finalSquare</span> = <span class="m">25</span>
</li><li> <span class="k">let</span> <span class="nv">dice</span> = <span class="nv">Dice</span>(<span class="nv">sides</span>: <span class="m">6</span>, <span class="nv">generator</span>: <span class="nv">LinearCongruentialGenerator</span>())
</li><li> <span class="k">var</span> <span class="nv">square</span> = <span class="m">0</span>
</li><li> <span class="k">var</span> <span class="nv">board</span>: [<span class="nc">Int</span>]
</li><li> <span class="k">init</span>() {
</li><li> <span class="nv">board</span> = <span class="nv">Array</span>(<span class="nv">repeating</span>: <span class="m">0</span>, <span class="nv">count</span>: <span class="nv">finalSquare</span> + <span class="m">1</span>)
</li><li> <span class="nv">board</span>[<span class="m">03</span>] = +<span class="m">08</span>; <span class="nv">board</span>[<span class="m">06</span>] = +<span class="m">11</span>; <span class="nv">board</span>[<span class="m">09</span>] = +<span class="m">09</span>; <span class="nv">board</span>[<span class="m">10</span>] = +<span class="m">02</span>
</li><li> <span class="nv">board</span>[<span class="m">14</span>] = <span class="m">-10</span>; <span class="nv">board</span>[<span class="m">19</span>] = <span class="m">-11</span>; <span class="nv">board</span>[<span class="m">22</span>] = <span class="m">-02</span>; <span class="nv">board</span>[<span class="m">24</span>] = <span class="m">-08</span>
</li><li>    }
</li><li> <span class="k">weak</span> <span class="k">var</span> <span class="nv">delegate</span>: <span class="nc">DiceGameDelegate</span>?
</li><li> <span class="k">func</span> <span class="nv">play</span>() {
</li><li> <span class="nv">square</span> = <span class="m">0</span>
</li><li> <span class="nv">delegate</span>?.<span class="nv">gameDidStart</span>(<span class="k">self</span>)
</li><li> <span class="nv">gameLoop</span>: <span class="k">while</span> <span class="nv">square</span> != <span class="nv">finalSquare</span> {
</li><li> <span class="k">let</span> <span class="nv">diceRoll</span> = <span class="nv">dice</span>.<span class="nv">roll</span>()
</li><li> <span class="nv">delegate</span>?.<span class="nv">game</span>(<span class="k">self</span>, <span class="nv">didStartNewTurnWithDiceRoll</span>: <span class="nv">diceRoll</span>)
</li><li> <span class="k">switch</span> <span class="nv">square</span> + <span class="nv">diceRoll</span> {
</li><li> <span class="k">case</span> <span class="nv">finalSquare</span>:
</li><li> <span class="k">break</span> <span class="nv">gameLoop</span>
</li><li> <span class="k">case</span> <span class="k">let</span> <span class="nv">newSquare</span> <span class="k">where</span> <span class="nv">newSquare</span> &gt; <span class="nv">finalSquare</span>:
</li><li> <span class="k">continue</span> <span class="nv">gameLoop</span>
</li><li> <span class="k">default</span>:
</li><li> <span class="nv">square</span> += <span class="nv">diceRoll</span>
</li><li> <span class="nv">square</span> += <span class="nv">board</span>[<span class="nv">square</span>]
</li><li>            }
</li><li>        }
</li><li> <span class="nv">delegate</span>?.<span class="nv">gameDidEnd</span>(<span class="k">self</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>For a description of the <em>Snakes and Ladders</em> gameplay, see <a class="reference internal" href="ControlFlow.html#ID137"><span class="std std-ref">Break</span></a>.</p>
<p>This version of the game is wrapped up as a class called <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>, which adopts the <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code> protocol. It provides a gettable <code class="docutils literal notranslate"><span class="pre">dice</span></code> property and a <code class="docutils literal notranslate"><span class="pre">play()</span></code> method in order to conform to the protocol. (The <code class="docutils literal notranslate"><span class="pre">dice</span></code> property is declared as a constant property because it doesn’t need to change after initialization, and the protocol only requires that it must be gettable.)</p>
<p>The <em>Snakes and Ladders</em> game board setup takes place within the class’s <code class="docutils literal notranslate"><span class="pre">init()</span></code> initializer. All game logic is moved into the protocol’s <code class="docutils literal notranslate"><span class="pre">play</span></code> method, which uses the protocol’s required <code class="docutils literal notranslate"><span class="pre">dice</span></code> property to provide its dice roll values.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">delegate</span></code> property is defined as an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>, because a delegate isn’t required in order to play the game. Because it’s of an optional type, the <code class="docutils literal notranslate"><span class="pre">delegate</span></code> property is automatically set to an initial value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Thereafter, the game instantiator has the option to set the property to a suitable delegate. Because the <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code> protocol is class-only, you can declare the delegate to be <code class="docutils literal notranslate"><span class="pre">weak</span></code> to prevent reference cycles.</p>
<p><code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code> provides three methods for tracking the progress of a game. These three methods have been incorporated into the game logic within the <code class="docutils literal notranslate"><span class="pre">play()</span></code> method above, and are called when a new game starts, a new turn begins, or the game ends.</p>
<p>Because the <code class="docutils literal notranslate"><span class="pre">delegate</span></code> property is an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>, the <code class="docutils literal notranslate"><span class="pre">play()</span></code> method uses optional chaining each time it calls a method on the delegate. If the <code class="docutils literal notranslate"><span class="pre">delegate</span></code> property is nil, these delegate calls fail gracefully and without error. If the <code class="docutils literal notranslate"><span class="pre">delegate</span></code> property is non-nil, the delegate methods are called, and are passed the <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> instance as a parameter.</p>
<p>This next example shows a class called <code class="docutils literal notranslate"><span class="pre">DiceGameTracker</span></code>, which adopts the <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">DiceGameTracker</span>: <span class="nc">DiceGameDelegate</span> {
</li><li> <span class="k">var</span> <span class="nv">numberOfTurns</span> = <span class="m">0</span>
</li><li> <span class="k">func</span> <span class="nv">gameDidStart</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>) {
</li><li> <span class="nv">numberOfTurns</span> = <span class="m">0</span>
</li><li> <span class="k">if</span> <span class="nv">game</span> <span class="k">is</span> <span class="nc">SnakesAndLadders</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Started a new game of Snakes and Ladders"</span>)
</li><li>        }
</li><li> <span class="nv">print</span>(<span class="s">"The game is using a </span>\<span class="p">(</span><span class="nv">game</span>.<span class="nv">dice</span>.<span class="nv">sides</span><span class="p">)</span><span class="s">-sided dice"</span>)
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">game</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>, <span class="nv">didStartNewTurnWithDiceRoll</span> <span class="nv">diceRoll</span>: <span class="nc">Int</span>) {
</li><li> <span class="nv">numberOfTurns</span> += <span class="m">1</span>
</li><li> <span class="nv">print</span>(<span class="s">"Rolled a </span>\<span class="p">(</span><span class="nv">diceRoll</span><span class="p">)</span><span class="s">"</span>)
</li><li>    }
</li><li> <span class="k">func</span> <span class="nv">gameDidEnd</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"The game lasted for </span>\<span class="p">(</span><span class="nv">numberOfTurns</span><span class="p">)</span><span class="s"> turns"</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">DiceGameTracker</span></code> implements all three methods required by <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>. It uses these methods to keep track of the number of turns a game has taken. It resets a <code class="docutils literal notranslate"><span class="pre">numberOfTurns</span></code> property to zero when the game starts, increments it each time a new turn begins, and prints out the total number of turns once the game has ended.</p>
<p>The implementation of <code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code> shown above uses the <code class="docutils literal notranslate"><span class="pre">game</span></code> parameter to print some introductory information about the game that is about to be played. The <code class="docutils literal notranslate"><span class="pre">game</span></code> parameter has a type of <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>, not <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>, and so <code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code> can access and use only methods and properties that are implemented as part of the <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code> protocol. However, the method is still able to use type casting to query the type of the underlying instance. In this example, it checks whether <code class="docutils literal notranslate"><span class="pre">game</span></code> is actually an instance of <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> behind the scenes, and prints an appropriate message if so.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code> method also accesses the <code class="docutils literal notranslate"><span class="pre">dice</span></code> property of the passed <code class="docutils literal notranslate"><span class="pre">game</span></code> parameter. Because <code class="docutils literal notranslate"><span class="pre">game</span></code> is known to conform to the <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code> protocol, it’s guaranteed to have a <code class="docutils literal notranslate"><span class="pre">dice</span></code> property, and so the <code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code> method is able to access and print the dice’s <code class="docutils literal notranslate"><span class="pre">sides</span></code> property, regardless of what kind of game is being played.</p>
<p>Here’s how <code class="docutils literal notranslate"><span class="pre">DiceGameTracker</span></code> looks in action:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">tracker</span> = <span class="nv">DiceGameTracker</span>()
</li><li><span class="k">let</span> <span class="nv">game</span> = <span class="nv">SnakesAndLadders</span>()
</li><li><span class="nv">game</span>.<span class="nv">delegate</span> = <span class="nv">tracker</span>
</li><li><span class="nv">game</span>.<span class="nv">play</span>()
</li><li><span class="c">// Started a new game of Snakes and Ladders</span>
</li><li><span class="c">// The game is using a 6-sided dice</span>
</li><li><span class="c">// Rolled a 3</span>
</li><li><span class="c">// Rolled a 5</span>
</li><li><span class="c">// Rolled a 4</span>
</li><li><span class="c">// Rolled a 5</span>
</li><li><span class="c">// The game lasted for 4 turns</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID277">
<h2>Adding Protocol Conformance with an Extension<a class="headerlink" href="Protocols.html#ID277" title="Permalink to this headline">¶</a></h2>
<p>You can extend an existing type to adopt and conform to a new protocol, even if you don’t have access to the source code for the existing type. Extensions can add new properties, methods, and subscripts to an existing type, and are therefore able to add any requirements that a protocol may demand. For more about extensions, see <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instance’s type in an extension.</p>
</div>
<p>For example, this protocol, called <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>, can be implemented by any type that has a way to be represented as text. This might be a description of itself, or a text version of its current state:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">TextRepresentable</span> {
</li><li> <span class="k">var</span> <span class="nv">textualDescription</span>: <span class="nc">String</span> { <span class="k">get</span> }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Dice</span></code> class from above can be extended to adopt and conform to <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Dice</span>: <span class="nc">TextRepresentable</span> {
</li><li> <span class="k">var</span> <span class="nv">textualDescription</span>: <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="s">"A </span>\<span class="p">(</span><span class="nv">sides</span><span class="p">)</span><span class="s">-sided dice"</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This extension adopts the new protocol in exactly the same way as if <code class="docutils literal notranslate"><span class="pre">Dice</span></code> had provided it in its original implementation. The protocol name is provided after the type name, separated by a colon, and an implementation of all requirements of the protocol is provided within the extension’s curly braces.</p>
<p>Any <code class="docutils literal notranslate"><span class="pre">Dice</span></code> instance can now be treated as <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">d12</span> = <span class="nv">Dice</span>(<span class="nv">sides</span>: <span class="m">12</span>, <span class="nv">generator</span>: <span class="nv">LinearCongruentialGenerator</span>())
</li><li><span class="nv">print</span>(<span class="nv">d12</span>.<span class="nv">textualDescription</span>)
</li><li><span class="c">// Prints "A 12-sided dice"</span>
</li></ol></div></div></div>
<p>Similarly, the <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> game class can be extended to adopt and conform to the <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">SnakesAndLadders</span>: <span class="nc">TextRepresentable</span> {
</li><li> <span class="k">var</span> <span class="nv">textualDescription</span>: <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="s">"A game of Snakes and Ladders with </span>\<span class="p">(</span><span class="nv">finalSquare</span><span class="p">)</span><span class="s"> squares"</span>
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">game</span>.<span class="nv">textualDescription</span>)
</li><li><span class="c">// Prints "A game of Snakes and Ladders with 25 squares"</span>
</li></ol></div></div></div>
<div class="section" id="ID574">
<h3>Conditionally Conforming to a Protocol<a class="headerlink" href="Protocols.html#ID574" title="Permalink to this headline">¶</a></h3>
<p>A generic type may be able to satisfy the requirements of a protocol only under certain conditions, such as when the type’s generic parameter conforms to the protocol. You can make a generic type conditionally conform to a protocol by listing constraints when extending the type. Write these constraints after the name of the protocol you’re adopting by writing a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause. For more about generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clauses, see <a class="reference internal" href="Generics.html#ID192"><span class="std std-ref">Generic Where Clauses</span></a>.</p>
<p>The following extension makes <code class="docutils literal notranslate"><span class="pre">Array</span></code> instances conform to the <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> protocol whenever they store elements of a type that conforms to <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">TextRepresentable</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">TextRepresentable</span> {
</li><li> <span class="k">var</span> <span class="nv">textualDescription</span>: <span class="nc">String</span> {
</li><li> <span class="k">let</span> <span class="nv">itemsAsText</span> = <span class="k">self</span>.<span class="nv">map</span> { <span class="nv">$0</span>.<span class="nv">textualDescription</span> }
</li><li> <span class="k">return</span> <span class="s">"["</span> + <span class="nv">itemsAsText</span>.<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">", "</span>) + <span class="s">"]"</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">myDice</span> = [<span class="nv">d6</span>, <span class="nv">d12</span>]
</li><li><span class="nv">print</span>(<span class="nv">myDice</span>.<span class="nv">textualDescription</span>)
</li><li><span class="c">// Prints "[A 6-sided dice, A 12-sided dice]"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID278">
<h3>Declaring Protocol Adoption with an Extension<a class="headerlink" href="Protocols.html#ID278" title="Permalink to this headline">¶</a></h3>
<p>If a type already conforms to all of the requirements of a protocol, but has not yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Hamster</span> {
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">var</span> <span class="nv">textualDescription</span>: <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="s">"A hamster named </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">"</span>
</li><li>    }
</li><li>}
</li><li><span class="k">extension</span> <span class="nc">Hamster</span>: <span class="nc">TextRepresentable</span> {}
</li></ol></div></div></div>
<p>Instances of <code class="docutils literal notranslate"><span class="pre">Hamster</span></code> can now be used wherever <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> is the required type:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">simonTheHamster</span> = <span class="nv">Hamster</span>(<span class="nv">name</span>: <span class="s">"Simon"</span>)
</li><li><span class="k">let</span> <span class="nv">somethingTextRepresentable</span>: <span class="nc">TextRepresentable</span> = <span class="nv">simonTheHamster</span>
</li><li><span class="nv">print</span>(<span class="nv">somethingTextRepresentable</span>.<span class="nv">textualDescription</span>)
</li><li><span class="c">// Prints "A hamster named Simon"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Types don’t automatically adopt a protocol just by satisfying its requirements. They must always explicitly declare their adoption of the protocol.</p>
</div>
</div>
</div>
<div class="section" id="ID279">
<h2>Collections of Protocol Types<a class="headerlink" href="Protocols.html#ID279" title="Permalink to this headline">¶</a></h2>
<p>A protocol can be used as the type to be stored in a collection such as an array or a dictionary, as mentioned in <a class="reference internal" href="Protocols.html#ID275"><span class="std std-ref">Protocols as Types</span></a>. This example creates an array of <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> things:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">things</span>: [<span class="nc">TextRepresentable</span>] = [<span class="nv">game</span>, <span class="nv">d12</span>, <span class="nv">simonTheHamster</span>]
</li></ol></div></div></div>
<p>It’s now possible to iterate over the items in the array, and print each item’s textual description:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">thing</span> <span class="k">in</span> <span class="nv">things</span> {
</li><li> <span class="nv">print</span>(<span class="nv">thing</span>.<span class="nv">textualDescription</span>)
</li><li>}
</li><li><span class="c">// A game of Snakes and Ladders with 25 squares</span>
</li><li><span class="c">// A 12-sided dice</span>
</li><li><span class="c">// A hamster named Simon</span>
</li></ol></div></div></div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">thing</span></code> constant is of type <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>. It’s not of type <code class="docutils literal notranslate"><span class="pre">Dice</span></code>, or <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>, or <code class="docutils literal notranslate"><span class="pre">Hamster</span></code>, even if the actual instance behind the scenes is of one of those types. Nonetheless, because it’s of type <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>, and anything that is <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> is known to have a <code class="docutils literal notranslate"><span class="pre">textualDescription</span></code> property, it’s safe to access <code class="docutils literal notranslate"><span class="pre">thing.textualDescription</span></code> each time through the loop.</p>
</div>
<div class="section" id="ID280">
<h2>Protocol Inheritance<a class="headerlink" href="Protocols.html#ID280" title="Permalink to this headline">¶</a></h2>
<p>A protocol can <em>inherit</em> one or more other protocols and can add further requirements on top of the requirements it inherits. The syntax for protocol inheritance is similar to the syntax for class inheritance, but with the option to list multiple inherited protocols, separated by commas:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">InheritingProtocol</span>: <span class="nc">SomeProtocol</span>, <span class="nc">AnotherProtocol</span> {
</li><li> <span class="c">// protocol definition goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>Here’s an example of a protocol that inherits the <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> protocol from above:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">PrettyTextRepresentable</span>: <span class="nc">TextRepresentable</span> {
</li><li> <span class="k">var</span> <span class="nv">prettyTextualDescription</span>: <span class="nc">String</span> { <span class="k">get</span> }
</li><li>}
</li></ol></div></div></div>
<p>This example defines a new protocol, <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>, which inherits from <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>. Anything that adopts <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code> must satisfy all of the requirements enforced by <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>, <em>plus</em> the additional requirements enforced by <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>. In this example, <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code> adds a single requirement to provide a gettable property called <code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code> that returns a <code class="docutils literal notranslate"><span class="pre">String</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> class can be extended to adopt and conform to <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">SnakesAndLadders</span>: <span class="nc">PrettyTextRepresentable</span> {
</li><li> <span class="k">var</span> <span class="nv">prettyTextualDescription</span>: <span class="nc">String</span> {
</li><li> <span class="k">var</span> <span class="nv">output</span> = <span class="nv">textualDescription</span> + <span class="s">":\n"</span>
</li><li> <span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> <span class="m">1</span>...<span class="nv">finalSquare</span> {
</li><li> <span class="k">switch</span> <span class="nv">board</span>[<span class="nv">index</span>] {
</li><li> <span class="k">case</span> <span class="k">let</span> <span class="nv">ladder</span> <span class="k">where</span> <span class="nv">ladder</span> &gt; <span class="m">0</span>:
</li><li> <span class="nv">output</span> += <span class="s">"▲ "</span>
</li><li> <span class="k">case</span> <span class="k">let</span> <span class="nv">snake</span> <span class="k">where</span> <span class="nv">snake</span> &lt; <span class="m">0</span>:
</li><li> <span class="nv">output</span> += <span class="s">"▼ "</span>
</li><li> <span class="k">default</span>:
</li><li> <span class="nv">output</span> += <span class="s">"○ "</span>
</li><li>            }
</li><li>        }
</li><li> <span class="k">return</span> <span class="nv">output</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This extension states that it adopts the <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code> protocol and provides an implementation of the <code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code> property for the <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> type. Anything that is <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code> must also be <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>, and so the implementation of <code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code> starts by accessing the <code class="docutils literal notranslate"><span class="pre">textualDescription</span></code> property from the <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> protocol to begin an output string. It appends a colon and a line break, and uses this as the start of its pretty text representation. It then iterates through the array of board squares, and appends a geometric shape to represent the contents of each square:</p>
<ul class="simple">
<li>If the square’s value is greater than <code class="docutils literal notranslate"><span class="pre">0</span></code>, it’s the base of a ladder, and is represented by <code class="docutils literal notranslate"><span class="pre">▲</span></code>.</li>
<li>If the square’s value is less than <code class="docutils literal notranslate"><span class="pre">0</span></code>, it’s the head of a snake, and is represented by <code class="docutils literal notranslate"><span class="pre">▼</span></code>.</li>
<li>Otherwise, the square’s value is <code class="docutils literal notranslate"><span class="pre">0</span></code>, and it’s a “free” square, represented by <code class="docutils literal notranslate"><span class="pre">○</span></code>.</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code> property can now be used to print a pretty text description of any <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="nv">game</span>.<span class="nv">prettyTextualDescription</span>)
</li><li><span class="c">// A game of Snakes and Ladders with 25 squares:</span>
</li><li><span class="c">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID281">
<h2>Class-Only Protocols<a class="headerlink" href="Protocols.html#ID281" title="Permalink to this headline">¶</a></h2>
<p>You can limit protocol adoption to class types (and not structures or enumerations) by adding the <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code> protocol to a protocol’s inheritance list.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SomeClassOnlyProtocol</span>: <span class="nc">AnyObject</span>, <span class="nc">SomeInheritedProtocol</span> {
</li><li> <span class="c">// class-only protocol definition goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>In the example above, <code class="docutils literal notranslate"><span class="pre">SomeClassOnlyProtocol</span></code> can only be adopted by class types. It’s a compile-time error to write a structure or enumeration definition that tries to adopt <code class="docutils literal notranslate"><span class="pre">SomeClassOnlyProtocol</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics. For more about reference and value semantics, see <a class="reference internal" href="ClassesAndStructures.html#ID88"><span class="std std-ref">Structures and Enumerations Are Value Types</span></a> and <a class="reference internal" href="ClassesAndStructures.html#ID89"><span class="std std-ref">Classes Are Reference Types</span></a>.</p>
</div>
</div>
<div class="section" id="ID282">
<h2>Protocol Composition<a class="headerlink" href="Protocols.html#ID282" title="Permalink to this headline">¶</a></h2>
<p>It can be useful to require a type to conform to multiple protocols at the same time. You can combine multiple protocols into a single requirement with a <em>protocol composition</em>. Protocol compositions behave as if you defined a temporary local protocol that has the combined requirements of all protocols in the composition. Protocol compositions don’t define any new protocol types.</p>
<p>Protocol compositions have the form <code class="docutils literal notranslate"><span class="pre">SomeProtocol</span> <span class="pre">&amp;</span> <span class="pre">AnotherProtocol</span></code>. You can list as many protocols as you need, separating them with ampersands (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>). In addition to its list of protocols, a protocol composition can also contain one class type, which you can use to specify a required superclass.</p>
<p>Here’s an example that combines two protocols called <code class="docutils literal notranslate"><span class="pre">Named</span></code> and <code class="docutils literal notranslate"><span class="pre">Aged</span></code> into a single protocol composition requirement on a function parameter:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Named</span> {
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span> { <span class="k">get</span> }
</li><li>}
</li><li><span class="k">protocol</span> <span class="nv">Aged</span> {
</li><li> <span class="k">var</span> <span class="nv">age</span>: <span class="nc">Int</span> { <span class="k">get</span> }
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Person</span>: <span class="nc">Named</span>, <span class="nc">Aged</span> {
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">var</span> <span class="nv">age</span>: <span class="nc">Int</span>
</li><li>}
</li><li><span class="k">func</span> <span class="nv">wishHappyBirthday</span>(<span class="nv">to</span> <span class="nv">celebrator</span>: <span class="nc">Named</span> &amp; <span class="nc">Aged</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Happy birthday, </span>\<span class="p">(</span><span class="nv">celebrator</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, you're </span>\<span class="p">(</span><span class="nv">celebrator</span>.<span class="nv">age</span><span class="p">)</span><span class="s">!"</span>)
</li><li>}
</li><li><span class="k">let</span> <span class="nv">birthdayPerson</span> = <span class="nv">Person</span>(<span class="nv">name</span>: <span class="s">"Malcolm"</span>, <span class="nv">age</span>: <span class="m">21</span>)
</li><li><span class="nv">wishHappyBirthday</span>(<span class="nv">to</span>: <span class="nv">birthdayPerson</span>)
</li><li><span class="c">// Prints "Happy birthday, Malcolm, you're 21!"</span>
</li></ol></div></div></div>
<p>In this example, the <code class="docutils literal notranslate"><span class="pre">Named</span></code> protocol has a single requirement for a gettable <code class="docutils literal notranslate"><span class="pre">String</span></code> property called <code class="docutils literal notranslate"><span class="pre">name</span></code>. The <code class="docutils literal notranslate"><span class="pre">Aged</span></code> protocol has a single requirement for a gettable <code class="docutils literal notranslate"><span class="pre">Int</span></code> property called <code class="docutils literal notranslate"><span class="pre">age</span></code>. Both protocols are adopted by a structure called <code class="docutils literal notranslate"><span class="pre">Person</span></code>.</p>
<p>The example also defines a <code class="docutils literal notranslate"><span class="pre">wishHappyBirthday(to:)</span></code> function. The type of the <code class="docutils literal notranslate"><span class="pre">celebrator</span></code> parameter is <code class="docutils literal notranslate"><span class="pre">Named</span> <span class="pre">&amp;</span> <span class="pre">Aged</span></code>, which means “any type that conforms to both the <code class="docutils literal notranslate"><span class="pre">Named</span></code> and <code class="docutils literal notranslate"><span class="pre">Aged</span></code> protocols.” It doesn’t matter which specific type is passed to the function, as long as it conforms to both of the required protocols.</p>
<p>The example then creates a new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance called <code class="docutils literal notranslate"><span class="pre">birthdayPerson</span></code> and passes this new instance to the <code class="docutils literal notranslate"><span class="pre">wishHappyBirthday(to:)</span></code> function. Because <code class="docutils literal notranslate"><span class="pre">Person</span></code> conforms to both protocols, this call is valid, and the <code class="docutils literal notranslate"><span class="pre">wishHappyBirthday(to:)</span></code> function can print its birthday greeting.</p>
<p>Here’s an example that combines the <code class="docutils literal notranslate"><span class="pre">Named</span></code> protocol from the previous example with a <code class="docutils literal notranslate"><span class="pre">Location</span></code> class:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Location</span> {
</li><li> <span class="k">var</span> <span class="nv">latitude</span>: <span class="nc">Double</span>
</li><li> <span class="k">var</span> <span class="nv">longitude</span>: <span class="nc">Double</span>
</li><li> <span class="k">init</span>(<span class="nv">latitude</span>: <span class="nc">Double</span>, <span class="nv">longitude</span>: <span class="nc">Double</span>) {
</li><li> <span class="k">self</span>.<span class="nv">latitude</span> = <span class="nv">latitude</span>
</li><li> <span class="k">self</span>.<span class="nv">longitude</span> = <span class="nv">longitude</span>
</li><li>    }
</li><li>}
</li><li><span class="k">class</span> <span class="nv">City</span>: <span class="nc">Location</span>, <span class="nc">Named</span> {
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">latitude</span>: <span class="nc">Double</span>, <span class="nv">longitude</span>: <span class="nc">Double</span>) {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li> <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">latitude</span>: <span class="nv">latitude</span>, <span class="nv">longitude</span>: <span class="nv">longitude</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">func</span> <span class="nv">beginConcert</span>(<span class="nv">in</span> <span class="nv">location</span>: <span class="nc">Location</span> &amp; <span class="nc">Named</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Hello, </span>\<span class="p">(</span><span class="nv">location</span>.<span class="nv">name</span><span class="p">)</span><span class="s">!"</span>)
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">seattle</span> = <span class="nv">City</span>(<span class="nv">name</span>: <span class="s">"Seattle"</span>, <span class="nv">latitude</span>: <span class="m">47.6</span>, <span class="nv">longitude</span>: <span class="m">-122.3</span>)
</li><li><span class="nv">beginConcert</span>(<span class="nv">in</span>: <span class="nv">seattle</span>)
</li><li><span class="c">// Prints "Hello, Seattle!"</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">beginConcert(in:)</span></code> function takes a parameter of type <code class="docutils literal notranslate"><span class="pre">Location</span> <span class="pre">&amp;</span> <span class="pre">Named</span></code>, which means “any type that’s a subclass of <code class="docutils literal notranslate"><span class="pre">Location</span></code> and that conforms to the <code class="docutils literal notranslate"><span class="pre">Named</span></code> protocol.” In this case, <code class="docutils literal notranslate"><span class="pre">City</span></code> satisfies both requirements.</p>
<p>Passing <code class="docutils literal notranslate"><span class="pre">birthdayPerson</span></code> to the <code class="docutils literal notranslate"><span class="pre">beginConcert(in:)</span></code> function is invalid because <code class="docutils literal notranslate"><span class="pre">Person</span></code> isn’t a subclass of <code class="docutils literal notranslate"><span class="pre">Location</span></code>. Likewise, if you made a subclass of <code class="docutils literal notranslate"><span class="pre">Location</span></code> that didn’t conform to the <code class="docutils literal notranslate"><span class="pre">Named</span></code> protocol, calling <code class="docutils literal notranslate"><span class="pre">beginConcert(in:)</span></code> with an instance of that type is also invalid.</p>
</div>
<div class="section" id="ID283">
<h2>Checking for Protocol Conformance<a class="headerlink" href="Protocols.html#ID283" title="Permalink to this headline">¶</a></h2>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">is</span></code> and <code class="docutils literal notranslate"><span class="pre">as</span></code> operators described in <a class="reference internal" href="TypeCasting.html"><span class="doc">Type Casting</span></a> to check for protocol conformance, and to cast to a specific protocol. Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a type:</p>
<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">is</span></code> operator returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if an instance conforms to a protocol and returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if it doesn’t.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">as?</span></code> version of the downcast operator returns an optional value of the protocol’s type, and this value is <code class="docutils literal notranslate"><span class="pre">nil</span></code> if the instance doesn’t conform to that protocol.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">as!</span></code> version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast doesn’t succeed.</li>
</ul>
<p>This example defines a protocol called <code class="docutils literal notranslate"><span class="pre">HasArea</span></code>, with a single property requirement of a gettable <code class="docutils literal notranslate"><span class="pre">Double</span></code> property called <code class="docutils literal notranslate"><span class="pre">area</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">HasArea</span> {
</li><li> <span class="k">var</span> <span class="nv">area</span>: <span class="nc">Double</span> { <span class="k">get</span> }
</li><li>}
</li></ol></div></div></div>
<p>Here are two classes, <code class="docutils literal notranslate"><span class="pre">Circle</span></code> and <code class="docutils literal notranslate"><span class="pre">Country</span></code>, both of which conform to the <code class="docutils literal notranslate"><span class="pre">HasArea</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Circle</span>: <span class="nc">HasArea</span> {
</li><li> <span class="k">let</span> <span class="nv">pi</span> = <span class="m">3.1415927</span>
</li><li> <span class="k">var</span> <span class="nv">radius</span>: <span class="nc">Double</span>
</li><li> <span class="k">var</span> <span class="nv">area</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="nv">pi</span> * <span class="nv">radius</span> * <span class="nv">radius</span> }
</li><li> <span class="k">init</span>(<span class="nv">radius</span>: <span class="nc">Double</span>) { <span class="k">self</span>.<span class="nv">radius</span> = <span class="nv">radius</span> }
</li><li>}
</li><li><span class="k">class</span> <span class="nv">Country</span>: <span class="nc">HasArea</span> {
</li><li> <span class="k">var</span> <span class="nv">area</span>: <span class="nc">Double</span>
</li><li> <span class="k">init</span>(<span class="nv">area</span>: <span class="nc">Double</span>) { <span class="k">self</span>.<span class="nv">area</span> = <span class="nv">area</span> }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Circle</span></code> class implements the <code class="docutils literal notranslate"><span class="pre">area</span></code> property requirement as a computed property, based on a stored <code class="docutils literal notranslate"><span class="pre">radius</span></code> property. The <code class="docutils literal notranslate"><span class="pre">Country</span></code> class implements the <code class="docutils literal notranslate"><span class="pre">area</span></code> requirement directly as a stored property. Both classes correctly conform to the <code class="docutils literal notranslate"><span class="pre">HasArea</span></code> protocol.</p>
<p>Here’s a class called <code class="docutils literal notranslate"><span class="pre">Animal</span></code>, which doesn’t conform to the <code class="docutils literal notranslate"><span class="pre">HasArea</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Animal</span> {
</li><li> <span class="k">var</span> <span class="nv">legs</span>: <span class="nc">Int</span>
</li><li> <span class="k">init</span>(<span class="nv">legs</span>: <span class="nc">Int</span>) { <span class="k">self</span>.<span class="nv">legs</span> = <span class="nv">legs</span> }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Circle</span></code>, <code class="docutils literal notranslate"><span class="pre">Country</span></code> and <code class="docutils literal notranslate"><span class="pre">Animal</span></code> classes don’t have a shared base class. Nonetheless, they’re all classes, and so instances of all three types can be used to initialize an array that stores values of type <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">objects</span>: [<span class="nc">AnyObject</span>] = [
</li><li> <span class="nv">Circle</span>(<span class="nv">radius</span>: <span class="m">2.0</span>),
</li><li> <span class="nv">Country</span>(<span class="nv">area</span>: <span class="m">243_610</span>),
</li><li> <span class="nv">Animal</span>(<span class="nv">legs</span>: <span class="m">4</span>)
</li><li>]
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">objects</span></code> array is initialized with an array literal containing a <code class="docutils literal notranslate"><span class="pre">Circle</span></code> instance with a radius of 2 units; a <code class="docutils literal notranslate"><span class="pre">Country</span></code> instance initialized with the surface area of the United Kingdom in square kilometers; and an <code class="docutils literal notranslate"><span class="pre">Animal</span></code> instance with four legs.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">objects</span></code> array can now be iterated, and each object in the array can be checked to see if it conforms to the <code class="docutils literal notranslate"><span class="pre">HasArea</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">object</span> <span class="k">in</span> <span class="nv">objects</span> {
</li><li> <span class="k">if</span> <span class="k">let</span> <span class="nv">objectWithArea</span> = <span class="nv">object</span> <span class="k">as</span>? <span class="nc">HasArea</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Area is </span>\<span class="p">(</span><span class="nv">objectWithArea</span>.<span class="nv">area</span><span class="p">)</span><span class="s">"</span>)
</li><li>    } <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Something that doesn't have an area"</span>)
</li><li>    }
</li><li>}
</li><li><span class="c">// Area is 12.5663708</span>
</li><li><span class="c">// Area is 243610.0</span>
</li><li><span class="c">// Something that doesn't have an area</span>
</li></ol></div></div></div>
<p>Whenever an object in the array conforms to the <code class="docutils literal notranslate"><span class="pre">HasArea</span></code> protocol, the optional value returned by the <code class="docutils literal notranslate"><span class="pre">as?</span></code> operator is unwrapped with optional binding into a constant called <code class="docutils literal notranslate"><span class="pre">objectWithArea</span></code>. The <code class="docutils literal notranslate"><span class="pre">objectWithArea</span></code> constant is known to be of type <code class="docutils literal notranslate"><span class="pre">HasArea</span></code>, and so its <code class="docutils literal notranslate"><span class="pre">area</span></code> property can be accessed and printed in a type-safe way.</p>
<p>Note that the underlying objects aren’t changed by the casting process. They continue to be a <code class="docutils literal notranslate"><span class="pre">Circle</span></code>, a <code class="docutils literal notranslate"><span class="pre">Country</span></code> and an <code class="docutils literal notranslate"><span class="pre">Animal</span></code>. However, at the point that they’re stored in the <code class="docutils literal notranslate"><span class="pre">objectWithArea</span></code> constant, they’re only known to be of type <code class="docutils literal notranslate"><span class="pre">HasArea</span></code>, and so only their <code class="docutils literal notranslate"><span class="pre">area</span></code> property can be accessed.</p>
</div>
<div class="section" id="ID284">
<h2>Optional Protocol Requirements<a class="headerlink" href="Protocols.html#ID284" title="Permalink to this headline">¶</a></h2>
<p>You can define <em>optional requirements</em> for protocols, These requirements don’t have to be implemented by types that conform to the protocol. Optional requirements are prefixed by the <code class="docutils literal notranslate"><span class="pre">optional</span></code> modifier as part of the protocol’s definition. Optional requirements are available so that you can write code that interoperates with Objective-C. Both the protocol and the optional requirement must be marked with the <code class="docutils literal notranslate"><span class="pre">@objc</span></code> attribute. Note that <code class="docutils literal notranslate"><span class="pre">@objc</span></code> protocols can be adopted only by classes that inherit from Objective-C classes or other <code class="docutils literal notranslate"><span class="pre">@objc</span></code> classes. They can’t be adopted by structures or enumerations.</p>
<p>When you use a method or property in an optional requirement, its type automatically becomes an optional. For example, a method of type <code class="docutils literal notranslate"><span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code> becomes <code class="docutils literal notranslate"><span class="pre">((Int)</span> <span class="pre">-&gt;</span> <span class="pre">String)?</span></code>. Note that the entire function type is wrapped in the optional, not the method’s return value.</p>
<p>An optional protocol requirement can be called with optional chaining, to account for the possibility that the requirement was not implemented by a type that conforms to the protocol. You check for an implementation of an optional method by writing a question mark after the name of the method when it’s called, such as <code class="docutils literal notranslate"><span class="pre">someOptionalMethod?(someArgument)</span></code>. For information on optional chaining, see <a class="reference internal" href="OptionalChaining.html"><span class="doc">Optional Chaining</span></a>.</p>
<p>The following example defines an integer-counting class called <code class="docutils literal notranslate"><span class="pre">Counter</span></code>, which uses an external data source to provide its increment amount. This data source is defined by the <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> protocol, which has two optional requirements:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">@objc</span> <span class="k">protocol</span> <span class="nv">CounterDataSource</span> {
</li><li> <span class="k">@objc</span> <span class="k">optional</span> <span class="k">func</span> <span class="nv">increment</span>(<span class="nv">forCount</span> <span class="nv">count</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span>
</li><li> <span class="k">@objc</span> <span class="k">optional</span> <span class="k">var</span> <span class="nv">fixedIncrement</span>: <span class="nc">Int</span> { <span class="k">get</span> }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> protocol defines an optional method requirement called <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> and an optional property requirement called <code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code>. These requirements define two different ways for data sources to provide an appropriate increment amount for a <code class="docutils literal notranslate"><span class="pre">Counter</span></code> instance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Strictly speaking, you can write a custom class that conforms to <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> without implementing <em>either</em> protocol requirement. They’re both optional, after all. Although technically allowed, this wouldn’t make for a very good data source.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class, defined below, has an optional <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> property of type <code class="docutils literal notranslate"><span class="pre">CounterDataSource?</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Counter</span> {
</li><li> <span class="k">var</span> <span class="nv">count</span> = <span class="m">0</span>
</li><li> <span class="k">var</span> <span class="nv">dataSource</span>: <span class="nc">CounterDataSource</span>?
</li><li> <span class="k">func</span> <span class="nv">increment</span>() {
</li><li> <span class="k">if</span> <span class="k">let</span> <span class="nv">amount</span> = <span class="nv">dataSource</span>?.<span class="nv">increment</span>?(<span class="nv">forCount</span>: <span class="nv">count</span>) {
</li><li> <span class="nv">count</span> += <span class="nv">amount</span>
</li><li>        } <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nv">amount</span> = <span class="nv">dataSource</span>?.<span class="nv">fixedIncrement</span> {
</li><li> <span class="nv">count</span> += <span class="nv">amount</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class stores its current value in a variable property called <code class="docutils literal notranslate"><span class="pre">count</span></code>. The <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class also defines a method called <code class="docutils literal notranslate"><span class="pre">increment</span></code>, which increments the <code class="docutils literal notranslate"><span class="pre">count</span></code> property every time the method is called.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">increment()</span></code> method first tries to retrieve an increment amount by looking for an implementation of the <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> method on its data source. The <code class="docutils literal notranslate"><span class="pre">increment()</span></code> method uses optional chaining to try to call <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>, and passes the current <code class="docutils literal notranslate"><span class="pre">count</span></code> value as the method’s single argument.</p>
<p>Note that <em>two</em> levels of optional chaining are at play here. First, it’s possible that <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> may be <code class="docutils literal notranslate"><span class="pre">nil</span></code>, and so <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> has a question mark after its name to indicate that <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> should be called only if <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> isn’t <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Second, even if <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> <em>does</em> exist, there’s no guarantee that it implements <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>, because it’s an optional requirement. Here, the possibility that <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> might not be implemented is also handled by optional chaining. The call to <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> happens only if <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> exists—that is, if it isn’t <code class="docutils literal notranslate"><span class="pre">nil</span></code>. This is why <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> is also written with a question mark after its name.</p>
<p>Because the call to <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> can fail for either of these two reasons, the call returns an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">Int</span></code> value. This is true even though <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> is defined as returning a nonoptional <code class="docutils literal notranslate"><span class="pre">Int</span></code> value in the definition of <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code>. Even though there are two optional chaining operations, one after another, the result is still wrapped in a single optional. For more information about using multiple optional chaining operations, see <a class="reference internal" href="OptionalChaining.html#ID252"><span class="std std-ref">Linking Multiple Levels of Chaining</span></a>.</p>
<p>After calling <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>, the optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> that it returns is unwrapped into a constant called <code class="docutils literal notranslate"><span class="pre">amount</span></code>, using optional binding. If the optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> does contain a value—that is, if the delegate and method both exist, and the method returned a value—the unwrapped <code class="docutils literal notranslate"><span class="pre">amount</span></code> is added onto the stored <code class="docutils literal notranslate"><span class="pre">count</span></code> property, and incrementation is complete.</p>
<p>If it’s <em>not</em> possible to retrieve a value from the <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> method—either because <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> is nil, or because the data source doesn’t implement <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>—then the <code class="docutils literal notranslate"><span class="pre">increment()</span></code> method tries to retrieve a value from the data source’s <code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code> property instead. The <code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code> property is also an optional requirement, so its value is an optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> value, even though <code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code> is defined as a nonoptional <code class="docutils literal notranslate"><span class="pre">Int</span></code> property as part of the <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> protocol definition.</p>
<p>Here’s a simple <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> implementation where the data source returns a constant value of <code class="docutils literal notranslate"><span class="pre">3</span></code> every time it’s queried. It does this by implementing the optional <code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code> property requirement:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">ThreeSource</span>: <span class="nc">NSObject</span>, <span class="nc">CounterDataSource</span> {
</li><li> <span class="k">let</span> <span class="nv">fixedIncrement</span> = <span class="m">3</span>
</li><li>}
</li></ol></div></div></div>
<p>You can use an instance of <code class="docutils literal notranslate"><span class="pre">ThreeSource</span></code> as the data source for a new <code class="docutils literal notranslate"><span class="pre">Counter</span></code> instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">counter</span> = <span class="nv">Counter</span>()
</li><li><span class="nv">counter</span>.<span class="nv">dataSource</span> = <span class="nv">ThreeSource</span>()
</li><li><span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">4</span> {
</li><li> <span class="nv">counter</span>.<span class="nv">increment</span>()
</li><li> <span class="nv">print</span>(<span class="nv">counter</span>.<span class="nv">count</span>)
</li><li>}
</li><li><span class="c">// 3</span>
</li><li><span class="c">// 6</span>
</li><li><span class="c">// 9</span>
</li><li><span class="c">// 12</span>
</li></ol></div></div></div>
<p>The code above creates a new <code class="docutils literal notranslate"><span class="pre">Counter</span></code> instance; sets its data source to be a new <code class="docutils literal notranslate"><span class="pre">ThreeSource</span></code> instance; and calls the counter’s <code class="docutils literal notranslate"><span class="pre">increment()</span></code> method four times. As expected, the counter’s <code class="docutils literal notranslate"><span class="pre">count</span></code> property increases by three each time <code class="docutils literal notranslate"><span class="pre">increment()</span></code> is called.</p>
<p>Here’s a more complex data source called <code class="docutils literal notranslate"><span class="pre">TowardsZeroSource</span></code>, which makes a <code class="docutils literal notranslate"><span class="pre">Counter</span></code> instance count up or down towards zero from its current <code class="docutils literal notranslate"><span class="pre">count</span></code> value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">TowardsZeroSource</span>: <span class="nc">NSObject</span>, <span class="nc">CounterDataSource</span> {
</li><li> <span class="k">func</span> <span class="nv">increment</span>(<span class="nv">forCount</span> <span class="nv">count</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">if</span> <span class="nv">count</span> == <span class="m">0</span> {
</li><li> <span class="k">return</span> <span class="m">0</span>
</li><li>        } <span class="k">else</span> <span class="k">if</span> <span class="nv">count</span> &lt; <span class="m">0</span> {
</li><li> <span class="k">return</span> <span class="m">1</span>
</li><li>        } <span class="k">else</span> {
</li><li> <span class="k">return</span> <span class="m">-1</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">TowardsZeroSource</span></code> class implements the optional <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> method from the <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> protocol and uses the <code class="docutils literal notranslate"><span class="pre">count</span></code> argument value to work out which direction to count in. If <code class="docutils literal notranslate"><span class="pre">count</span></code> is already zero, the method returns <code class="docutils literal notranslate"><span class="pre">0</span></code> to indicate that no further counting should take place.</p>
<p>You can use an instance of <code class="docutils literal notranslate"><span class="pre">TowardsZeroSource</span></code> with the existing <code class="docutils literal notranslate"><span class="pre">Counter</span></code> instance to count from <code class="docutils literal notranslate"><span class="pre">-4</span></code> to zero. Once the counter reaches zero, no more counting takes place:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">counter</span>.<span class="nv">count</span> = <span class="m">-4</span>
</li><li><span class="nv">counter</span>.<span class="nv">dataSource</span> = <span class="nv">TowardsZeroSource</span>()
</li><li><span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">5</span> {
</li><li> <span class="nv">counter</span>.<span class="nv">increment</span>()
</li><li> <span class="nv">print</span>(<span class="nv">counter</span>.<span class="nv">count</span>)
</li><li>}
</li><li><span class="c">// -3</span>
</li><li><span class="c">// -2</span>
</li><li><span class="c">// -1</span>
</li><li><span class="c">// 0</span>
</li><li><span class="c">// 0</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID521">
<h2>Protocol Extensions<a class="headerlink" href="Protocols.html#ID521" title="Permalink to this headline">¶</a></h2>
<p>Protocols can be extended to provide method, initializer, subscript, and computed property implementations to conforming types. This allows you to define behavior on protocols themselves, rather than in each type’s individual conformance or in a global function.</p>
<p>For example, the <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code> protocol can be extended to provide a <code class="docutils literal notranslate"><span class="pre">randomBool()</span></code> method, which uses the result of the required <code class="docutils literal notranslate"><span class="pre">random()</span></code> method to return a random <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">RandomNumberGenerator</span> {
</li><li> <span class="k">func</span> <span class="nv">randomBool</span>() -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">return</span> <span class="nv">random</span>() &gt; <span class="m">0.5</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>By creating an extension on the protocol, all conforming types automatically gain this method implementation without any additional modification.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">generator</span> = <span class="nv">LinearCongruentialGenerator</span>()
</li><li><span class="nv">print</span>(<span class="s">"Here's a random number: </span>\<span class="p">(</span><span class="nv">generator</span>.<span class="nv">random</span>()<span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "Here's a random number: 0.3746499199817101"</span>
</li><li><span class="nv">print</span>(<span class="s">"And here's a random Boolean: </span>\<span class="p">(</span><span class="nv">generator</span>.<span class="nv">randomBool</span>()<span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "And here's a random Boolean: true"</span>
</li></ol></div></div></div>
<p>Protocol extensions can add implementations to conforming types but can’t make a protocol extend or inherit from another protocol. Protocol inheritance is always specified in the protocol declaration itself.</p>
<div class="section" id="ID529">
<h3>Providing Default Implementations<a class="headerlink" href="Protocols.html#ID529" title="Permalink to this headline">¶</a></h3>
<p>You can use protocol extensions to provide a default implementation to any method or computed property requirement of that protocol. If a conforming type provides its own implementation of a required method or property, that implementation will be used instead of the one provided by the extension.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Protocol requirements with default implementations provided by extensions are distinct from optional protocol requirements. Although conforming types don’t have to provide their own implementation of either, requirements with default implementations can be called without optional chaining.</p>
</div>
<p>For example, the <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code> protocol, which inherits the <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> protocol can provide a default implementation of its required <code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code> property to simply return the result of accessing the <code class="docutils literal notranslate"><span class="pre">textualDescription</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">PrettyTextRepresentable</span>  {
</li><li> <span class="k">var</span> <span class="nv">prettyTextualDescription</span>: <span class="nc">String</span> {
</li><li> <span class="k">return</span> <span class="nv">textualDescription</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID527">
<h3>Adding Constraints to Protocol Extensions<a class="headerlink" href="Protocols.html#ID527" title="Permalink to this headline">¶</a></h3>
<p>When you define a protocol extension, you can specify constraints that conforming types must satisfy before the methods and properties of the extension are available. You write these constraints after the name of the protocol you’re extending by writing a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause. For more about generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clauses, see <a class="reference internal" href="Generics.html#ID192"><span class="std std-ref">Generic Where Clauses</span></a>.</p>
<p>For example, you can define an extension to the <code class="docutils literal notranslate"><span class="pre">Collection</span></code> protocol that applies to any collection whose elements conform to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol. By constraining a collection’s elements to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol, a part of the standard library, you can use the <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> operators to check for equality and inequality between two elements.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Collection</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">Equatable</span> {
</li><li> <span class="k">func</span> <span class="nv">allEqual</span>() -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">for</span> <span class="nv">element</span> <span class="k">in</span> <span class="k">self</span> {
</li><li> <span class="k">if</span> <span class="nv">element</span> != <span class="k">self</span>.<span class="nv">first</span> {
</li><li> <span class="k">return</span> <span class="k">false</span>
</li><li>            }
</li><li>        }
</li><li> <span class="k">return</span> <span class="k">true</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">allEqual()</span></code> method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> only if all the elements in the collection are equal.</p>
<p>Consider two arrays of integers, one where all the elements are the same, and one where they aren’t:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">equalNumbers</span> = [<span class="m">100</span>, <span class="m">100</span>, <span class="m">100</span>, <span class="m">100</span>, <span class="m">100</span>]
</li><li><span class="k">let</span> <span class="nv">differentNumbers</span> = [<span class="m">100</span>, <span class="m">100</span>, <span class="m">200</span>, <span class="m">100</span>, <span class="m">200</span>]
</li></ol></div></div></div>
<p>Because arrays conform to <code class="docutils literal notranslate"><span class="pre">Collection</span></code> and integers conform to <code class="docutils literal notranslate"><span class="pre">Equatable</span></code>, <code class="docutils literal notranslate"><span class="pre">equalNumbers</span></code> and <code class="docutils literal notranslate"><span class="pre">differentNumbers</span></code> can use the <code class="docutils literal notranslate"><span class="pre">allEqual()</span></code> method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="nv">equalNumbers</span>.<span class="nv">allEqual</span>())
</li><li><span class="c">// Prints "true"</span>
</li><li><span class="nv">print</span>(<span class="nv">differentNumbers</span>.<span class="nv">allEqual</span>())
</li><li><span class="c">// Prints "false"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a conforming type satisfies the requirements for multiple constrained extensions that provide implementations for the same method or property, Swift uses the implementation corresponding to the most specialized constraints.</p>
</div>
</div>
</div>
</div><div class="section" id="generics">
<h1>Generics<a class="headerlink" href="Generics.html#generics" title="Permalink to this headline">¶</a></h1>
<p><em>Generic code</em> enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.</p>
<p>Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code. In fact, you’ve been using generics throughout the <em>Language Guide</em>, even if you didn’t realize it. For example, Swift’s <code class="docutils literal notranslate"><span class="pre">Array</span></code> and <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> types are both generic collections. You can create an array that holds <code class="docutils literal notranslate"><span class="pre">Int</span></code> values, or an array that holds <code class="docutils literal notranslate"><span class="pre">String</span></code> values, or indeed an array for any other type that can be created in Swift. Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be.</p>
<div class="section" id="ID180">
<h2>The Problem That Generics Solve<a class="headerlink" href="Generics.html#ID180" title="Permalink to this headline">¶</a></h2>
<p>Here’s a standard, nongeneric function called <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code>, which swaps two <code class="docutils literal notranslate"><span class="pre">Int</span></code> values:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">swapTwoInts</span>(<span class="k">_</span> <span class="nv">a</span>: <span class="k">inout</span> <span class="nc">Int</span>, <span class="k">_</span> <span class="nv">b</span>: <span class="k">inout</span> <span class="nc">Int</span>) {
</li><li> <span class="k">let</span> <span class="nv">temporaryA</span> = <span class="nv">a</span>
</li><li> <span class="nv">a</span> = <span class="nv">b</span>
</li><li> <span class="nv">b</span> = <span class="nv">temporaryA</span>
</li><li>}
</li></ol></div></div></div>
<p>This function makes use of in-out parameters to swap the values of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, as described in <a class="reference internal" href="Functions.html#ID173"><span class="std std-ref">In-Out Parameters</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code> function swaps the original value of <code class="docutils literal notranslate"><span class="pre">b</span></code> into <code class="docutils literal notranslate"><span class="pre">a</span></code>, and the original value of <code class="docutils literal notranslate"><span class="pre">a</span></code> into <code class="docutils literal notranslate"><span class="pre">b</span></code>. You can call this function to swap the values in two <code class="docutils literal notranslate"><span class="pre">Int</span></code> variables:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">someInt</span> = <span class="m">3</span>
</li><li><span class="k">var</span> <span class="nv">anotherInt</span> = <span class="m">107</span>
</li><li><span class="nv">swapTwoInts</span>(&amp;<span class="nv">someInt</span>, &amp;<span class="nv">anotherInt</span>)
</li><li><span class="nv">print</span>(<span class="s">"someInt is now </span>\<span class="p">(</span><span class="nv">someInt</span><span class="p">)</span><span class="s">, and anotherInt is now </span>\<span class="p">(</span><span class="nv">anotherInt</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "someInt is now 107, and anotherInt is now 3"</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code> function is useful, but it can only be used with <code class="docutils literal notranslate"><span class="pre">Int</span></code> values. If you want to swap two <code class="docutils literal notranslate"><span class="pre">String</span></code> values, or two <code class="docutils literal notranslate"><span class="pre">Double</span></code> values, you have to write more functions, such as the <code class="docutils literal notranslate"><span class="pre">swapTwoStrings(_:_:)</span></code> and <code class="docutils literal notranslate"><span class="pre">swapTwoDoubles(_:_:)</span></code> functions shown below:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">swapTwoStrings</span>(<span class="k">_</span> <span class="nv">a</span>: <span class="k">inout</span> <span class="nc">String</span>, <span class="k">_</span> <span class="nv">b</span>: <span class="k">inout</span> <span class="nc">String</span>) {
</li><li> <span class="k">let</span> <span class="nv">temporaryA</span> = <span class="nv">a</span>
</li><li> <span class="nv">a</span> = <span class="nv">b</span>
</li><li> <span class="nv">b</span> = <span class="nv">temporaryA</span>
</li><li>}
</li><li>
</li><li><span class="k">func</span> <span class="nv">swapTwoDoubles</span>(<span class="k">_</span> <span class="nv">a</span>: <span class="k">inout</span> <span class="nc">Double</span>, <span class="k">_</span> <span class="nv">b</span>: <span class="k">inout</span> <span class="nc">Double</span>) {
</li><li> <span class="k">let</span> <span class="nv">temporaryA</span> = <span class="nv">a</span>
</li><li> <span class="nv">a</span> = <span class="nv">b</span>
</li><li> <span class="nv">b</span> = <span class="nv">temporaryA</span>
</li><li>}
</li></ol></div></div></div>
<p>You may have noticed that the bodies of the <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code>, <code class="docutils literal notranslate"><span class="pre">swapTwoStrings(_:_:)</span></code>, and <code class="docutils literal notranslate"><span class="pre">swapTwoDoubles(_:_:)</span></code> functions are identical. The only difference is the type of the values that they accept (<code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">String</span></code>, and <code class="docutils literal notranslate"><span class="pre">Double</span></code>).</p>
<p>It’s more useful, and considerably more flexible, to write a single function that swaps two values of <em>any</em> type. Generic code enables you to write such a function. (A generic version of these functions is defined below.)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In all three functions, the types of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must be the same. If <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> aren’t of the same type, it isn’t possible to swap their values. Swift is a type-safe language, and doesn’t allow (for example) a variable of type <code class="docutils literal notranslate"><span class="pre">String</span></code> and a variable of type <code class="docutils literal notranslate"><span class="pre">Double</span></code> to swap values with each other. Attempting to do so results in a compile-time error.</p>
</div>
</div>
<div class="section" id="ID181">
<h2>Generic Functions<a class="headerlink" href="Generics.html#ID181" title="Permalink to this headline">¶</a></h2>
<p><em>Generic functions</em> can work with any type. Here’s a generic version of the <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code> function from above, called <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">swapTwoValues</span>&lt;<span class="nv">T</span>&gt;(<span class="k">_</span> <span class="nv">a</span>: <span class="k">inout</span> <span class="nc">T</span>, <span class="k">_</span> <span class="nv">b</span>: <span class="k">inout</span> <span class="nc">T</span>) {
</li><li> <span class="k">let</span> <span class="nv">temporaryA</span> = <span class="nv">a</span>
</li><li> <span class="nv">a</span> = <span class="nv">b</span>
</li><li> <span class="nv">b</span> = <span class="nv">temporaryA</span>
</li><li>}
</li></ol></div></div></div>
<p>The body of the <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> function is identical to the body of the <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code> function. However, the first line of <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> is slightly different from <code class="docutils literal notranslate"><span class="pre">swapTwoInts(_:_:)</span></code>. Here’s how the first lines compare:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">swapTwoInts</span>(<span class="k">_</span> <span class="nv">a</span>: <span class="k">inout</span> <span class="nc">Int</span>, <span class="k">_</span> <span class="nv">b</span>: <span class="k">inout</span> <span class="nc">Int</span>)
</li><li><span class="k">func</span> <span class="nv">swapTwoValues</span>&lt;<span class="nv">T</span>&gt;(<span class="k">_</span> <span class="nv">a</span>: <span class="k">inout</span> <span class="nc">T</span>, <span class="k">_</span> <span class="nv">b</span>: <span class="k">inout</span> <span class="nc">T</span>)
</li></ol></div></div></div>
<p>The generic version of the function uses a <em>placeholder</em> type name (called <code class="docutils literal notranslate"><span class="pre">T</span></code>, in this case) instead of an <em>actual</em> type name (such as <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">String</span></code>, or <code class="docutils literal notranslate"><span class="pre">Double</span></code>). The placeholder type name doesn’t say anything about what <code class="docutils literal notranslate"><span class="pre">T</span></code> must be, but it <em>does</em> say that both <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must be of the same type <code class="docutils literal notranslate"><span class="pre">T</span></code>, whatever <code class="docutils literal notranslate"><span class="pre">T</span></code> represents. The actual type to use in place of <code class="docutils literal notranslate"><span class="pre">T</span></code> is determined each time the <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> function is called.</p>
<p>The other difference between a generic function and a nongeneric function is that the generic function’s name (<code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code>) is followed by the placeholder type name (<code class="docutils literal notranslate"><span class="pre">T</span></code>) inside angle brackets (<code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code>). The brackets tell Swift that <code class="docutils literal notranslate"><span class="pre">T</span></code> is a placeholder type name within the <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> function definition. Because <code class="docutils literal notranslate"><span class="pre">T</span></code> is a placeholder, Swift doesn’t look for an actual type called <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> function can now be called in the same way as <code class="docutils literal notranslate"><span class="pre">swapTwoInts</span></code>, except that it can be passed two values of <em>any</em> type, as long as both of those values are of the same type as each other. Each time <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> is called, the type to use for <code class="docutils literal notranslate"><span class="pre">T</span></code> is inferred from the types of values passed to the function.</p>
<p>In the two examples below, <code class="docutils literal notranslate"><span class="pre">T</span></code> is inferred to be <code class="docutils literal notranslate"><span class="pre">Int</span></code> and <code class="docutils literal notranslate"><span class="pre">String</span></code> respectively:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">someInt</span> = <span class="m">3</span>
</li><li><span class="k">var</span> <span class="nv">anotherInt</span> = <span class="m">107</span>
</li><li><span class="nv">swapTwoValues</span>(&amp;<span class="nv">someInt</span>, &amp;<span class="nv">anotherInt</span>)
</li><li><span class="c">// someInt is now 107, and anotherInt is now 3</span>
</li><li>
</li><li><span class="k">var</span> <span class="nv">someString</span> = <span class="s">"hello"</span>
</li><li><span class="k">var</span> <span class="nv">anotherString</span> = <span class="s">"world"</span>
</li><li><span class="nv">swapTwoValues</span>(&amp;<span class="nv">someString</span>, &amp;<span class="nv">anotherString</span>)
</li><li><span class="c">// someString is now "world", and anotherString is now "hello"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> function defined above is inspired by a generic function called <code class="docutils literal notranslate"><span class="pre">swap</span></code>, which is part of the Swift standard library, and is automatically made available for you to use in your apps. If you need the behavior of the <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> function in your own code, you can use Swift’s existing <code class="docutils literal notranslate"><span class="pre">swap(_:_:)</span></code> function rather than providing your own implementation.</p>
</div>
</div>
<div class="section" id="ID182">
<h2>Type Parameters<a class="headerlink" href="Generics.html#ID182" title="Permalink to this headline">¶</a></h2>
<p>In the <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> example above, the placeholder type <code class="docutils literal notranslate"><span class="pre">T</span></code> is an example of a <em>type parameter</em>. Type parameters specify and name a placeholder type, and are written immediately after the function’s name, between a pair of matching angle brackets (such as <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code>).</p>
<p>Once you specify a type parameter, you can use it to define the type of a function’s parameters (such as the <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> parameters of the <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> function), or as the function’s return type, or as a type annotation within the body of the function. In each case, the type parameter is replaced with an <em>actual</em> type whenever the function is called. (In the <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> example above, <code class="docutils literal notranslate"><span class="pre">T</span></code> was replaced with <code class="docutils literal notranslate"><span class="pre">Int</span></code> the first time the function was called, and was replaced with <code class="docutils literal notranslate"><span class="pre">String</span></code> the second time it was called.)</p>
<p>You can provide more than one type parameter by writing multiple type parameter names within the angle brackets, separated by commas.</p>
</div>
<div class="section" id="ID183">
<h2>Naming Type Parameters<a class="headerlink" href="Generics.html#ID183" title="Permalink to this headline">¶</a></h2>
<p>In most cases, type parameters have descriptive names, such as <code class="docutils literal notranslate"><span class="pre">Key</span></code> and <code class="docutils literal notranslate"><span class="pre">Value</span></code> in <code class="docutils literal notranslate"><span class="pre">Dictionary&lt;Key,</span> <span class="pre">Value&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">Element</span></code> in <code class="docutils literal notranslate"><span class="pre">Array&lt;Element&gt;</span></code>, which tells the reader about the relationship between the type parameter and the generic type or function it’s used in. However, when there isn’t a meaningful relationship between them, it’s traditional to name them using single letters such as <code class="docutils literal notranslate"><span class="pre">T</span></code>, <code class="docutils literal notranslate"><span class="pre">U</span></code>, and <code class="docutils literal notranslate"><span class="pre">V</span></code>, such as <code class="docutils literal notranslate"><span class="pre">T</span></code> in the <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> function above.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Always give type parameters upper camel case names (such as <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">MyTypeParameter</span></code>) to indicate that they’re a placeholder for a <em>type</em>, not a value.</p>
</div>
</div>
<div class="section" id="ID184">
<h2>Generic Types<a class="headerlink" href="Generics.html#ID184" title="Permalink to this headline">¶</a></h2>
<p>In addition to generic functions, Swift enables you to define your own <em>generic types</em>. These are custom classes, structures, and enumerations that can work with <em>any</em> type, in a similar way to <code class="docutils literal notranslate"><span class="pre">Array</span></code> and <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>.</p>
<p>This section shows you how to write a generic collection type called <code class="docutils literal notranslate"><span class="pre">Stack</span></code>. A stack is an ordered set of values, similar to an array, but with a more restricted set of operations than Swift’s <code class="docutils literal notranslate"><span class="pre">Array</span></code> type. An array allows new items to be inserted and removed at any location in the array. A stack, however, allows new items to be appended only to the end of the collection (known as <em>pushing</em> a new value on to the stack). Similarly, a stack allows items to be removed only from the end of the collection (known as <em>popping</em> a value off the stack).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The concept of a stack is used by the <code class="docutils literal notranslate"><span class="pre">UINavigationController</span></code> class to model the view controllers in its navigation hierarchy. You call the <code class="docutils literal notranslate"><span class="pre">UINavigationController</span></code> class <code class="docutils literal notranslate"><span class="pre">pushViewController(_:animated:)</span></code> method to add (or push) a view controller on to the navigation stack, and its <code class="docutils literal notranslate"><span class="pre">popViewControllerAnimated(_:)</span></code> method to remove (or pop) a view controller from the navigation stack. A stack is a useful collection model whenever you need a strict “last in, first out” approach to managing a collection.</p>
</div>
<p>The illustration below shows the push and pop behavior for a stack:</p>
<img alt="../_images/stackPushPop_2x.png" class="align-center" src="../_images/stackPushPop_2x.png" style="width: 664px;"/>
<ol class="arabic simple">
<li>There are currently three values on the stack.</li>
<li>A fourth value is pushed onto the top of the stack.</li>
<li>The stack now holds four values, with the most recent one at the top.</li>
<li>The top item in the stack is popped.</li>
<li>After popping a value, the stack once again holds three values.</li>
</ol>
<p>Here’s how to write a nongeneric version of a stack, in this case for a stack of <code class="docutils literal notranslate"><span class="pre">Int</span></code> values:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">IntStack</span> {
</li><li> <span class="k">var</span> <span class="nv">items</span> = [<span class="nv">Int</span>]()
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">push</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Int</span>) {
</li><li> <span class="nv">items</span>.<span class="nv">append</span>(<span class="nv">item</span>)
</li><li>    }
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">pop</span>() -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">items</span>.<span class="nv">removeLast</span>()
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This structure uses an <code class="docutils literal notranslate"><span class="pre">Array</span></code> property called <code class="docutils literal notranslate"><span class="pre">items</span></code> to store the values in the stack. <code class="docutils literal notranslate"><span class="pre">Stack</span></code> provides two methods, <code class="docutils literal notranslate"><span class="pre">push</span></code> and <code class="docutils literal notranslate"><span class="pre">pop</span></code>, to push and pop values on and off the stack. These methods are marked as <code class="docutils literal notranslate"><span class="pre">mutating</span></code>, because they need to modify (or <em>mutate</em>) the structure’s <code class="docutils literal notranslate"><span class="pre">items</span></code> array.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">IntStack</span></code> type shown above can only be used with <code class="docutils literal notranslate"><span class="pre">Int</span></code> values, however. It would be much more useful to define a <em>generic</em> <code class="docutils literal notranslate"><span class="pre">Stack</span></code> class, that can manage a stack of <em>any</em> type of value.</p>
<p>Here’s a generic version of the same code:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Stack</span>&lt;<span class="nv">Element</span>&gt; {
</li><li> <span class="k">var</span> <span class="nv">items</span> = [<span class="nv">Element</span>]()
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">push</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Element</span>) {
</li><li> <span class="nv">items</span>.<span class="nv">append</span>(<span class="nv">item</span>)
</li><li>    }
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">pop</span>() -&gt; <span class="nc">Element</span> {
</li><li> <span class="k">return</span> <span class="nv">items</span>.<span class="nv">removeLast</span>()
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Note how the generic version of <code class="docutils literal notranslate"><span class="pre">Stack</span></code> is essentially the same as the nongeneric version, but with a type parameter called <code class="docutils literal notranslate"><span class="pre">Element</span></code> instead of an actual type of <code class="docutils literal notranslate"><span class="pre">Int</span></code>. This type parameter is written within a pair of angle brackets (<code class="docutils literal notranslate"><span class="pre">&lt;Element&gt;</span></code>) immediately after the structure’s name.</p>
<p><code class="docutils literal notranslate"><span class="pre">Element</span></code> defines a placeholder name for a type to be provided later. This future type can be referred to as <code class="docutils literal notranslate"><span class="pre">Element</span></code> anywhere within the structure’s definition. In this case, <code class="docutils literal notranslate"><span class="pre">Element</span></code> is used as a placeholder in three places:</p>
<ul class="simple">
<li>To create a property called <code class="docutils literal notranslate"><span class="pre">items</span></code>, which is initialized with an empty array of values of type <code class="docutils literal notranslate"><span class="pre">Element</span></code></li>
<li>To specify that the <code class="docutils literal notranslate"><span class="pre">push(_:)</span></code> method has a single parameter called <code class="docutils literal notranslate"><span class="pre">item</span></code>, which must be of type <code class="docutils literal notranslate"><span class="pre">Element</span></code></li>
<li>To specify that the value returned by the <code class="docutils literal notranslate"><span class="pre">pop()</span></code> method will be a value of type <code class="docutils literal notranslate"><span class="pre">Element</span></code></li>
</ul>
<p>Because it’s a generic type, <code class="docutils literal notranslate"><span class="pre">Stack</span></code> can be used to create a stack of <em>any</em> valid type in Swift, in a similar manner to <code class="docutils literal notranslate"><span class="pre">Array</span></code> and <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>.</p>
<p>You create a new <code class="docutils literal notranslate"><span class="pre">Stack</span></code> instance by writing the type to be stored in the stack within angle brackets. For example, to create a new stack of strings, you write <code class="docutils literal notranslate"><span class="pre">Stack&lt;String&gt;()</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">stackOfStrings</span> = <span class="nv">Stack</span>&lt;<span class="nc">String</span>&gt;()
</li><li><span class="nv">stackOfStrings</span>.<span class="nv">push</span>(<span class="s">"uno"</span>)
</li><li><span class="nv">stackOfStrings</span>.<span class="nv">push</span>(<span class="s">"dos"</span>)
</li><li><span class="nv">stackOfStrings</span>.<span class="nv">push</span>(<span class="s">"tres"</span>)
</li><li><span class="nv">stackOfStrings</span>.<span class="nv">push</span>(<span class="s">"cuatro"</span>)
</li><li><span class="c">// the stack now contains 4 strings</span>
</li></ol></div></div></div>
<p>Here’s how <code class="docutils literal notranslate"><span class="pre">stackOfStrings</span></code> looks after pushing these four values on to the stack:</p>
<img alt="../_images/stackPushedFourStrings_2x.png" class="align-center" src="../_images/stackPushedFourStrings_2x.png" style="width: 664px;"/>
<p>Popping a value from the stack removes and returns the top value, <code class="docutils literal notranslate"><span class="pre">"cuatro"</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">fromTheTop</span> = <span class="nv">stackOfStrings</span>.<span class="nv">pop</span>()
</li><li><span class="c">// fromTheTop is equal to "cuatro", and the stack now contains 3 strings</span>
</li></ol></div></div></div>
<p>Here’s how the stack looks after popping its top value:</p>
<img alt="../_images/stackPoppedOneString_2x.png" class="align-center" src="../_images/stackPoppedOneString_2x.png" style="width: 405px;"/>
</div>
<div class="section" id="ID185">
<h2>Extending a Generic Type<a class="headerlink" href="Generics.html#ID185" title="Permalink to this headline">¶</a></h2>
<p>When you extend a generic type, you don’t provide a type parameter list as part of the extension’s definition. Instead, the type parameter list from the <em>original</em> type definition is available within the body of the extension, and the original type parameter names are used to refer to the type parameters from the original definition.</p>
<p>The following example extends the generic <code class="docutils literal notranslate"><span class="pre">Stack</span></code> type to add a read-only computed property called <code class="docutils literal notranslate"><span class="pre">topItem</span></code>, which returns the top item on the stack without popping it from the stack:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Stack</span> {
</li><li> <span class="k">var</span> <span class="nv">topItem</span>: <span class="nc">Element</span>? {
</li><li> <span class="k">return</span> <span class="nv">items</span>.<span class="nv">isEmpty</span> ? <span class="k">nil</span> : <span class="nv">items</span>[<span class="nv">items</span>.<span class="nv">count</span> - <span class="m">1</span>]
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">topItem</span></code> property returns an optional value of type <code class="docutils literal notranslate"><span class="pre">Element</span></code>. If the stack is empty, <code class="docutils literal notranslate"><span class="pre">topItem</span></code> returns <code class="docutils literal notranslate"><span class="pre">nil</span></code>; if the stack isn’t empty, <code class="docutils literal notranslate"><span class="pre">topItem</span></code> returns the final item in the <code class="docutils literal notranslate"><span class="pre">items</span></code> array.</p>
<p>Note that this extension doesn’t define a type parameter list. Instead, the <code class="docutils literal notranslate"><span class="pre">Stack</span></code> type’s existing type parameter name, <code class="docutils literal notranslate"><span class="pre">Element</span></code>, is used within the extension to indicate the optional type of the <code class="docutils literal notranslate"><span class="pre">topItem</span></code> computed property.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">topItem</span></code> computed property can now be used with any <code class="docutils literal notranslate"><span class="pre">Stack</span></code> instance to access and query its top item without removing it.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">topItem</span> = <span class="nv">stackOfStrings</span>.<span class="nv">topItem</span> {
</li><li> <span class="nv">print</span>(<span class="s">"The top item on the stack is </span>\<span class="p">(</span><span class="nv">topItem</span><span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li><span class="c">// Prints "The top item on the stack is tres."</span>
</li></ol></div></div></div>
<p>Extensions of a generic type can also include requirements that instances of the extended type must satisfy in order to gain the new functionality, as discussed in <a class="reference internal" href="Generics.html#ID553"><span class="std std-ref">Extensions with a Generic Where Clause</span></a> below.</p>
</div>
<div class="section" id="ID186">
<h2>Type Constraints<a class="headerlink" href="Generics.html#ID186" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">swapTwoValues(_:_:)</span></code> function and the <code class="docutils literal notranslate"><span class="pre">Stack</span></code> type can work with any type. However, it’s sometimes useful to enforce certain <em>type constraints</em> on the types that can be used with generic functions and generic types. Type constraints specify that a type parameter must inherit from a specific class, or conform to a particular protocol or protocol composition.</p>
<p>For example, Swift’s <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> type places a limitation on the types that can be used as keys for a dictionary. As described in <a class="reference internal" href="CollectionTypes.html#ID113"><span class="std std-ref">Dictionaries</span></a>, the type of a dictionary’s keys must be <em>hashable</em>. That is, it must provide a way to make itself uniquely representable. <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> needs its keys to be hashable so that it can check whether it already contains a value for a particular key. Without this requirement, <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> could not tell whether it should insert or replace a value for a particular key, nor would it be able to find a value for a given key that is already in the dictionary.</p>
<p>This requirement is enforced by a type constraint on the key type for <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>, which specifies that the key type must conform to the <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> protocol, a special protocol defined in the Swift standard library. All of Swift’s basic types (such as <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Double</span></code>, and <code class="docutils literal notranslate"><span class="pre">Bool</span></code>) are hashable by default.</p>
<p>You can define your own type constraints when creating custom generic types, and these constraints provide much of the power of generic programming. Abstract concepts like <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> characterize types in terms of their conceptual characteristics, rather than their concrete type.</p>
<div class="section" id="ID187">
<h3>Type Constraint Syntax<a class="headerlink" href="Generics.html#ID187" title="Permalink to this headline">¶</a></h3>
<p>You write type constraints by placing a single class or protocol constraint after a type parameter’s name, separated by a colon, as part of the type parameter list. The basic syntax for type constraints on a generic function is shown below (although the syntax is the same for generic types):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>&lt;<span class="nv">T</span>: <span class="nc">SomeClass</span>, <span class="nv">U</span>: <span class="nc">SomeProtocol</span>&gt;(<span class="nv">someT</span>: <span class="nc">T</span>, <span class="nv">someU</span>: <span class="nc">U</span>) {
</li><li> <span class="c">// function body goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>The hypothetical function above has two type parameters. The first type parameter, <code class="docutils literal notranslate"><span class="pre">T</span></code>, has a type constraint that requires <code class="docutils literal notranslate"><span class="pre">T</span></code> to be a subclass of <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>. The second type parameter, <code class="docutils literal notranslate"><span class="pre">U</span></code>, has a type constraint that requires <code class="docutils literal notranslate"><span class="pre">U</span></code> to conform to the protocol <code class="docutils literal notranslate"><span class="pre">SomeProtocol</span></code>.</p>
</div>
<div class="section" id="ID188">
<h3>Type Constraints in Action<a class="headerlink" href="Generics.html#ID188" title="Permalink to this headline">¶</a></h3>
<p>Here’s a nongeneric function called <code class="docutils literal notranslate"><span class="pre">findIndex(ofString:in:)</span></code>, which is given a <code class="docutils literal notranslate"><span class="pre">String</span></code> value to find and an array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values within which to find it. The <code class="docutils literal notranslate"><span class="pre">findIndex(ofString:in:)</span></code> function returns an optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> value, which will be the index of the first matching string in the array if it’s found, or <code class="docutils literal notranslate"><span class="pre">nil</span></code> if the string can’t be found:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">findIndex</span>(<span class="nv">ofString</span> <span class="nv">valueToFind</span>: <span class="nc">String</span>, <span class="nv">in</span> <span class="nv">array</span>: [<span class="nc">String</span>]) -&gt; <span class="nc">Int</span>? {
</li><li> <span class="k">for</span> (<span class="nv">index</span>, <span class="nv">value</span>) <span class="k">in</span> <span class="nv">array</span>.<span class="nv">enumerated</span>() {
</li><li> <span class="k">if</span> <span class="nv">value</span> == <span class="nv">valueToFind</span> {
</li><li> <span class="k">return</span> <span class="nv">index</span>
</li><li>        }
</li><li>    }
</li><li> <span class="k">return</span> <span class="k">nil</span>
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">findIndex(ofString:in:)</span></code> function can be used to find a string value in an array of strings:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">strings</span> = [<span class="s">"cat"</span>, <span class="s">"dog"</span>, <span class="s">"llama"</span>, <span class="s">"parakeet"</span>, <span class="s">"terrapin"</span>]
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">foundIndex</span> = <span class="nv">findIndex</span>(<span class="nv">ofString</span>: <span class="s">"llama"</span>, <span class="nv">in</span>: <span class="nv">strings</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"The index of llama is </span>\<span class="p">(</span><span class="nv">foundIndex</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Prints "The index of llama is 2"</span>
</li></ol></div></div></div>
<p>The principle of finding the index of a value in an array isn’t useful only for strings, however. You can write the same functionality as a generic function by replacing any mention of strings with values of some type <code class="docutils literal notranslate"><span class="pre">T</span></code> instead.</p>
<p>Here’s how you might expect a generic version of <code class="docutils literal notranslate"><span class="pre">findIndex(ofString:in:)</span></code>, called <code class="docutils literal notranslate"><span class="pre">findIndex(of:in:)</span></code>, to be written. Note that the return type of this function is still <code class="docutils literal notranslate"><span class="pre">Int?</span></code>, because the function returns an optional index number, not an optional value from the array. Be warned, though—this function doesn’t compile, for reasons explained after the example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">findIndex</span>&lt;<span class="nv">T</span>&gt;(<span class="nv">of</span> <span class="nv">valueToFind</span>: <span class="nc">T</span>, <span class="nv">in</span> <span class="nv">array</span>:[<span class="nc">T</span>]) -&gt; <span class="nc">Int</span>? {
</li><li> <span class="k">for</span> (<span class="nv">index</span>, <span class="nv">value</span>) <span class="k">in</span> <span class="nv">array</span>.<span class="nv">enumerated</span>() {
</li><li> <span class="k">if</span> <span class="nv">value</span> == <span class="nv">valueToFind</span> {
</li><li> <span class="k">return</span> <span class="nv">index</span>
</li><li>        }
</li><li>    }
</li><li> <span class="k">return</span> <span class="k">nil</span>
</li><li>}
</li></ol></div></div></div>
<p>This function doesn’t compile as written above. The problem lies with the equality check, “<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">value</span> <span class="pre">==</span> <span class="pre">valueToFind</span></code>”. Not every type in Swift can be compared with the equal to operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>). If you create your own class or structure to represent a complex data model, for example, then the meaning of “equal to” for that class or structure isn’t something that Swift can guess for you. Because of this, it isn’t possible to guarantee that this code will work for <em>every</em> possible type <code class="docutils literal notranslate"><span class="pre">T</span></code>, and an appropriate error is reported when you try to compile the code.</p>
<p>All is not lost, however. The Swift standard library defines a protocol called <code class="docutils literal notranslate"><span class="pre">Equatable</span></code>, which requires any conforming type to implement the equal to operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) and the not equal to operator (<code class="docutils literal notranslate"><span class="pre">!=</span></code>) to compare any two values of that type. All of Swift’s standard types automatically support the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol.</p>
<p>Any type that is <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> can be used safely with the <code class="docutils literal notranslate"><span class="pre">findIndex(of:in:)</span></code> function, because it’s guaranteed to support the equal to operator. To express this fact, you write a type constraint of <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> as part of the type parameter’s definition when you define the function:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">findIndex</span>&lt;<span class="nv">T</span>: <span class="nc">Equatable</span>&gt;(<span class="nv">of</span> <span class="nv">valueToFind</span>: <span class="nc">T</span>, <span class="nv">in</span> <span class="nv">array</span>:[<span class="nc">T</span>]) -&gt; <span class="nc">Int</span>? {
</li><li> <span class="k">for</span> (<span class="nv">index</span>, <span class="nv">value</span>) <span class="k">in</span> <span class="nv">array</span>.<span class="nv">enumerated</span>() {
</li><li> <span class="k">if</span> <span class="nv">value</span> == <span class="nv">valueToFind</span> {
</li><li> <span class="k">return</span> <span class="nv">index</span>
</li><li>        }
</li><li>    }
</li><li> <span class="k">return</span> <span class="k">nil</span>
</li><li>}
</li></ol></div></div></div>
<p>The single type parameter for <code class="docutils literal notranslate"><span class="pre">findIndex(of:in:)</span></code> is written as <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">Equatable</span></code>, which means “any type <code class="docutils literal notranslate"><span class="pre">T</span></code> that conforms to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol.”</p>
<p>The <code class="docutils literal notranslate"><span class="pre">findIndex(of:in:)</span></code> function now compiles successfully and can be used with any type that is <code class="docutils literal notranslate"><span class="pre">Equatable</span></code>, such as <code class="docutils literal notranslate"><span class="pre">Double</span></code> or <code class="docutils literal notranslate"><span class="pre">String</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">doubleIndex</span> = <span class="nv">findIndex</span>(<span class="nv">of</span>: <span class="m">9.3</span>, <span class="nv">in</span>: [<span class="m">3.14159</span>, <span class="m">0.1</span>, <span class="m">0.25</span>])
</li><li><span class="c">// doubleIndex is an optional Int with no value, because 9.3 isn't in the array</span>
</li><li><span class="k">let</span> <span class="nv">stringIndex</span> = <span class="nv">findIndex</span>(<span class="nv">of</span>: <span class="s">"Andrea"</span>, <span class="nv">in</span>: [<span class="s">"Mike"</span>, <span class="s">"Malcolm"</span>, <span class="s">"Andrea"</span>])
</li><li><span class="c">// stringIndex is an optional Int containing a value of 2</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID189">
<h2>Associated Types<a class="headerlink" href="Generics.html#ID189" title="Permalink to this headline">¶</a></h2>
<p>When defining a protocol, it’s sometimes useful to declare one or more associated types as part of the protocol’s definition. An <em>associated type</em> gives a placeholder name to a type that is used as part of the protocol. The actual type to use for that associated type isn’t specified until the protocol is adopted. Associated types are specified with the <code class="docutils literal notranslate"><span class="pre">associatedtype</span></code> keyword.</p>
<div class="section" id="ID190">
<h3>Associated Types in Action<a class="headerlink" href="Generics.html#ID190" title="Permalink to this headline">¶</a></h3>
<p>Here’s an example of a protocol called <code class="docutils literal notranslate"><span class="pre">Container</span></code>, which declares an associated type called <code class="docutils literal notranslate"><span class="pre">Item</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Container</span> {
</li><li> <span class="k">associatedtype</span> <span class="nv">Item</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">append</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Item</span>)
</li><li> <span class="k">var</span> <span class="nv">count</span>: <span class="nc">Int</span> { <span class="k">get</span> }
</li><li> <span class="k">subscript</span>(<span class="nv">i</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Item</span> { <span class="k">get</span> }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol defines three required capabilities that any container must provide:</p>
<ul class="simple">
<li>It must be possible to add a new item to the container with an <code class="docutils literal notranslate"><span class="pre">append(_:)</span></code> method.</li>
<li>It must be possible to access a count of the items in the container through a <code class="docutils literal notranslate"><span class="pre">count</span></code> property that returns an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value.</li>
<li>It must be possible to retrieve each item in the container with a subscript that takes an <code class="docutils literal notranslate"><span class="pre">Int</span></code> index value.</li>
</ul>
<p>This protocol doesn’t specify how the items in the container should be stored or what type they’re allowed to be. The protocol only specifies the three bits of functionality that any type must provide in order to be considered a <code class="docutils literal notranslate"><span class="pre">Container</span></code>. A conforming type can provide additional functionality, as long as it satisfies these three requirements.</p>
<p>Any type that conforms to the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol must be able to specify the type of values it stores. Specifically, it must ensure that only items of the right type are added to the container, and it must be clear about the type of the items returned by its subscript.</p>
<p>To define these requirements, the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol needs a way to refer to the type of the elements that a container will hold, without knowing what that type is for a specific container. The <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol needs to specify that any value passed to the <code class="docutils literal notranslate"><span class="pre">append(_:)</span></code> method must have the same type as the container’s element type, and that the value returned by the container’s subscript will be of the same type as the container’s element type.</p>
<p>To achieve this, the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol declares an associated type called <code class="docutils literal notranslate"><span class="pre">Item</span></code>, written as <code class="docutils literal notranslate"><span class="pre">associatedtype</span> <span class="pre">Item</span></code>. The protocol doesn’t define what <code class="docutils literal notranslate"><span class="pre">Item</span></code> is—that information is left for any conforming type to provide. Nonetheless, the <code class="docutils literal notranslate"><span class="pre">Item</span></code> alias provides a way to refer to the type of the items in a <code class="docutils literal notranslate"><span class="pre">Container</span></code>, and to define a type for use with the <code class="docutils literal notranslate"><span class="pre">append(_:)</span></code> method and subscript, to ensure that the expected behavior of any <code class="docutils literal notranslate"><span class="pre">Container</span></code> is enforced.</p>
<p>Here’s a version of the nongeneric <code class="docutils literal notranslate"><span class="pre">IntStack</span></code> type from <a class="reference internal" href="Generics.html#ID184"><span class="std std-ref">Generic Types</span></a> above, adapted to conform to the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">IntStack</span>: <span class="nc">Container</span> {
</li><li> <span class="c">// original IntStack implementation</span>
</li><li> <span class="k">var</span> <span class="nv">items</span> = [<span class="nv">Int</span>]()
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">push</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Int</span>) {
</li><li> <span class="nv">items</span>.<span class="nv">append</span>(<span class="nv">item</span>)
</li><li>    }
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">pop</span>() -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">items</span>.<span class="nv">removeLast</span>()
</li><li>    }
</li><li> <span class="c">// conformance to the Container protocol</span>
</li><li> <span class="k">typealias</span> <span class="nv">Item</span> = <span class="nc">Int</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">append</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Int</span>) {
</li><li> <span class="k">self</span>.<span class="nv">push</span>(<span class="nv">item</span>)
</li><li>    }
</li><li> <span class="k">var</span> <span class="nv">count</span>: <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">items</span>.<span class="nv">count</span>
</li><li>    }
</li><li> <span class="k">subscript</span>(<span class="nv">i</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">items</span>[<span class="nv">i</span>]
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">IntStack</span></code> type implements all three of the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol’s requirements, and in each case wraps part of the <code class="docutils literal notranslate"><span class="pre">IntStack</span></code> type’s existing functionality to satisfy these requirements.</p>
<p>Moreover, <code class="docutils literal notranslate"><span class="pre">IntStack</span></code> specifies that for this implementation of <code class="docutils literal notranslate"><span class="pre">Container</span></code>, the appropriate <code class="docutils literal notranslate"><span class="pre">Item</span></code> to use is a type of <code class="docutils literal notranslate"><span class="pre">Int</span></code>. The definition of <code class="docutils literal notranslate"><span class="pre">typealias</span> <span class="pre">Item</span> <span class="pre">=</span> <span class="pre">Int</span></code> turns the abstract type of <code class="docutils literal notranslate"><span class="pre">Item</span></code> into a concrete type of <code class="docutils literal notranslate"><span class="pre">Int</span></code> for this implementation of the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol.</p>
<p>Thanks to Swift’s type inference, you don’t actually need to declare a concrete <code class="docutils literal notranslate"><span class="pre">Item</span></code> of <code class="docutils literal notranslate"><span class="pre">Int</span></code> as part of the definition of <code class="docutils literal notranslate"><span class="pre">IntStack</span></code>. Because <code class="docutils literal notranslate"><span class="pre">IntStack</span></code> conforms to all of the requirements of the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol, Swift can infer the appropriate <code class="docutils literal notranslate"><span class="pre">Item</span></code> to use, simply by looking at the type of the <code class="docutils literal notranslate"><span class="pre">append(_:)</span></code> method’s <code class="docutils literal notranslate"><span class="pre">item</span></code> parameter and the return type of the subscript. Indeed, if you delete the <code class="docutils literal notranslate"><span class="pre">typealias</span> <span class="pre">Item</span> <span class="pre">=</span> <span class="pre">Int</span></code> line from the code above, everything still works, because it’s clear what type should be used for <code class="docutils literal notranslate"><span class="pre">Item</span></code>.</p>
<p>You can also make the generic <code class="docutils literal notranslate"><span class="pre">Stack</span></code> type conform to the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Stack</span>&lt;<span class="nv">Element</span>&gt;: <span class="nc">Container</span> {
</li><li> <span class="c">// original Stack&lt;Element&gt; implementation</span>
</li><li> <span class="k">var</span> <span class="nv">items</span> = [<span class="nv">Element</span>]()
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">push</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Element</span>) {
</li><li> <span class="nv">items</span>.<span class="nv">append</span>(<span class="nv">item</span>)
</li><li>    }
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">pop</span>() -&gt; <span class="nc">Element</span> {
</li><li> <span class="k">return</span> <span class="nv">items</span>.<span class="nv">removeLast</span>()
</li><li>    }
</li><li> <span class="c">// conformance to the Container protocol</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">append</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Element</span>) {
</li><li> <span class="k">self</span>.<span class="nv">push</span>(<span class="nv">item</span>)
</li><li>    }
</li><li> <span class="k">var</span> <span class="nv">count</span>: <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">items</span>.<span class="nv">count</span>
</li><li>    }
</li><li> <span class="k">subscript</span>(<span class="nv">i</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Element</span> {
</li><li> <span class="k">return</span> <span class="nv">items</span>[<span class="nv">i</span>]
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This time, the type parameter <code class="docutils literal notranslate"><span class="pre">Element</span></code> is used as the type of the <code class="docutils literal notranslate"><span class="pre">append(_:)</span></code> method’s <code class="docutils literal notranslate"><span class="pre">item</span></code> parameter and the return type of the subscript. Swift can therefore infer that <code class="docutils literal notranslate"><span class="pre">Element</span></code> is the appropriate type to use as the <code class="docutils literal notranslate"><span class="pre">Item</span></code> for this particular container.</p>
</div>
<div class="section" id="ID191">
<h3>Extending an Existing Type to Specify an Associated Type<a class="headerlink" href="Generics.html#ID191" title="Permalink to this headline">¶</a></h3>
<p>You can extend an existing type to add conformance to a protocol, as described in <a class="reference internal" href="Protocols.html#ID277"><span class="std std-ref">Adding Protocol Conformance with an Extension</span></a>. This includes a protocol with an associated type.</p>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">Array</span></code> type already provides an <code class="docutils literal notranslate"><span class="pre">append(_:)</span></code> method, a <code class="docutils literal notranslate"><span class="pre">count</span></code> property, and a subscript with an <code class="docutils literal notranslate"><span class="pre">Int</span></code> index to retrieve its elements. These three capabilities match the requirements of the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol. This means that you can extend <code class="docutils literal notranslate"><span class="pre">Array</span></code> to conform to the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol simply by declaring that <code class="docutils literal notranslate"><span class="pre">Array</span></code> adopts the protocol. You do this with an empty extension, as described in <a class="reference internal" href="Protocols.html#ID278"><span class="std std-ref">Declaring Protocol Adoption with an Extension</span></a>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">Container</span> {}
</li></ol></div></div></div>
<p>Array’s existing <code class="docutils literal notranslate"><span class="pre">append(_:)</span></code> method and subscript enable Swift to infer the appropriate type to use for <code class="docutils literal notranslate"><span class="pre">Item</span></code>, just as for the generic <code class="docutils literal notranslate"><span class="pre">Stack</span></code> type above. After defining this extension, you can use any <code class="docutils literal notranslate"><span class="pre">Array</span></code> as a <code class="docutils literal notranslate"><span class="pre">Container</span></code>.</p>
</div>
<div class="section" id="ID560">
<h3>Adding Constraints to an Associated Type<a class="headerlink" href="Generics.html#ID560" title="Permalink to this headline">¶</a></h3>
<p>You can add type constraints to an associated type in a protocol to require that conforming types satisfy those constraints. For example, the following code defines a version of <code class="docutils literal notranslate"><span class="pre">Container</span></code> that requires the items in the container to be equatable.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Container</span> {
</li><li> <span class="k">associatedtype</span> <span class="nv">Item</span>: <span class="nc">Equatable</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">append</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Item</span>)
</li><li> <span class="k">var</span> <span class="nv">count</span>: <span class="nc">Int</span> { <span class="k">get</span> }
</li><li> <span class="k">subscript</span>(<span class="nv">i</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Item</span> { <span class="k">get</span> }
</li><li>}
</li></ol></div></div></div>
<p>To conform to this version of <code class="docutils literal notranslate"><span class="pre">Container</span></code>, the container’s <code class="docutils literal notranslate"><span class="pre">Item</span></code> type has to conform to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol.</p>
</div>
<div class="section" id="ID575">
<h3>Using a Protocol in Its Associated Type’s Constraints<a class="headerlink" href="Generics.html#ID575" title="Permalink to this headline">¶</a></h3>
<p>A protocol can appear as part of its own requirements. For example, here’s a protocol that refines the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol, adding the requirement of a <code class="docutils literal notranslate"><span class="pre">suffix(_:)</span></code> method. The <code class="docutils literal notranslate"><span class="pre">suffix(_:)</span></code> method returns a given number of elements from the end of the container, storing them in an instance of the <code class="docutils literal notranslate"><span class="pre">Suffix</span></code> type.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SuffixableContainer</span>: <span class="nc">Container</span> {
</li><li> <span class="k">associatedtype</span> <span class="nv">Suffix</span>: <span class="nc">SuffixableContainer</span> <span class="k">where</span> <span class="nc">Suffix</span>.<span class="nc">Item</span> == <span class="nc">Item</span>
</li><li> <span class="k">func</span> <span class="nv">suffix</span>(<span class="k">_</span> <span class="nv">size</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Suffix</span>
</li><li>}
</li></ol></div></div></div>
<p>In this protocol, <code class="docutils literal notranslate"><span class="pre">Suffix</span></code> is an associated type, like the <code class="docutils literal notranslate"><span class="pre">Item</span></code> type in the <code class="docutils literal notranslate"><span class="pre">Container</span></code> example above. <code class="docutils literal notranslate"><span class="pre">Suffix</span></code> has two constraints: It must conform to the <code class="docutils literal notranslate"><span class="pre">SuffixableContainer</span></code> protocol (the protocol currently being defined), and its <code class="docutils literal notranslate"><span class="pre">Item</span></code> type must be the same as the container’s <code class="docutils literal notranslate"><span class="pre">Item</span></code> type. The constraint on <code class="docutils literal notranslate"><span class="pre">Item</span></code> is a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause, which is discussed in <a class="reference internal" href="Generics.html#ID557"><span class="std std-ref">Associated Types with a Generic Where Clause</span></a> below.</p>
<p>Here’s an extension of the <code class="docutils literal notranslate"><span class="pre">Stack</span></code> type from <a class="reference internal" href="AutomaticReferenceCounting.html#ID56"><span class="std std-ref">Strong Reference Cycles for Closures</span></a> above that adds conformance to the <code class="docutils literal notranslate"><span class="pre">SuffixableContainer</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Stack</span>: <span class="nc">SuffixableContainer</span> {
</li><li> <span class="k">func</span> <span class="nv">suffix</span>(<span class="k">_</span> <span class="nv">size</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Stack</span> {
</li><li> <span class="k">var</span> <span class="nv">result</span> = <span class="nv">Stack</span>()
</li><li> <span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> (<span class="nv">count</span>-<span class="nv">size</span>)..&lt;<span class="nv">count</span> {
</li><li> <span class="nv">result</span>.<span class="nv">append</span>(<span class="k">self</span>[<span class="nv">index</span>])
</li><li>        }
</li><li> <span class="k">return</span> <span class="nv">result</span>
</li><li>    }
</li><li> <span class="c">// Inferred that Suffix is Stack.</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">stackOfInts</span> = <span class="nv">Stack</span>&lt;<span class="nc">Int</span>&gt;()
</li><li><span class="nv">stackOfInts</span>.<span class="nv">append</span>(<span class="m">10</span>)
</li><li><span class="nv">stackOfInts</span>.<span class="nv">append</span>(<span class="m">20</span>)
</li><li><span class="nv">stackOfInts</span>.<span class="nv">append</span>(<span class="m">30</span>)
</li><li><span class="k">let</span> <span class="nv">suffix</span> = <span class="nv">stackOfInts</span>.<span class="nv">suffix</span>(<span class="m">2</span>)
</li><li><span class="c">// suffix contains 20 and 30</span>
</li></ol></div></div></div>
<p>In the example above, the <code class="docutils literal notranslate"><span class="pre">Suffix</span></code> associated type for <code class="docutils literal notranslate"><span class="pre">Stack</span></code> is also <code class="docutils literal notranslate"><span class="pre">Stack</span></code>, so the suffix operation on <code class="docutils literal notranslate"><span class="pre">Stack</span></code> returns another <code class="docutils literal notranslate"><span class="pre">Stack</span></code>. Alternatively, a type that conforms to <code class="docutils literal notranslate"><span class="pre">SuffixableContainer</span></code> can have a <code class="docutils literal notranslate"><span class="pre">Suffix</span></code> type that’s different from itself—meaning the suffix operation can return a different type. For example, here’s an extension to the nongeneric <code class="docutils literal notranslate"><span class="pre">IntStack</span></code> type that adds <code class="docutils literal notranslate"><span class="pre">SuffixableContainer</span></code> conformance, using <code class="docutils literal notranslate"><span class="pre">Stack&lt;Int&gt;</span></code> as its suffix type instead of <code class="docutils literal notranslate"><span class="pre">IntStack</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">IntStack</span>: <span class="nc">SuffixableContainer</span> {
</li><li> <span class="k">func</span> <span class="nv">suffix</span>(<span class="k">_</span> <span class="nv">size</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Stack</span>&lt;<span class="nc">Int</span>&gt; {
</li><li> <span class="k">var</span> <span class="nv">result</span> = <span class="nv">Stack</span>&lt;<span class="nc">Int</span>&gt;()
</li><li> <span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> (<span class="nv">count</span>-<span class="nv">size</span>)..&lt;<span class="nv">count</span> {
</li><li> <span class="nv">result</span>.<span class="nv">append</span>(<span class="k">self</span>[<span class="nv">index</span>])
</li><li>        }
</li><li> <span class="k">return</span> <span class="nv">result</span>
</li><li>    }
</li><li> <span class="c">// Inferred that Suffix is Stack&lt;Int&gt;.</span>
</li><li>}
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID192">
<h2>Generic Where Clauses<a class="headerlink" href="Generics.html#ID192" title="Permalink to this headline">¶</a></h2>
<p>Type constraints, as described in <a class="reference internal" href="Generics.html#ID186"><span class="std std-ref">Type Constraints</span></a>, enable you to define requirements on the type parameters associated with a generic function, subscript, or type.</p>
<p>It can also be useful to define requirements for associated types. You do this by defining a <em>generic where clause</em>. A generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause enables you to require that an associated type must conform to a certain protocol, or that certain type parameters and associated types must be the same. A generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause starts with the <code class="docutils literal notranslate"><span class="pre">where</span></code> keyword, followed by constraints for associated types or equality relationships between types and associated types. You write a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause right before the opening curly brace of a type or function’s body.</p>
<p>The example below defines a generic function called <code class="docutils literal notranslate"><span class="pre">allItemsMatch</span></code>, which checks to see if two <code class="docutils literal notranslate"><span class="pre">Container</span></code> instances contain the same items in the same order. The function returns a Boolean value of <code class="docutils literal notranslate"><span class="pre">true</span></code> if all items match and a value of <code class="docutils literal notranslate"><span class="pre">false</span></code> if they don’t.</p>
<p>The two containers to be checked don’t have to be the same type of container (although they can be), but they do have to hold the same type of items. This requirement is expressed through a combination of type constraints and a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">allItemsMatch</span>&lt;<span class="nv">C1</span>: <span class="nc">Container</span>, <span class="nv">C2</span>: <span class="nc">Container</span>&gt;
</li><li>    (<span class="k">_</span> <span class="nv">someContainer</span>: <span class="nc">C1</span>, <span class="k">_</span> <span class="nv">anotherContainer</span>: <span class="nc">C2</span>) -&gt; <span class="nc">Bool</span>
</li><li> <span class="k">where</span> <span class="nc">C1</span>.<span class="nc">Item</span> == <span class="nc">C2</span>.<span class="nc">Item</span>, <span class="nc">C1</span>.<span class="nc">Item</span>: <span class="nc">Equatable</span> {
</li><li>
</li><li> <span class="c">// Check that both containers contain the same number of items.</span>
</li><li> <span class="k">if</span> <span class="nv">someContainer</span>.<span class="nv">count</span> != <span class="nv">anotherContainer</span>.<span class="nv">count</span> {
</li><li> <span class="k">return</span> <span class="k">false</span>
</li><li>        }
</li><li>
</li><li> <span class="c">// Check each pair of items to see if they're equivalent.</span>
</li><li> <span class="k">for</span> <span class="nv">i</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="nv">someContainer</span>.<span class="nv">count</span> {
</li><li> <span class="k">if</span> <span class="nv">someContainer</span>[<span class="nv">i</span>] != <span class="nv">anotherContainer</span>[<span class="nv">i</span>] {
</li><li> <span class="k">return</span> <span class="k">false</span>
</li><li>            }
</li><li>        }
</li><li>
</li><li> <span class="c">// All items match, so return true.</span>
</li><li> <span class="k">return</span> <span class="k">true</span>
</li><li>}
</li></ol></div></div></div>
<p>This function takes two arguments called <code class="docutils literal notranslate"><span class="pre">someContainer</span></code> and <code class="docutils literal notranslate"><span class="pre">anotherContainer</span></code>. The <code class="docutils literal notranslate"><span class="pre">someContainer</span></code> argument is of type <code class="docutils literal notranslate"><span class="pre">C1</span></code>, and the <code class="docutils literal notranslate"><span class="pre">anotherContainer</span></code> argument is of type <code class="docutils literal notranslate"><span class="pre">C2</span></code>. Both <code class="docutils literal notranslate"><span class="pre">C1</span></code> and <code class="docutils literal notranslate"><span class="pre">C2</span></code> are type parameters for two container types to be determined when the function is called.</p>
<p>The following requirements are placed on the function’s two type parameters:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">C1</span></code> must conform to the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol (written as <code class="docutils literal notranslate"><span class="pre">C1:</span> <span class="pre">Container</span></code>).</li>
<li><code class="docutils literal notranslate"><span class="pre">C2</span></code> must also conform to the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol (written as <code class="docutils literal notranslate"><span class="pre">C2:</span> <span class="pre">Container</span></code>).</li>
<li>The <code class="docutils literal notranslate"><span class="pre">Item</span></code> for <code class="docutils literal notranslate"><span class="pre">C1</span></code> must be the same as the <code class="docutils literal notranslate"><span class="pre">Item</span></code> for <code class="docutils literal notranslate"><span class="pre">C2</span></code> (written as <code class="docutils literal notranslate"><span class="pre">C1.Item</span> <span class="pre">==</span> <span class="pre">C2.Item</span></code>).</li>
<li>The <code class="docutils literal notranslate"><span class="pre">Item</span></code> for <code class="docutils literal notranslate"><span class="pre">C1</span></code> must conform to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol (written as <code class="docutils literal notranslate"><span class="pre">C1.Item:</span> <span class="pre">Equatable</span></code>).</li>
</ul>
<p>The first and second requirements are defined in the function’s type parameter list, and the third and fourth requirements are defined in the function’s generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause.</p>
<p>These requirements mean:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">someContainer</span></code> is a container of type <code class="docutils literal notranslate"><span class="pre">C1</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">anotherContainer</span></code> is a container of type <code class="docutils literal notranslate"><span class="pre">C2</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">someContainer</span></code> and <code class="docutils literal notranslate"><span class="pre">anotherContainer</span></code> contain the same type of items.</li>
<li>The items in <code class="docutils literal notranslate"><span class="pre">someContainer</span></code> can be checked with the not equal operator (<code class="docutils literal notranslate"><span class="pre">!=</span></code>) to see if they’re different from each other.</li>
</ul>
<p>The third and fourth requirements combine to mean that the items in <code class="docutils literal notranslate"><span class="pre">anotherContainer</span></code> can <em>also</em> be checked with the <code class="docutils literal notranslate"><span class="pre">!=</span></code> operator, because they’re exactly the same type as the items in <code class="docutils literal notranslate"><span class="pre">someContainer</span></code>.</p>
<p>These requirements enable the <code class="docutils literal notranslate"><span class="pre">allItemsMatch(_:_:)</span></code> function to compare the two containers, even if they’re of a different container type.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">allItemsMatch(_:_:)</span></code> function starts by checking that both containers contain the same number of items. If they contain a different number of items, there’s no way that they can match, and the function returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>After making this check, the function iterates over all of the items in <code class="docutils literal notranslate"><span class="pre">someContainer</span></code> with a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop and the half-open range operator (<code class="docutils literal notranslate"><span class="pre">..&lt;</span></code>). For each item, the function checks whether the item from <code class="docutils literal notranslate"><span class="pre">someContainer</span></code> isn’t equal to the corresponding item in <code class="docutils literal notranslate"><span class="pre">anotherContainer</span></code>. If the two items aren’t equal, then the two containers don’t match, and the function returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>If the loop finishes without finding a mismatch, the two containers match, and the function returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Here’s how the <code class="docutils literal notranslate"><span class="pre">allItemsMatch(_:_:)</span></code> function looks in action:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">stackOfStrings</span> = <span class="nv">Stack</span>&lt;<span class="nc">String</span>&gt;()
</li><li><span class="nv">stackOfStrings</span>.<span class="nv">push</span>(<span class="s">"uno"</span>)
</li><li><span class="nv">stackOfStrings</span>.<span class="nv">push</span>(<span class="s">"dos"</span>)
</li><li><span class="nv">stackOfStrings</span>.<span class="nv">push</span>(<span class="s">"tres"</span>)
</li><li>
</li><li><span class="k">var</span> <span class="nv">arrayOfStrings</span> = [<span class="s">"uno"</span>, <span class="s">"dos"</span>, <span class="s">"tres"</span>]
</li><li>
</li><li><span class="k">if</span> <span class="nv">allItemsMatch</span>(<span class="nv">stackOfStrings</span>, <span class="nv">arrayOfStrings</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"All items match."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Not all items match."</span>)
</li><li>}
</li><li><span class="c">// Prints "All items match."</span>
</li></ol></div></div></div>
<p>The example above creates a <code class="docutils literal notranslate"><span class="pre">Stack</span></code> instance to store <code class="docutils literal notranslate"><span class="pre">String</span></code> values, and pushes three strings onto the stack. The example also creates an <code class="docutils literal notranslate"><span class="pre">Array</span></code> instance initialized with an array literal containing the same three strings as the stack. Even though the stack and the array are of a different type, they both conform to the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol, and both contain the same type of values. You can therefore call the <code class="docutils literal notranslate"><span class="pre">allItemsMatch(_:_:)</span></code> function with these two containers as its arguments. In the example above, the <code class="docutils literal notranslate"><span class="pre">allItemsMatch(_:_:)</span></code> function correctly reports that all of the items in the two containers match.</p>
</div>
<div class="section" id="ID553">
<h2>Extensions with a Generic Where Clause<a class="headerlink" href="Generics.html#ID553" title="Permalink to this headline">¶</a></h2>
<p>You can also use a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause as part of an extension. The example below extends the generic <code class="docutils literal notranslate"><span class="pre">Stack</span></code> structure from the previous examples to add an <code class="docutils literal notranslate"><span class="pre">isTop(_:)</span></code> method.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Stack</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">Equatable</span> {
</li><li> <span class="k">func</span> <span class="nv">isTop</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Element</span>) -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">guard</span> <span class="k">let</span> <span class="nv">topItem</span> = <span class="nv">items</span>.<span class="nv">last</span> <span class="k">else</span> {
</li><li> <span class="k">return</span> <span class="k">false</span>
</li><li>        }
</li><li> <span class="k">return</span> <span class="nv">topItem</span> == <span class="nv">item</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This new <code class="docutils literal notranslate"><span class="pre">isTop(_:)</span></code> method first checks that the stack isn’t empty, and then compares the given item against the stack’s topmost item. If you tried to do this without a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause, you would have a problem: The implementation of <code class="docutils literal notranslate"><span class="pre">isTop(_:)</span></code> uses the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator, but the definition of <code class="docutils literal notranslate"><span class="pre">Stack</span></code> doesn’t require its items to be equatable, so using the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator results in a compile-time error. Using a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause lets you add a new requirement to the extension, so that the extension adds the <code class="docutils literal notranslate"><span class="pre">isTop(_:)</span></code> method only when the items in the stack are equatable.</p>
<p>Here’s how the <code class="docutils literal notranslate"><span class="pre">isTop(_:)</span></code> method looks in action:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">stackOfStrings</span>.<span class="nv">isTop</span>(<span class="s">"tres"</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Top element is tres."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Top element is something else."</span>)
</li><li>}
</li><li><span class="c">// Prints "Top element is tres."</span>
</li></ol></div></div></div>
<p>If you try to call the <code class="docutils literal notranslate"><span class="pre">isTop(_:)</span></code> method on a stack whose elements aren’t equatable, you’ll get a compile-time error.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">NotEquatable</span> { }
</li><li><span class="k">var</span> <span class="nv">notEquatableStack</span> = <span class="nv">Stack</span>&lt;<span class="nc">NotEquatable</span>&gt;()
</li><li><span class="k">let</span> <span class="nv">notEquatableValue</span> = <span class="nv">NotEquatable</span>()
</li><li><span class="nv">notEquatableStack</span>.<span class="nv">push</span>(<span class="nv">notEquatableValue</span>)
</li><li><span class="nv">notEquatableStack</span>.<span class="nv">isTop</span>(<span class="nv">notEquatableValue</span>)  <span class="c">// Error</span>
</li></ol></div></div></div>
<p>You can use a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause with extensions to a protocol. The example below extends the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol from the previous examples to add a <code class="docutils literal notranslate"><span class="pre">startsWith(_:)</span></code> method.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Container</span> <span class="k">where</span> <span class="nc">Item</span>: <span class="nc">Equatable</span> {
</li><li> <span class="k">func</span> <span class="nv">startsWith</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Item</span>) -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">return</span> <span class="nv">count</span> &gt;= <span class="m">1</span> &amp;&amp; <span class="k">self</span>[<span class="m">0</span>] == <span class="nv">item</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">startsWith(_:)</span></code> method first makes sure that the container has at least one item, and then it checks whether the first item in the container matches the given item. This new <code class="docutils literal notranslate"><span class="pre">startsWith(_:)</span></code> method can be used with any type that conforms to the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol, including the stacks and arrays used above, as long as the container’s items are equatable.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> [<span class="m">9</span>, <span class="m">9</span>, <span class="m">9</span>].<span class="nv">startsWith</span>(<span class="m">42</span>) {
</li><li> <span class="nv">print</span>(<span class="s">"Starts with 42."</span>)
</li><li>} <span class="k">else</span> {
</li><li> <span class="nv">print</span>(<span class="s">"Starts with something else."</span>)
</li><li>}
</li><li><span class="c">// Prints "Starts with something else."</span>
</li></ol></div></div></div>
<p>The generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause in the example above requires <code class="docutils literal notranslate"><span class="pre">Item</span></code> to conform to a protocol, but you can also write a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clauses that require <code class="docutils literal notranslate"><span class="pre">Item</span></code> to be a specific type. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Container</span> <span class="k">where</span> <span class="nc">Item</span> == <span class="nc">Double</span> {
</li><li> <span class="k">func</span> <span class="nv">average</span>() -&gt; <span class="nc">Double</span> {
</li><li> <span class="k">var</span> <span class="nv">sum</span> = <span class="m">0.0</span>
</li><li> <span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="nv">count</span> {
</li><li> <span class="nv">sum</span> += <span class="k">self</span>[<span class="nv">index</span>]
</li><li>        }
</li><li> <span class="k">return</span> <span class="nv">sum</span> / <span class="nv">Double</span>(<span class="nv">count</span>)
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>([<span class="m">1260.0</span>, <span class="m">1200.0</span>, <span class="m">98.6</span>, <span class="m">37.0</span>].<span class="nv">average</span>())
</li><li><span class="c">// Prints "648.9"</span>
</li></ol></div></div></div>
<p>This example adds an <code class="docutils literal notranslate"><span class="pre">average()</span></code> method to containers whose <code class="docutils literal notranslate"><span class="pre">Item</span></code> type is <code class="docutils literal notranslate"><span class="pre">Double</span></code>. It iterates over the items in the container to add them up, and divides by the container’s count to compute the average. It explicitly converts the count from <code class="docutils literal notranslate"><span class="pre">Int</span></code> to <code class="docutils literal notranslate"><span class="pre">Double</span></code> to be able to do floating-point division.</p>
<p>You can include multiple requirements in a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause that is part of an extension, just like you can for a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause that you write elsewhere. Separate each requirement in the list with a comma.</p>
</div>
<div class="section" id="ID557">
<h2>Associated Types with a Generic Where Clause<a class="headerlink" href="Generics.html#ID557" title="Permalink to this headline">¶</a></h2>
<p>You can include a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause on an associated type. For example, suppose you want to make a version of <code class="docutils literal notranslate"><span class="pre">Container</span></code> that includes an iterator, like what the <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> protocol uses in the standard library. Here’s how you write that:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Container</span> {
</li><li> <span class="k">associatedtype</span> <span class="nv">Item</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">append</span>(<span class="k">_</span> <span class="nv">item</span>: <span class="nc">Item</span>)
</li><li> <span class="k">var</span> <span class="nv">count</span>: <span class="nc">Int</span> { <span class="k">get</span> }
</li><li> <span class="k">subscript</span>(<span class="nv">i</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Item</span> { <span class="k">get</span> }
</li><li>
</li><li> <span class="k">associatedtype</span> <span class="nv">Iterator</span>: <span class="nc">IteratorProtocol</span> <span class="k">where</span> <span class="nc">Iterator</span>.<span class="nc">Element</span> == <span class="nc">Item</span>
</li><li> <span class="k">func</span> <span class="nv">makeIterator</span>() -&gt; <span class="nc">Iterator</span>
</li><li>}
</li></ol></div></div></div>
<p>The generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause on <code class="docutils literal notranslate"><span class="pre">Iterator</span></code> requires that the iterator must traverse over elements of the same item type as the container’s items, regardless of the iterator’s type. The <code class="docutils literal notranslate"><span class="pre">makeIterator()</span></code> function provides access to a container’s iterator.</p>
<p>For a protocol that inherits from another protocol, you add a constraint to an inherited associated type by including the generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause in the protocol declaration. For example, the following code declares a <code class="docutils literal notranslate"><span class="pre">ComparableContainer</span></code> protocol that requires <code class="docutils literal notranslate"><span class="pre">Item</span></code> to conform to <code class="docutils literal notranslate"><span class="pre">Comparable</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">ComparableContainer</span>: <span class="nc">Container</span> <span class="k">where</span> <span class="nc">Item</span>: <span class="nc">Comparable</span> { }
</li></ol></div></div></div>
</div>
<div class="section" id="ID558">
<h2>Generic Subscripts<a class="headerlink" href="Generics.html#ID558" title="Permalink to this headline">¶</a></h2>
<p>Subscripts can be generic, and they can include generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clauses. You write the placeholder type name inside angle brackets after <code class="docutils literal notranslate"><span class="pre">subscript</span></code>, and you write a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause right before the opening curly brace of the subscript’s body. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Container</span> {
</li><li> <span class="k">subscript</span>&lt;<span class="nv">Indices</span>: <span class="nc">Sequence</span>&gt;(<span class="nv">indices</span>: <span class="nc">Indices</span>) -&gt; [<span class="nc">Item</span>]
</li><li> <span class="k">where</span> <span class="nc">Indices</span>.<span class="nc">Iterator</span>.<span class="nc">Element</span> == <span class="nc">Int</span> {
</li><li> <span class="k">var</span> <span class="nv">result</span> = [<span class="nv">Item</span>]()
</li><li> <span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> <span class="nv">indices</span> {
</li><li> <span class="nv">result</span>.<span class="nv">append</span>(<span class="k">self</span>[<span class="nv">index</span>])
</li><li>            }
</li><li> <span class="k">return</span> <span class="nv">result</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This extension to the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol adds a subscript that takes a sequence of indices and returns an array containing the items at each given index. This generic subscript is constrained as follows:</p>
<ul class="simple">
<li>The generic parameter <code class="docutils literal notranslate"><span class="pre">Indices</span></code> in angle brackets has to be a type that conforms to the <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> protocol from the standard library.</li>
<li>The subscript takes a single parameter, <code class="docutils literal notranslate"><span class="pre">indices</span></code>, which is an instance of that <code class="docutils literal notranslate"><span class="pre">Indices</span></code> type.</li>
<li>The generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause requires that the iterator for the sequence must traverse over elements of type <code class="docutils literal notranslate"><span class="pre">Int</span></code>. This ensures that the indices in the sequence are the same type as the indices used for a container.</li>
</ul>
<p>Taken together, these constraints mean that the value passed for the <code class="docutils literal notranslate"><span class="pre">indices</span></code> parameter is a sequence of integers.</p>
</div>
</div><div class="section" id="automatic-reference-counting">
<h1>Automatic Reference Counting<a class="headerlink" href="AutomaticReferenceCounting.html#automatic-reference-counting" title="Permalink to this headline">¶</a></h1>
<p>Swift uses <em>Automatic Reference Counting</em> (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.</p>
<p>However, in a few cases ARC requires more information about the relationships between parts of your code in order to manage memory for you. This chapter describes those situations and shows how you enable ARC to manage all of your app’s memory. Using ARC in Swift is very similar to the approach described in <a class="reference external" href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC Release Notes</a> for using ARC with Objective-C.</p>
<p>Reference counting applies only to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.</p>
<div class="section" id="ID49">
<h2>How ARC Works<a class="headerlink" href="AutomaticReferenceCounting.html#ID49" title="Permalink to this headline">¶</a></h2>
<p>Every time you create a new instance of a class, ARC allocates a chunk of memory to store information about that instance. This memory holds information about the type of the instance, together with the values of any stored properties associated with that instance.</p>
<p>Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance so that the memory can be used for other purposes instead. This ensures that class instances do not take up space in memory when they are no longer needed.</p>
<p>However, if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance’s properties, or call that instance’s methods. Indeed, if you tried to access the instance, your app would most likely crash.</p>
<p>To make sure that instances don’t disappear while they are still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance. ARC will not deallocate an instance as long as at least one active reference to that instance still exists.</p>
<p>To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a <em>strong reference</em> to the instance. The reference is called a “strong” reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.</p>
</div>
<div class="section" id="ID50">
<h2>ARC in Action<a class="headerlink" href="AutomaticReferenceCounting.html#ID50" title="Permalink to this headline">¶</a></h2>
<p>Here’s an example of how Automatic Reference Counting works. This example starts with a simple class called <code class="docutils literal notranslate"><span class="pre">Person</span></code>, which defines a stored constant property called <code class="docutils literal notranslate"><span class="pre">name</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Person</span> {
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being initialized"</span>)
</li><li>    }
</li><li> <span class="k">deinit</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Person</span></code> class has an initializer that sets the instance’s <code class="docutils literal notranslate"><span class="pre">name</span></code> property and prints a message to indicate that initialization is underway. The <code class="docutils literal notranslate"><span class="pre">Person</span></code> class also has a deinitializer that prints a message when an instance of the class is deallocated.</p>
<p>The next code snippet defines three variables of type <code class="docutils literal notranslate"><span class="pre">Person?</span></code>, which are used to set up multiple references to a new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance in subsequent code snippets. Because these variables are of an optional type (<code class="docutils literal notranslate"><span class="pre">Person?</span></code>, not <code class="docutils literal notranslate"><span class="pre">Person</span></code>), they are automatically initialized with a value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, and do not currently reference a <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">reference1</span>: <span class="nc">Person</span>?
</li><li><span class="k">var</span> <span class="nv">reference2</span>: <span class="nc">Person</span>?
</li><li><span class="k">var</span> <span class="nv">reference3</span>: <span class="nc">Person</span>?
</li></ol></div></div></div>
<p>You can now create a new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance and assign it to one of these three variables:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reference1</span> = <span class="nv">Person</span>(<span class="nv">name</span>: <span class="s">"John Appleseed"</span>)
</li><li><span class="c">// Prints "John Appleseed is being initialized"</span>
</li></ol></div></div></div>
<p>Note that the message <code class="docutils literal notranslate"><span class="pre">"John</span> <span class="pre">Appleseed</span> <span class="pre">is</span> <span class="pre">being</span> <span class="pre">initialized"</span></code> is printed at the point that you call the <code class="docutils literal notranslate"><span class="pre">Person</span></code> class’s initializer. This confirms that initialization has taken place.</p>
<p>Because the new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance has been assigned to the <code class="docutils literal notranslate"><span class="pre">reference1</span></code> variable, there is now a strong reference from <code class="docutils literal notranslate"><span class="pre">reference1</span></code> to the new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance. Because there is at least one strong reference, ARC makes sure that this <code class="docutils literal notranslate"><span class="pre">Person</span></code> is kept in memory and is not deallocated.</p>
<p>If you assign the same <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance to two more variables, two more strong references to that instance are established:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reference2</span> = <span class="nv">reference1</span>
</li><li><span class="nv">reference3</span> = <span class="nv">reference1</span>
</li></ol></div></div></div>
<p>There are now <em>three</em> strong references to this single <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance.</p>
<p>If you break two of these strong references (including the original reference) by assigning <code class="docutils literal notranslate"><span class="pre">nil</span></code> to two of the variables, a single strong reference remains, and the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance is not deallocated:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reference1</span> = <span class="k">nil</span>
</li><li><span class="nv">reference2</span> = <span class="k">nil</span>
</li></ol></div></div></div>
<p>ARC does not deallocate the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance until the third and final strong reference is broken, at which point it’s clear that you are no longer using the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reference3</span> = <span class="k">nil</span>
</li><li><span class="c">// Prints "John Appleseed is being deinitialized"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID51">
<h2>Strong Reference Cycles Between Class Instances<a class="headerlink" href="AutomaticReferenceCounting.html#ID51" title="Permalink to this headline">¶</a></h2>
<p>In the examples above, ARC is able to track the number of references to the new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance you create and to deallocate that <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance when it’s no longer needed.</p>
<p>However, it’s possible to write code in which an instance of a class <em>never</em> gets to a point where it has zero strong references. This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive. This is known as a <em>strong reference cycle</em>.</p>
<p>You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references. This process is described in <a class="reference internal" href="AutomaticReferenceCounting.html#ID52"><span class="std std-ref">Resolving Strong Reference Cycles Between Class Instances</span></a>. However, before you learn how to resolve a strong reference cycle, it’s useful to understand how such a cycle is caused.</p>
<p>Here’s an example of how a strong reference cycle can be created by accident. This example defines two classes called <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code>, which model a block of apartments and its residents:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Person</span> {
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span> }
</li><li> <span class="k">var</span> <span class="nv">apartment</span>: <span class="nc">Apartment</span>?
</li><li> <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">Apartment</span> {
</li><li> <span class="k">let</span> <span class="nv">unit</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">unit</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">unit</span> = <span class="nv">unit</span> }
</li><li> <span class="k">var</span> <span class="nv">tenant</span>: <span class="nc">Person</span>?
</li><li> <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"Apartment </span>\<span class="p">(</span><span class="nv">unit</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li></ol></div></div></div>
<p>Every <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance has a <code class="docutils literal notranslate"><span class="pre">name</span></code> property of type <code class="docutils literal notranslate"><span class="pre">String</span></code> and an optional <code class="docutils literal notranslate"><span class="pre">apartment</span></code> property that is initially <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The <code class="docutils literal notranslate"><span class="pre">apartment</span></code> property is optional, because a person may not always have an apartment.</p>
<p>Similarly, every <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance has a <code class="docutils literal notranslate"><span class="pre">unit</span></code> property of type <code class="docutils literal notranslate"><span class="pre">String</span></code> and has an optional <code class="docutils literal notranslate"><span class="pre">tenant</span></code> property that is initially <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The tenant property is optional because an apartment may not always have a tenant.</p>
<p>Both of these classes also define a deinitializer, which prints the fact that an instance of that class is being deinitialized. This enables you to see whether instances of <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> are being deallocated as expected.</p>
<p>This next code snippet defines two variables of optional type called <code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code>, which will be set to a specific <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> and <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance below. Both of these variables have an initial value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, by virtue of being optional:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">john</span>: <span class="nc">Person</span>?
</li><li><span class="k">var</span> <span class="nv">unit4A</span>: <span class="nc">Apartment</span>?
</li></ol></div></div></div>
<p>You can now create a specific <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance and assign these new instances to the <code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> variables:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span> = <span class="nv">Person</span>(<span class="nv">name</span>: <span class="s">"John Appleseed"</span>)
</li><li><span class="nv">unit4A</span> = <span class="nv">Apartment</span>(<span class="nv">unit</span>: <span class="s">"4A"</span>)
</li></ol></div></div></div>
<p>Here’s how the strong references look after creating and assigning these two instances. The <code class="docutils literal notranslate"><span class="pre">john</span></code> variable now has a strong reference to the new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance, and the <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> variable has a strong reference to the new <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance:</p>
<img alt="../_images/referenceCycle01_2x.png" class="align-center" src="../_images/referenceCycle01_2x.png" style="width: 626px;"/>
<p>You can now link the two instances together so that the person has an apartment, and the apartment has a tenant. Note that an exclamation mark (<code class="docutils literal notranslate"><span class="pre">!</span></code>) is used to unwrap and access the instances stored inside the <code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> optional variables, so that the properties of those instances can be set:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span>!.<span class="nv">apartment</span> = <span class="nv">unit4A</span>
</li><li><span class="nv">unit4A</span>!.<span class="nv">tenant</span> = <span class="nv">john</span>
</li></ol></div></div></div>
<p>Here’s how the strong references look after you link the two instances together:</p>
<img alt="../_images/referenceCycle02_2x.png" class="align-center" src="../_images/referenceCycle02_2x.png" style="width: 626px;"/>
<p>Unfortunately, linking these two instances creates a strong reference cycle between them. The <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance now has a strong reference to the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance, and the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance has a strong reference to the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance. Therefore, when you break the strong references held by the <code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> variables, the reference counts do not drop to zero, and the instances are not deallocated by ARC:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span> = <span class="k">nil</span>
</li><li><span class="nv">unit4A</span> = <span class="k">nil</span>
</li></ol></div></div></div>
<p>Note that neither deinitializer was called when you set these two variables to <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The strong reference cycle prevents the <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instances from ever being deallocated, causing a memory leak in your app.</p>
<p>Here’s how the strong references look after you set the <code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> variables to <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</p>
<img alt="../_images/referenceCycle03_2x.png" class="align-center" src="../_images/referenceCycle03_2x.png" style="width: 626px;"/>
<p>The strong references between the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance and the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance remain and cannot be broken.</p>
</div>
<div class="section" id="ID52">
<h2>Resolving Strong Reference Cycles Between Class Instances<a class="headerlink" href="AutomaticReferenceCounting.html#ID52" title="Permalink to this headline">¶</a></h2>
<p>Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.</p>
<p>Weak and unowned references enable one instance in a reference cycle to refer to the other instance <em>without</em> keeping a strong hold on it. The instances can then refer to each other without creating a strong reference cycle.</p>
<p>Use a weak reference when the other instance has a shorter lifetime—that is, when the other instance can be deallocated first. In the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> example above, it’s appropriate for an apartment to be able to have no tenant at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case. In contrast, use an unowned reference when the other instance has the same lifetime or a longer lifetime.</p>
<div class="section" id="ID53">
<h3>Weak References<a class="headerlink" href="AutomaticReferenceCounting.html#ID53" title="Permalink to this headline">¶</a></h3>
<p>A <em>weak reference</em> is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance. This behavior prevents the reference from becoming part of a strong reference cycle. You indicate a weak reference by placing the <code class="docutils literal notranslate"><span class="pre">weak</span></code> keyword before a property or variable declaration.</p>
<p>Because a weak reference does not keep a strong hold on the instance it refers to, it’s possible for that instance to be deallocated while the weak reference is still referring to it. Therefore, ARC automatically sets a weak reference to <code class="docutils literal notranslate"><span class="pre">nil</span></code> when the instance that it refers to is deallocated. And, because weak references need to allow their value to be changed to <code class="docutils literal notranslate"><span class="pre">nil</span></code> at runtime, they are always declared as variables, rather than constants, of an optional type.</p>
<p>You can check for the existence of a value in the weak reference, just like any other optional value, and you will never end up with a reference to an invalid instance that no longer exists.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Property observers aren’t called when ARC sets a weak reference to <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
</div>
<p>The example below is identical to the <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> example from above, with one important difference. This time around, the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> type’s <code class="docutils literal notranslate"><span class="pre">tenant</span></code> property is declared as a weak reference:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Person</span> {
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span> }
</li><li> <span class="k">var</span> <span class="nv">apartment</span>: <span class="nc">Apartment</span>?
</li><li> <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">Apartment</span> {
</li><li> <span class="k">let</span> <span class="nv">unit</span>: <span class="nc">String</span>
</li><li> <span class="k">init</span>(<span class="nv">unit</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">unit</span> = <span class="nv">unit</span> }
</li><li> <span class="k">weak</span> <span class="k">var</span> <span class="nv">tenant</span>: <span class="nc">Person</span>?
</li><li> <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"Apartment </span>\<span class="p">(</span><span class="nv">unit</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li></ol></div></div></div>
<p>The strong references from the two variables (<code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code>) and the links between the two instances are created as before:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">john</span>: <span class="nc">Person</span>?
</li><li><span class="k">var</span> <span class="nv">unit4A</span>: <span class="nc">Apartment</span>?
</li><li>
</li><li><span class="nv">john</span> = <span class="nv">Person</span>(<span class="nv">name</span>: <span class="s">"John Appleseed"</span>)
</li><li><span class="nv">unit4A</span> = <span class="nv">Apartment</span>(<span class="nv">unit</span>: <span class="s">"4A"</span>)
</li><li>
</li><li><span class="nv">john</span>!.<span class="nv">apartment</span> = <span class="nv">unit4A</span>
</li><li><span class="nv">unit4A</span>!.<span class="nv">tenant</span> = <span class="nv">john</span>
</li></ol></div></div></div>
<p>Here’s how the references look now that you’ve linked the two instances together:</p>
<img alt="../_images/weakReference01_2x.png" class="align-center" src="../_images/weakReference01_2x.png" style="width: 626px;"/>
<p>The <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance still has a strong reference to the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance, but the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance now has a <em>weak</em> reference to the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance. This means that when you break the strong reference held by the <code class="docutils literal notranslate"><span class="pre">john</span></code> variable by setting it to <code class="docutils literal notranslate"><span class="pre">nil</span></code>, there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span> = <span class="k">nil</span>
</li><li><span class="c">// Prints "John Appleseed is being deinitialized"</span>
</li></ol></div></div></div>
<p>Because there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance, it’s deallocated and the <code class="docutils literal notranslate"><span class="pre">tenant</span></code> property is set to <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</p>
<img alt="../_images/weakReference02_2x.png" class="align-center" src="../_images/weakReference02_2x.png" style="width: 626px;"/>
<p>The only remaining strong reference to the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance is from the <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> variable. If you break <em>that</em> strong reference, there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">unit4A</span> = <span class="k">nil</span>
</li><li><span class="c">// Prints "Apartment 4A is being deinitialized"</span>
</li></ol></div></div></div>
<p>Because there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance, it too is deallocated:</p>
<img alt="../_images/weakReference03_2x.png" class="align-center" src="../_images/weakReference03_2x.png" style="width: 626px;"/>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In systems that use garbage collection, weak pointers are sometimes used to implement a simple caching mechanism because objects with no strong references are deallocated only when memory pressure triggers garbage collection. However, with ARC, values are deallocated as soon as their last strong reference is removed, making weak references unsuitable for such a purpose.</p>
</div>
</div>
<div class="section" id="ID54">
<h3>Unowned References<a class="headerlink" href="AutomaticReferenceCounting.html#ID54" title="Permalink to this headline">¶</a></h3>
<p>Like a weak reference, an <em>unowned reference</em> does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime. You indicate an unowned reference by placing the <code class="docutils literal notranslate"><span class="pre">unowned</span></code> keyword before a property or variable declaration.</p>
<p>An unowned reference is expected to always have a value. As a result, ARC never sets an unowned reference’s value to <code class="docutils literal notranslate"><span class="pre">nil</span></code>, which means that unowned references are defined using nonoptional types.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>Use an unowned reference only when you are sure that the reference <em>always</em> refers to an instance that has not been deallocated.</p>
<p class="last">If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error.</p>
</div>
<p>The following example defines two classes, <code class="docutils literal notranslate"><span class="pre">Customer</span></code> and <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>, which model a bank customer and a possible credit card for that customer. These two classes each store an instance of the other class as a property. This relationship has the potential to create a strong reference cycle.</p>
<p>The relationship between <code class="docutils literal notranslate"><span class="pre">Customer</span></code> and <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> is slightly different from the relationship between <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> and <code class="docutils literal notranslate"><span class="pre">Person</span></code> seen in the weak reference example above. In this data model, a customer may or may not have a credit card, but a credit card will <em>always</em> be associated with a customer. A <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance never outlives the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> that it refers to. To represent this, the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> class has an optional <code class="docutils literal notranslate"><span class="pre">card</span></code> property, but the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> class has an unowned (and nonoptional) <code class="docutils literal notranslate"><span class="pre">customer</span></code> property.</p>
<p>Furthermore, a new <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance can <em>only</em> be created by passing a <code class="docutils literal notranslate"><span class="pre">number</span></code> value and a <code class="docutils literal notranslate"><span class="pre">customer</span></code> instance to a custom <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> initializer. This ensures that a <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance always has a <code class="docutils literal notranslate"><span class="pre">customer</span></code> instance associated with it when the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance is created.</p>
<p>Because a credit card will always have a customer, you define its <code class="docutils literal notranslate"><span class="pre">customer</span></code> property as an unowned reference, to avoid a strong reference cycle:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Customer</span> {
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">var</span> <span class="nv">card</span>: <span class="nc">CreditCard</span>?
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>    }
</li><li> <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">CreditCard</span> {
</li><li> <span class="k">let</span> <span class="nv">number</span>: <span class="nc">UInt64</span>
</li><li> <span class="k">unowned</span> <span class="k">let</span> <span class="nv">customer</span>: <span class="nc">Customer</span>
</li><li> <span class="k">init</span>(<span class="nv">number</span>: <span class="nc">UInt64</span>, <span class="nv">customer</span>: <span class="nc">Customer</span>) {
</li><li> <span class="k">self</span>.<span class="nv">number</span> = <span class="nv">number</span>
</li><li> <span class="k">self</span>.<span class="nv">customer</span> = <span class="nv">customer</span>
</li><li>    }
</li><li> <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"Card #</span>\<span class="p">(</span><span class="nv">number</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">number</span></code> property of the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> class is defined with a type of <code class="docutils literal notranslate"><span class="pre">UInt64</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Int</span></code>, to ensure that the <code class="docutils literal notranslate"><span class="pre">number</span></code> property’s capacity is large enough to store a 16-digit card number on both 32-bit and 64-bit systems.</p>
</div>
<p>This next code snippet defines an optional <code class="docutils literal notranslate"><span class="pre">Customer</span></code> variable called <code class="docutils literal notranslate"><span class="pre">john</span></code>, which will be used to store a reference to a specific customer. This variable has an initial value of nil, by virtue of being optional:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">john</span>: <span class="nc">Customer</span>?
</li></ol></div></div></div>
<p>You can now create a <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance, and use it to initialize and assign a new <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance as that customer’s <code class="docutils literal notranslate"><span class="pre">card</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span> = <span class="nv">Customer</span>(<span class="nv">name</span>: <span class="s">"John Appleseed"</span>)
</li><li><span class="nv">john</span>!.<span class="nv">card</span> = <span class="nv">CreditCard</span>(<span class="nv">number</span>: <span class="m">1234_5678_9012_3456</span>, <span class="nv">customer</span>: <span class="nv">john</span>!)
</li></ol></div></div></div>
<p>Here’s how the references look, now that you’ve linked the two instances:</p>
<img alt="../_images/unownedReference01_2x.png" class="align-center" src="../_images/unownedReference01_2x.png" style="width: 626px;"/>
<p>The <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance now has a strong reference to the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance, and the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance has an unowned reference to the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance.</p>
<p>Because of the unowned <code class="docutils literal notranslate"><span class="pre">customer</span></code> reference, when you break the strong reference held by the <code class="docutils literal notranslate"><span class="pre">john</span></code> variable, there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance:</p>
<img alt="../_images/unownedReference02_2x.png" class="align-center" src="../_images/unownedReference02_2x.png" style="width: 626px;"/>
<p>Because there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance, it’s deallocated. After this happens, there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance, and it too is deallocated:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span> = <span class="k">nil</span>
</li><li><span class="c">// Prints "John Appleseed is being deinitialized"</span>
</li><li><span class="c">// Prints "Card #1234567890123456 is being deinitialized"</span>
</li></ol></div></div></div>
<p>The final code snippet above shows that the deinitializers for the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance and <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance both print their “deinitialized” messages after the <code class="docutils literal notranslate"><span class="pre">john</span></code> variable is set to <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The examples above show how to use <em>safe</em> unowned references. Swift also provides <em>unsafe</em> unowned references for cases where you need to disable runtime safety checks—for example, for performance reasons. As with all unsafe operations, you take on the responsibility for checking that code for safety.</p>
<p class="last">You indicate an unsafe unowned reference by writing <code class="docutils literal notranslate"><span class="pre">unowned(unsafe)</span></code>. If you try to access an unsafe unowned reference after the instance that it refers to is deallocated, your program will try to access the memory location where the instance used to be, which is an unsafe operation.</p>
</div>
</div>
<div class="section" id="ID55">
<h3>Unowned References and Implicitly Unwrapped Optional Properties<a class="headerlink" href="AutomaticReferenceCounting.html#ID55" title="Permalink to this headline">¶</a></h3>
<p>The examples for weak and unowned references above cover two of the more common scenarios in which it’s necessary to break a strong reference cycle.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> example shows a situation where two properties, both of which are allowed to be <code class="docutils literal notranslate"><span class="pre">nil</span></code>, have the potential to cause a strong reference cycle. This scenario is best resolved with a weak reference.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Customer</span></code> and <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> example shows a situation where one property that is allowed to be <code class="docutils literal notranslate"><span class="pre">nil</span></code> and another property that cannot be <code class="docutils literal notranslate"><span class="pre">nil</span></code> have the potential to cause a strong reference cycle. This scenario is best resolved with an unowned reference.</p>
<p>However, there is a third scenario, in which <em>both</em> properties should always have a value, and neither property should ever be <code class="docutils literal notranslate"><span class="pre">nil</span></code> once initialization is complete. In this scenario, it’s useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</p>
<p>This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle. This section shows you how to set up such a relationship.</p>
<p>The example below defines two classes, <code class="docutils literal notranslate"><span class="pre">Country</span></code> and <code class="docutils literal notranslate"><span class="pre">City</span></code>, each of which stores an instance of the other class as a property. In this data model, every country must always have a capital city, and every city must always belong to a country. To represent this, the <code class="docutils literal notranslate"><span class="pre">Country</span></code> class has a <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property, and the <code class="docutils literal notranslate"><span class="pre">City</span></code> class has a <code class="docutils literal notranslate"><span class="pre">country</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Country</span> {
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">var</span> <span class="nv">capitalCity</span>: <span class="nc">City</span>!
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">capitalName</span>: <span class="nc">String</span>) {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li> <span class="k">self</span>.<span class="nv">capitalCity</span> = <span class="nv">City</span>(<span class="nv">name</span>: <span class="nv">capitalName</span>, <span class="nv">country</span>: <span class="k">self</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">City</span> {
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">unowned</span> <span class="k">let</span> <span class="nv">country</span>: <span class="nc">Country</span>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">country</span>: <span class="nc">Country</span>) {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li> <span class="k">self</span>.<span class="nv">country</span> = <span class="nv">country</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>To set up the interdependency between the two classes, the initializer for <code class="docutils literal notranslate"><span class="pre">City</span></code> takes a <code class="docutils literal notranslate"><span class="pre">Country</span></code> instance, and stores this instance in its <code class="docutils literal notranslate"><span class="pre">country</span></code> property.</p>
<p>The initializer for <code class="docutils literal notranslate"><span class="pre">City</span></code> is called from within the initializer for <code class="docutils literal notranslate"><span class="pre">Country</span></code>. However, the initializer for <code class="docutils literal notranslate"><span class="pre">Country</span></code> cannot pass <code class="docutils literal notranslate"><span class="pre">self</span></code> to the <code class="docutils literal notranslate"><span class="pre">City</span></code> initializer until a new <code class="docutils literal notranslate"><span class="pre">Country</span></code> instance is fully initialized, as described in <a class="reference internal" href="Initialization.html#ID220"><span class="std std-ref">Two-Phase Initialization</span></a>.</p>
<p>To cope with this requirement, you declare the <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property of <code class="docutils literal notranslate"><span class="pre">Country</span></code> as an implicitly unwrapped optional property, indicated by the exclamation mark at the end of its type annotation (<code class="docutils literal notranslate"><span class="pre">City!</span></code>). This means that the <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property has a default value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, like any other optional, but can be accessed without the need to unwrap its value as described in <a class="reference internal" href="TheBasics.html#ID334"><span class="std std-ref">Implicitly Unwrapped Optionals</span></a>.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> has a default <code class="docutils literal notranslate"><span class="pre">nil</span></code> value, a new <code class="docutils literal notranslate"><span class="pre">Country</span></code> instance is considered fully initialized as soon as the <code class="docutils literal notranslate"><span class="pre">Country</span></code> instance sets its <code class="docutils literal notranslate"><span class="pre">name</span></code> property within its initializer. This means that the <code class="docutils literal notranslate"><span class="pre">Country</span></code> initializer can start to reference and pass around the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> property as soon as the <code class="docutils literal notranslate"><span class="pre">name</span></code> property is set. The <code class="docutils literal notranslate"><span class="pre">Country</span></code> initializer can therefore pass <code class="docutils literal notranslate"><span class="pre">self</span></code> as one of the parameters for the <code class="docutils literal notranslate"><span class="pre">City</span></code> initializer when the <code class="docutils literal notranslate"><span class="pre">Country</span></code> initializer is setting its own <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property.</p>
<p>All of this means that you can create the <code class="docutils literal notranslate"><span class="pre">Country</span></code> and <code class="docutils literal notranslate"><span class="pre">City</span></code> instances in a single statement, without creating a strong reference cycle, and the <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property can be accessed directly, without needing to use an exclamation mark to unwrap its optional value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">country</span> = <span class="nv">Country</span>(<span class="nv">name</span>: <span class="s">"Canada"</span>, <span class="nv">capitalName</span>: <span class="s">"Ottawa"</span>)
</li><li><span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">country</span>.<span class="nv">name</span><span class="p">)</span><span class="s">'s capital city is called </span>\<span class="p">(</span><span class="nv">country</span>.<span class="nv">capitalCity</span>.<span class="nv">name</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "Canada's capital city is called Ottawa"</span>
</li></ol></div></div></div>
<p>In the example above, the use of an implicitly unwrapped optional means that all of the two-phase class initializer requirements are satisfied. The <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property can be used and accessed like a nonoptional value once initialization is complete, while still avoiding a strong reference cycle.</p>
</div>
</div>
<div class="section" id="ID56">
<h2>Strong Reference Cycles for Closures<a class="headerlink" href="AutomaticReferenceCounting.html#ID56" title="Permalink to this headline">¶</a></h2>
<p>You saw above how a strong reference cycle can be created when two class instance properties hold a strong reference to each other. You also saw how to use weak and unowned references to break these strong reference cycles.</p>
<p>A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as <code class="docutils literal notranslate"><span class="pre">self.someProperty</span></code>, or because the closure calls a method on the instance, such as <code class="docutils literal notranslate"><span class="pre">self.someMethod()</span></code>. In either case, these accesses cause the closure to “capture” <code class="docutils literal notranslate"><span class="pre">self</span></code>, creating a strong reference cycle.</p>
<p>This strong reference cycle occurs because closures, like classes, are <em>reference types</em>. When you assign a closure to a property, you are assigning a <em>reference</em> to that closure. In essence, it’s the same problem as above—two strong references are keeping each other alive. However, rather than two class instances, this time it’s a class instance and a closure that are keeping each other alive.</p>
<p>Swift provides an elegant solution to this problem, known as a <em>closure capture list</em>. However, before you learn how to break a strong reference cycle with a closure capture list, it’s useful to understand how such a cycle can be caused.</p>
<p>The example below shows how you can create a strong reference cycle when using a closure that references <code class="docutils literal notranslate"><span class="pre">self</span></code>. This example defines a class called <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>, which provides a simple model for an individual element within an HTML document:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">HTMLElement</span> {
</li><li>
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">let</span> <span class="nv">text</span>: <span class="nc">String</span>?
</li><li>
</li><li> <span class="k">lazy</span> <span class="k">var</span> <span class="nv">asHTML</span>: () -&gt; <span class="nc">String</span> = {
</li><li> <span class="k">if</span> <span class="k">let</span> <span class="nv">text</span> = <span class="k">self</span>.<span class="nv">text</span> {
</li><li> <span class="k">return</span> <span class="s">"&lt;</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;</span>\<span class="p">(</span><span class="nv">text</span><span class="p">)</span><span class="s">&lt;/</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;"</span>
</li><li>        } <span class="k">else</span> {
</li><li> <span class="k">return</span> <span class="s">"&lt;</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s"> /&gt;"</span>
</li><li>        }
</li><li>    }
</li><li>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">text</span>: <span class="nc">String</span>? = <span class="k">nil</span>) {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li> <span class="k">self</span>.<span class="nv">text</span> = <span class="nv">text</span>
</li><li>    }
</li><li>
</li><li> <span class="k">deinit</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>)
</li><li>    }
</li><li>
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class defines a <code class="docutils literal notranslate"><span class="pre">name</span></code> property, which indicates the name of the element, such as <code class="docutils literal notranslate"><span class="pre">"h1"</span></code> for a heading element, <code class="docutils literal notranslate"><span class="pre">"p"</span></code> for a paragraph element, or <code class="docutils literal notranslate"><span class="pre">"br"</span></code> for a line break element. <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> also defines an optional <code class="docutils literal notranslate"><span class="pre">text</span></code> property, which you can set to a string that represents the text to be rendered within that HTML element.</p>
<p>In addition to these two simple properties, the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class defines a lazy property called <code class="docutils literal notranslate"><span class="pre">asHTML</span></code>. This property references a closure that combines <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">text</span></code> into an HTML string fragment. The <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property is of type <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code>, or “a function that takes no parameters, and returns a <code class="docutils literal notranslate"><span class="pre">String</span></code> value”.</p>
<p>By default, the <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property is assigned a closure that returns a string representation of an HTML tag. This tag contains the optional <code class="docutils literal notranslate"><span class="pre">text</span></code> value if it exists, or no text content if <code class="docutils literal notranslate"><span class="pre">text</span></code> does not exist. For a paragraph element, the closure would return <code class="docutils literal notranslate"><span class="pre">"&lt;p&gt;some</span> <span class="pre">text&lt;/p&gt;"</span></code> or <code class="docutils literal notranslate"><span class="pre">"&lt;p</span> <span class="pre">/&gt;"</span></code>, depending on whether the <code class="docutils literal notranslate"><span class="pre">text</span></code> property equals <code class="docutils literal notranslate"><span class="pre">"some</span> <span class="pre">text"</span></code> or <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property is named and used somewhat like an instance method. However, because <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> is a closure property rather than an instance method, you can replace the default value of the <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property with a custom closure, if you want to change the HTML rendering for a particular HTML element.</p>
<p>For example, the <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property could be set to a closure that defaults to some text if the <code class="docutils literal notranslate"><span class="pre">text</span></code> property is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, in order to prevent the representation from returning an empty HTML tag:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">heading</span> = <span class="nv">HTMLElement</span>(<span class="nv">name</span>: <span class="s">"h1"</span>)
</li><li><span class="k">let</span> <span class="nv">defaultText</span> = <span class="s">"some default text"</span>
</li><li><span class="nv">heading</span>.<span class="nv">asHTML</span> = {
</li><li> <span class="k">return</span> <span class="s">"&lt;</span>\<span class="p">(</span><span class="nv">heading</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;</span>\<span class="p">(</span><span class="nv">heading</span>.<span class="nv">text</span> ?? <span class="nv">defaultText</span><span class="p">)</span><span class="s">&lt;/</span>\<span class="p">(</span><span class="nv">heading</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;"</span>
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">heading</span>.<span class="nv">asHTML</span>())
</li><li><span class="c">// Prints "&lt;h1&gt;some default text&lt;/h1&gt;"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property is declared as a lazy property, because it’s only needed if and when the element actually needs to be rendered as a string value for some HTML output target. The fact that <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> is a lazy property means that you can refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> within the default closure, because the lazy property will not be accessed until after initialization has been completed and <code class="docutils literal notranslate"><span class="pre">self</span></code> is known to exist.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class provides a single initializer, which takes a <code class="docutils literal notranslate"><span class="pre">name</span></code> argument and (if desired) a <code class="docutils literal notranslate"><span class="pre">text</span></code> argument to initialize a new element. The class also defines a deinitializer, which prints a message to show when an <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance is deallocated.</p>
<p>Here’s how you use the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class to create and print a new instance:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">paragraph</span>: <span class="nc">HTMLElement</span>? = <span class="nv">HTMLElement</span>(<span class="nv">name</span>: <span class="s">"p"</span>, <span class="nv">text</span>: <span class="s">"hello, world"</span>)
</li><li><span class="nv">print</span>(<span class="nv">paragraph</span>!.<span class="nv">asHTML</span>())
</li><li><span class="c">// Prints "&lt;p&gt;hello, world&lt;/p&gt;"</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">paragraph</span></code> variable above is defined as an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>, so that it can be set to <code class="docutils literal notranslate"><span class="pre">nil</span></code> below to demonstrate the presence of a strong reference cycle.</p>
</div>
<p>Unfortunately, the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class, as written above, creates a strong reference cycle between an <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance and the closure used for its default <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> value. Here’s how the cycle looks:</p>
<img alt="../_images/closureReferenceCycle01_2x.png" class="align-center" src="../_images/closureReferenceCycle01_2x.png" style="width: 626px;"/>
<p>The instance’s <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property holds a strong reference to its closure. However, because the closure refers to <code class="docutils literal notranslate"><span class="pre">self</span></code> within its body (as a way to reference <code class="docutils literal notranslate"><span class="pre">self.name</span></code> and <code class="docutils literal notranslate"><span class="pre">self.text</span></code>), the closure <em>captures</em> self, which means that it holds a strong reference back to the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance. A strong reference cycle is created between the two. (For more information about capturing values in a closure, see <a class="reference internal" href="Closures.html#ID103"><span class="std std-ref">Capturing Values</span></a>.)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Even though the closure refers to <code class="docutils literal notranslate"><span class="pre">self</span></code> multiple times, it only captures one strong reference to the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance.</p>
</div>
<p>If you set the <code class="docutils literal notranslate"><span class="pre">paragraph</span></code> variable to <code class="docutils literal notranslate"><span class="pre">nil</span></code> and break its strong reference to the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance, neither the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance nor its closure are deallocated, because of the strong reference cycle:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">paragraph</span> = <span class="k">nil</span>
</li></ol></div></div></div>
<p>Note that the message in the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> deinitializer is not printed, which shows that the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance is not deallocated.</p>
</div>
<div class="section" id="ID57">
<h2>Resolving Strong Reference Cycles for Closures<a class="headerlink" href="AutomaticReferenceCounting.html#ID57" title="Permalink to this headline">¶</a></h2>
<p>You resolve a strong reference cycle between a closure and a class instance by defining a <em>capture list</em> as part of the closure’s definition. A capture list defines the rules to use when capturing one or more reference types within the closure’s body. As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference. The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Swift requires you to write <code class="docutils literal notranslate"><span class="pre">self.someProperty</span></code> or <code class="docutils literal notranslate"><span class="pre">self.someMethod()</span></code> (rather than just <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> or <code class="docutils literal notranslate"><span class="pre">someMethod()</span></code>) whenever you refer to a member of <code class="docutils literal notranslate"><span class="pre">self</span></code> within a closure. This helps you remember that it’s possible to capture <code class="docutils literal notranslate"><span class="pre">self</span></code> by accident.</p>
</div>
<div class="section" id="ID58">
<h3>Defining a Capture List<a class="headerlink" href="AutomaticReferenceCounting.html#ID58" title="Permalink to this headline">¶</a></h3>
<p>Each item in a capture list is a pairing of the <code class="docutils literal notranslate"><span class="pre">weak</span></code> or <code class="docutils literal notranslate"><span class="pre">unowned</span></code> keyword with a reference to a class instance (such as <code class="docutils literal notranslate"><span class="pre">self</span></code>) or a variable initialized with some value (such as <code class="docutils literal notranslate"><span class="pre">delegate</span> <span class="pre">=</span> <span class="pre">self.delegate!</span></code>). These pairings are written within a pair of square braces, separated by commas.</p>
<p>Place the capture list before a closure’s parameter list and return type if they are provided:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">lazy</span> <span class="k">var</span> <span class="nv">someClosure</span>: (<span class="nc">Int</span>, <span class="nc">String</span>) -&gt; <span class="nc">String</span> = {
</li><li>    [<span class="nv">unowned</span> <span class="k">self</span>, <span class="nv">weak</span> <span class="nv">delegate</span> = <span class="k">self</span>.<span class="nv">delegate</span>!] (<span class="nv">index</span>: <span class="nc">Int</span>, <span class="nv">stringToProcess</span>: <span class="nc">String</span>) -&gt; <span class="nc">String</span> <span class="k">in</span>
</li><li> <span class="c">// closure body goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>If a closure does not specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">lazy</span> <span class="k">var</span> <span class="nv">someClosure</span>: () -&gt; <span class="nc">String</span> = {
</li><li>    [<span class="nv">unowned</span> <span class="k">self</span>, <span class="nv">weak</span> <span class="nv">delegate</span> = <span class="k">self</span>.<span class="nv">delegate</span>!] <span class="k">in</span>
</li><li> <span class="c">// closure body goes here</span>
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID59">
<h3>Weak and Unowned References<a class="headerlink" href="AutomaticReferenceCounting.html#ID59" title="Permalink to this headline">¶</a></h3>
<p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>
<p>Conversely, define a capture as a weak reference when the captured reference may become <code class="docutils literal notranslate"><span class="pre">nil</span></code> at some point in the future. Weak references are always of an optional type, and automatically become <code class="docutils literal notranslate"><span class="pre">nil</span></code> when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the captured reference will never become <code class="docutils literal notranslate"><span class="pre">nil</span></code>, it should always be captured as an unowned reference, rather than a weak reference.</p>
</div>
<p>An unowned reference is the appropriate capture method to use to resolve the strong reference cycle in the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> example from <a class="reference internal" href="AutomaticReferenceCounting.html#ID56"><span class="std std-ref">Strong Reference Cycles for Closures</span></a> above. Here’s how you write the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class to avoid the cycle:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">HTMLElement</span> {
</li><li>
</li><li> <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">let</span> <span class="nv">text</span>: <span class="nc">String</span>?
</li><li>
</li><li> <span class="k">lazy</span> <span class="k">var</span> <span class="nv">asHTML</span>: () -&gt; <span class="nc">String</span> = {
</li><li>        [<span class="nv">unowned</span> <span class="k">self</span>] <span class="k">in</span>
</li><li> <span class="k">if</span> <span class="k">let</span> <span class="nv">text</span> = <span class="k">self</span>.<span class="nv">text</span> {
</li><li> <span class="k">return</span> <span class="s">"&lt;</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;</span>\<span class="p">(</span><span class="nv">text</span><span class="p">)</span><span class="s">&lt;/</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;"</span>
</li><li>        } <span class="k">else</span> {
</li><li> <span class="k">return</span> <span class="s">"&lt;</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s"> /&gt;"</span>
</li><li>        }
</li><li>    }
</li><li>
</li><li> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">text</span>: <span class="nc">String</span>? = <span class="k">nil</span>) {
</li><li> <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li> <span class="k">self</span>.<span class="nv">text</span> = <span class="nv">text</span>
</li><li>    }
</li><li>
</li><li> <span class="k">deinit</span> {
</li><li> <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>)
</li><li>    }
</li><li>
</li><li>}
</li></ol></div></div></div>
<p>This implementation of <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> is identical to the previous implementation, apart from the addition of a capture list within the <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> closure. In this case, the capture list is <code class="docutils literal notranslate"><span class="pre">[unowned</span> <span class="pre">self]</span></code>, which means “capture self as an unowned reference rather than a strong reference”.</p>
<p>You can create and print an <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance as before:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">paragraph</span>: <span class="nc">HTMLElement</span>? = <span class="nv">HTMLElement</span>(<span class="nv">name</span>: <span class="s">"p"</span>, <span class="nv">text</span>: <span class="s">"hello, world"</span>)
</li><li><span class="nv">print</span>(<span class="nv">paragraph</span>!.<span class="nv">asHTML</span>())
</li><li><span class="c">// Prints "&lt;p&gt;hello, world&lt;/p&gt;"</span>
</li></ol></div></div></div>
<p>Here’s how the references look with the capture list in place:</p>
<img alt="../_images/closureReferenceCycle02_2x.png" class="align-center" src="../_images/closureReferenceCycle02_2x.png" style="width: 626px;"/>
<p>This time, the capture of <code class="docutils literal notranslate"><span class="pre">self</span></code> by the closure is an unowned reference, and does not keep a strong hold on the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance it has captured. If you set the strong reference from the <code class="docutils literal notranslate"><span class="pre">paragraph</span></code> variable to <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance is deallocated, as can be seen from the printing of its deinitializer message in the example below:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">paragraph</span> = <span class="k">nil</span>
</li><li><span class="c">// Prints "p is being deinitialized"</span>
</li></ol></div></div></div>
<p>For more information about capture lists, see <a class="reference internal" href="../ReferenceManual/Expressions.html#ID544"><span class="std std-ref">Capture Lists</span></a>.</p>
</div>
</div>
</div><div class="section" id="memory-safety">
<h1>Memory Safety<a class="headerlink" href="MemorySafety.html#memory-safety" title="Permalink to this headline">¶</a></h1>
<p>By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors.</p>
<p>Swift also makes sure that multiple accesses to the same area of memory don’t conflict, by requiring code that modifies a location in memory to have exclusive access to that memory. Because Swift manages memory automatically, most of the time you don’t have to think about accessing memory at all. However, it’s important to understand where potential conflicts can occur, so you can avoid writing code that has conflicting access to memory. If your code does contain conflicts, you’ll get a compile-time or runtime error.</p>
<div class="section" id="ID568">
<h2>Understanding Conflicting Access to Memory<a class="headerlink" href="MemorySafety.html#ID568" title="Permalink to this headline">¶</a></h2>
<p>Access to memory happens in your code when you do things like set the value of a variable or pass an argument to a function. For example, the following code contains both a read access and a write access:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// A write access to the memory where one is stored.</span>
</li><li><span class="k">var</span> <span class="nv">one</span> = <span class="m">1</span>
</li><li>
</li><li><span class="c">// A read access from the memory where one is stored.</span>
</li><li><span class="nv">print</span>(<span class="s">"We're number </span>\<span class="p">(</span><span class="nv">one</span><span class="p">)</span><span class="s">!"</span>)
</li></ol></div></div></div>
<p>A conflicting access to memory can occur when different parts of your code are trying to access the same location in memory at the same time. Multiple accesses to a location in memory at the same time can produce unpredictable or inconsistent behavior. In Swift, there are ways to modify a value that span several lines of code, making it possible to attempt to access a value in the middle of its own modification.</p>
<p>You can see a similar problem by thinking about how you update a budget that’s written on a piece of paper. Updating the budget is a two-step process: First you add the items’ names and prices, and then you change the total amount to reflect the items currently on the list. Before and after the update, you can read any information from the budget and get a correct answer, as shown in the figure below.</p>
<img alt="../_images/memory_shopping_2x.png" class="align-center" src="../_images/memory_shopping_2x.png" style="width: 430px;"/>
<p>While you’re adding items to the budget, it’s in a temporary, invalid state because the total amount hasn’t been updated to reflect the newly added items. Reading the total amount during the process of adding an item gives you incorrect information.</p>
<p>This example also demonstrates a challenge you may encounter when fixing conflicting access to memory: There are sometimes multiple ways to fix the conflict that produce different answers, and it’s not always obvious which answer is correct. In this example, depending on whether you wanted the original total amount or the updated total amount, either $5 or $320 could be the correct answer. Before you can fix the conflicting access, you have to determine what it was intended to do.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you’ve written concurrent or multithreaded code, conflicting access to memory might be a familiar problem. However, the conflicting access discussed here can happen on a single thread and <em>doesn’t</em> involve concurrent or multithreaded code.</p>
<p class="last">If you have conflicting access to memory from within a single thread, Swift guarantees that you’ll get an error at either compile time or runtime. For multithreaded code, use <a class="reference external" href="https://developer.apple.com/documentation/code_diagnostics/thread_sanitizer">Thread Sanitizer</a> to help detect conflicting access across threads.</p>
</div>
<div class="section" id="ID573">
<h3>Characteristics of Memory Access<a class="headerlink" href="MemorySafety.html#ID573" title="Permalink to this headline">¶</a></h3>
<p>There are three characteristics of memory access to consider in the context of conflicting access: whether the access is a read or a write, the duration of the access, and the location in memory being accessed. Specifically, a conflict occurs if you have two accesses that meet all of the following conditions:</p>
<ul class="simple">
<li>At least one is a write access.</li>
<li>They access the same location in memory.</li>
<li>Their durations overlap.</li>
</ul>
<p>The difference between a read and write access is usually obvious: a write access changes the location in memory, but a read access doesn’t. The location in memory refers to what is being accessed—for example, a variable, constant, or property. The duration of a memory access is either instantaneous or long-term.</p>
<p>An access is <em>instantaneous</em> if it’s not possible for other code to run after that access starts but before it ends. By their nature, two instantaneous accesses can’t happen at the same time. Most memory access is instantaneous. For example, all the read and write accesses in the code listing below are instantaneous:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">oneMore</span>(<span class="nv">than</span> <span class="nv">number</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li> <span class="k">return</span> <span class="nv">number</span> + <span class="m">1</span>
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">myNumber</span> = <span class="m">1</span>
</li><li><span class="nv">myNumber</span> = <span class="nv">oneMore</span>(<span class="nv">than</span>: <span class="nv">myNumber</span>)
</li><li><span class="nv">print</span>(<span class="nv">myNumber</span>)
</li><li><span class="c">// Prints "2"</span>
</li></ol></div></div></div>
<p>However, there are several ways to access memory, called <em>long-term</em> accesses, that span the execution of other code. The difference between instantaneous access and long-term access is that it’s possible for other code to run after a long-term access starts but before it ends, which is called <em>overlap</em>. A long-term access can overlap with other long-term accesses and instantaneous accesses.</p>
<p>Overlapping accesses appear primarily in code that uses in-out parameters in functions and methods or mutating methods of a structure. The specific kinds of Swift code that use long-term accesses are discussed in the sections below.</p>
</div>
</div>
<div class="section" id="ID569">
<h2>Conflicting Access to In-Out Parameters<a class="headerlink" href="MemorySafety.html#ID569" title="Permalink to this headline">¶</a></h2>
<p>A function has long-term write access to all of its in-out parameters. The write access for an in-out parameter starts after all of the non-in-out parameters have been evaluated and lasts for the entire duration of that function call. If there are multiple in-out parameters, the write accesses start in the same order as the parameters appear.</p>
<p>One consequence of this long-term write access is that you can’t access the original variable that was passed as in-out, even if scoping rules and access control would otherwise permit it—any access to the original creates a conflict. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">stepSize</span> = <span class="m">1</span>
</li><li>
</li><li><span class="k">func</span> <span class="nv">increment</span>(<span class="k">_</span> <span class="nv">number</span>: <span class="k">inout</span> <span class="nc">Int</span>) {
</li><li> <span class="nv">number</span> += <span class="nv">stepSize</span>
</li><li>}
</li><li>
</li><li><span class="nv">increment</span>(&amp;<span class="nv">stepSize</span>)
</li><li><span class="c">// Error: conflicting accesses to stepSize</span>
</li></ol></div></div></div>
<p>In the code above, <code class="docutils literal notranslate"><span class="pre">stepSize</span></code> is a global variable, and it is normally accessible from within <code class="docutils literal notranslate"><span class="pre">increment(_:)</span></code>. However, the read access to <code class="docutils literal notranslate"><span class="pre">stepSize</span></code> overlaps with the write access to <code class="docutils literal notranslate"><span class="pre">number</span></code>. As shown in the figure below, both <code class="docutils literal notranslate"><span class="pre">number</span></code> and <code class="docutils literal notranslate"><span class="pre">stepSize</span></code> refer to the same location in memory. The read and write accesses refer to the same memory and they overlap, producing a conflict.</p>
<img alt="../_images/memory_increment_2x.png" class="align-center" src="../_images/memory_increment_2x.png" style="width: 384px;"/>
<p>One way to solve this conflict is to make an explicit copy of <code class="docutils literal notranslate"><span class="pre">stepSize</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// Make an explicit copy.</span>
</li><li><span class="k">var</span> <span class="nv">copyOfStepSize</span> = <span class="nv">stepSize</span>
</li><li><span class="nv">increment</span>(&amp;<span class="nv">copyOfStepSize</span>)
</li><li>
</li><li><span class="c">// Update the original.</span>
</li><li><span class="nv">stepSize</span> = <span class="nv">copyOfStepSize</span>
</li><li><span class="c">// stepSize is now 2</span>
</li></ol></div></div></div>
<p>When you make a copy of <code class="docutils literal notranslate"><span class="pre">stepSize</span></code> before calling <code class="docutils literal notranslate"><span class="pre">increment(_:)</span></code>, it’s clear that the value of <code class="docutils literal notranslate"><span class="pre">copyOfStepSize</span></code> is incremented by the current step size. The read access ends before the write access starts, so there isn’t a conflict.</p>
<p>Another consequence of long-term write access to in-out parameters is that passing a single variable as the argument for multiple in-out parameters of the same function produces a conflict. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">balance</span>(<span class="k">_</span> <span class="nv">x</span>: <span class="k">inout</span> <span class="nc">Int</span>, <span class="k">_</span> <span class="nv">y</span>: <span class="k">inout</span> <span class="nc">Int</span>) {
</li><li> <span class="k">let</span> <span class="nv">sum</span> = <span class="nv">x</span> + <span class="nv">y</span>
</li><li> <span class="nv">x</span> = <span class="nv">sum</span> / <span class="m">2</span>
</li><li> <span class="nv">y</span> = <span class="nv">sum</span> - <span class="nv">x</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">playerOneScore</span> = <span class="m">42</span>
</li><li><span class="k">var</span> <span class="nv">playerTwoScore</span> = <span class="m">30</span>
</li><li><span class="nv">balance</span>(&amp;<span class="nv">playerOneScore</span>, &amp;<span class="nv">playerTwoScore</span>)  <span class="c">// OK</span>
</li><li><span class="nv">balance</span>(&amp;<span class="nv">playerOneScore</span>, &amp;<span class="nv">playerOneScore</span>)
</li><li><span class="c">// Error: conflicting accesses to playerOneScore</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">balance(_:_:)</span></code> function above modifies its two parameters to divide the total value evenly between them. Calling it with <code class="docutils literal notranslate"><span class="pre">playerOneScore</span></code> and <code class="docutils literal notranslate"><span class="pre">playerTwoScore</span></code> as arguments doesn’t produce a conflict—there are two write accesses that overlap in time, but they access different locations in memory. In contrast, passing <code class="docutils literal notranslate"><span class="pre">playerOneScore</span></code> as the value for both parameters produces a conflict because it tries to perform two write accesses to the same location in memory at the same time.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because operators are functions, they can also have long-term accesses to their in-out parameters. For example, if <code class="docutils literal notranslate"><span class="pre">balance(_:_:)</span></code> was an operator function named <code class="docutils literal notranslate"><span class="pre">&lt;^&gt;</span></code>, writing <code class="docutils literal notranslate"><span class="pre">playerOneScore</span> <span class="pre">&lt;^&gt;</span> <span class="pre">playerOneScore</span></code> would result in the same conflict as <code class="docutils literal notranslate"><span class="pre">balance(&amp;playerOneScore,</span> <span class="pre">&amp;playerOneScore)</span></code>.</p>
</div>
</div>
<div class="section" id="ID570">
<h2>Conflicting Access to self in Methods<a class="headerlink" href="MemorySafety.html#ID570" title="Permalink to this headline">¶</a></h2>
<p>A mutating method on a structure has write access to <code class="docutils literal notranslate"><span class="pre">self</span></code> for the duration of the method call. For example, consider a game where each player has a health amount, which decreases when taking damage, and an energy amount, which decreases when using special abilities.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Player</span> {
</li><li> <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li> <span class="k">var</span> <span class="nv">health</span>: <span class="nc">Int</span>
</li><li> <span class="k">var</span> <span class="nv">energy</span>: <span class="nc">Int</span>
</li><li>
</li><li> <span class="k">static</span> <span class="k">let</span> <span class="nv">maxHealth</span> = <span class="m">10</span>
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">restoreHealth</span>() {
</li><li> <span class="nv">health</span> = <span class="nv">Player</span>.<span class="nv">maxHealth</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>In the <code class="docutils literal notranslate"><span class="pre">restoreHealth()</span></code> method above, a write access to <code class="docutils literal notranslate"><span class="pre">self</span></code> starts at the beginning of the method and lasts until the method returns. In this case, there’s no other code inside <code class="docutils literal notranslate"><span class="pre">restoreHealth()</span></code> that could have an overlapping access to the properties of a <code class="docutils literal notranslate"><span class="pre">Player</span></code> instance. The <code class="docutils literal notranslate"><span class="pre">shareHealth(with:)</span></code> method below takes another <code class="docutils literal notranslate"><span class="pre">Player</span></code> instance as an in-out parameter, creating the possibility of overlapping accesses.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Player</span> {
</li><li> <span class="k">mutating</span> <span class="k">func</span> <span class="nv">shareHealth</span>(<span class="nv">with</span> <span class="nv">teammate</span>: <span class="k">inout</span> <span class="nc">Player</span>) {
</li><li> <span class="nv">balance</span>(&amp;<span class="nv">teammate</span>.<span class="nv">health</span>, &amp;<span class="nv">health</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">oscar</span> = <span class="nv">Player</span>(<span class="nv">name</span>: <span class="s">"Oscar"</span>, <span class="nv">health</span>: <span class="m">10</span>, <span class="nv">energy</span>: <span class="m">10</span>)
</li><li><span class="k">var</span> <span class="nv">maria</span> = <span class="nv">Player</span>(<span class="nv">name</span>: <span class="s">"Maria"</span>, <span class="nv">health</span>: <span class="m">5</span>, <span class="nv">energy</span>: <span class="m">10</span>)
</li><li><span class="nv">oscar</span>.<span class="nv">shareHealth</span>(<span class="nv">with</span>: &amp;<span class="nv">maria</span>)  <span class="c">// OK</span>
</li></ol></div></div></div>
<p>In the example above, calling the <code class="docutils literal notranslate"><span class="pre">shareHealth(with:)</span></code> method for Oscar’s player to share health with Maria’s player doesn’t cause a conflict. There’s a write access to <code class="docutils literal notranslate"><span class="pre">oscar</span></code> during the method call because <code class="docutils literal notranslate"><span class="pre">oscar</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">self</span></code> in a mutating method, and there’s a write access to <code class="docutils literal notranslate"><span class="pre">maria</span></code> for the same duration because <code class="docutils literal notranslate"><span class="pre">maria</span></code> was passed as an in-out parameter. As shown in the figure below, they access different locations in memory. Even though the two write accesses overlap in time, they don’t conflict.</p>
<img alt="../_images/memory_share_health_maria_2x.png" class="align-center" src="../_images/memory_share_health_maria_2x.png" style="width: 506px;"/>
<p>However, if you pass <code class="docutils literal notranslate"><span class="pre">oscar</span></code> as the argument to <code class="docutils literal notranslate"><span class="pre">shareHealth(with:)</span></code>, there’s a conflict:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">oscar</span>.<span class="nv">shareHealth</span>(<span class="nv">with</span>: &amp;<span class="nv">oscar</span>)
</li><li><span class="c">// Error: conflicting accesses to oscar</span>
</li></ol></div></div></div>
<p>The mutating method needs write access to <code class="docutils literal notranslate"><span class="pre">self</span></code> for the duration of the method, and the in-out parameter needs write access to <code class="docutils literal notranslate"><span class="pre">teammate</span></code> for the same duration. Within the method, both <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">teammate</span></code> refer to the same location in memory—as shown in the figure below. The two write accesses refer to the same memory and they overlap, producing a conflict.</p>
<img alt="../_images/memory_share_health_oscar_2x.png" class="align-center" src="../_images/memory_share_health_oscar_2x.png" style="width: 506px;"/>
</div>
<div class="section" id="ID571">
<h2>Conflicting Access to Properties<a class="headerlink" href="MemorySafety.html#ID571" title="Permalink to this headline">¶</a></h2>
<p>Types like structures, tuples, and enumerations are made up of individual constituent values, such as the properties of a structure or the elements of a tuple. Because these are value types, mutating any piece of the value mutates the whole value, meaning read or write access to one of the properties requires read or write access to the whole value. For example, overlapping write accesses to the elements of a tuple produces a conflict:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">playerInformation</span> = (<span class="nv">health</span>: <span class="m">10</span>, <span class="nv">energy</span>: <span class="m">20</span>)
</li><li><span class="nv">balance</span>(&amp;<span class="nv">playerInformation</span>.<span class="nv">health</span>, &amp;<span class="nv">playerInformation</span>.<span class="nv">energy</span>)
</li><li><span class="c">// Error: conflicting access to properties of playerInformation</span>
</li></ol></div></div></div>
<p>In the example above, calling <code class="docutils literal notranslate"><span class="pre">balance(_:_:)</span></code> on the elements of a tuple produces a conflict because there are overlapping write accesses to <code class="docutils literal notranslate"><span class="pre">playerInformation</span></code>. Both <code class="docutils literal notranslate"><span class="pre">playerInformation.health</span></code> and <code class="docutils literal notranslate"><span class="pre">playerInformation.energy</span></code> are passed as in-out parameters, which means <code class="docutils literal notranslate"><span class="pre">balance(_:_:)</span></code> needs write access to them for the duration of the function call. In both cases, a write access to the tuple element requires a write access to the entire tuple. This means there are two write accesses to <code class="docutils literal notranslate"><span class="pre">playerInformation</span></code> with durations that overlap, causing a conflict.</p>
<p>The code below shows that the same error appears for overlapping write accesses to the properties of a structure that’s stored in a global variable.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">holly</span> = <span class="nv">Player</span>(<span class="nv">name</span>: <span class="s">"Holly"</span>, <span class="nv">health</span>: <span class="m">10</span>, <span class="nv">energy</span>: <span class="m">10</span>)
</li><li><span class="nv">balance</span>(&amp;<span class="nv">holly</span>.<span class="nv">health</span>, &amp;<span class="nv">holly</span>.<span class="nv">energy</span>)  <span class="c">// Error</span>
</li></ol></div></div></div>
<p>In practice, most access to the properties of a structure can overlap safely. For example, if the variable <code class="docutils literal notranslate"><span class="pre">holly</span></code> in the example above is changed to a local variable instead of a global variable, the compiler can prove that overlapping access to stored properties of the structure is safe:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>() {
</li><li> <span class="k">var</span> <span class="nv">oscar</span> = <span class="nv">Player</span>(<span class="nv">name</span>: <span class="s">"Oscar"</span>, <span class="nv">health</span>: <span class="m">10</span>, <span class="nv">energy</span>: <span class="m">10</span>)
</li><li> <span class="nv">balance</span>(&amp;<span class="nv">oscar</span>.<span class="nv">health</span>, &amp;<span class="nv">oscar</span>.<span class="nv">energy</span>)  <span class="c">// OK</span>
</li><li>}
</li></ol></div></div></div>
<p>In the example above, Oscar’s health and energy are passed as the two in-out parameters to <code class="docutils literal notranslate"><span class="pre">balance(_:_:)</span></code>. The compiler can prove that memory safety is preserved because the two stored properties don’t interact in any way.</p>
<p>The restriction against overlapping access to properties of a structure isn’t always necessary to preserve memory safety. Memory safety is the desired guarantee, but exclusive access is a stricter requirement than memory safety—which means some code preserves memory safety, even though it violates exclusive access to memory. Swift allows this memory-safe code if the compiler can prove that the nonexclusive access to memory is still safe. Specifically, it can prove that overlapping access to properties of a structure is safe if the following conditions apply:</p>
<ul class="simple">
<li>You’re accessing only stored properties of an instance, not computed properties or class properties.</li>
<li>The structure is the value of a local variable, not a global variable.</li>
<li>The structure is either not captured by any closures, or it’s captured only by nonescaping closures.</li>
</ul>
<p>If the compiler can’t prove the access is safe, it doesn’t allow the access.</p>
</div>
</div><div class="section" id="access-control">
<h1>Access Control<a class="headerlink" href="AccessControl.html#access-control" title="Permalink to this headline">¶</a></h1>
<p><em>Access control</em> restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.</p>
<p>You can assign specific access levels to individual types (classes, structures, and enumerations), as well as to properties, methods, initializers, and subscripts belonging to those types. Protocols can be restricted to a certain context, as can global constants, variables, and functions.</p>
<p>In addition to offering various levels of access control, Swift reduces the need to specify explicit access control levels by providing default access levels for typical scenarios. Indeed, if you are writing a single-target app, you may not need to specify explicit access control levels at all.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The various aspects of your code that can have access control applied to them (properties, types, functions, and so on) are referred to as “entities” in the sections below, for brevity.</p>
</div>
<div class="section" id="ID4">
<h2>Modules and Source Files<a class="headerlink" href="AccessControl.html#ID4" title="Permalink to this headline">¶</a></h2>
<p>Swift’s access control model is based on the concept of modules and source files.</p>
<p>A <em>module</em> is a single unit of code distribution—a framework or application that is built and shipped as a single unit and that can be imported by another module with Swift’s <code class="docutils literal notranslate"><span class="pre">import</span></code> keyword.</p>
<p>Each build target (such as an app bundle or framework) in Xcode is treated as a separate module in Swift. If you group together aspects of your app’s code as a stand-alone framework—perhaps to encapsulate and reuse that code across multiple applications—then everything you define within that framework will be part of a separate module when it’s imported and used within an app, or when it’s used within another framework.</p>
<p>A <em>source file</em> is a single Swift source code file within a module (in effect, a single file within an app or framework). Although it’s common to define individual types in separate source files, a single source file can contain definitions for multiple types, functions, and so on.</p>
</div>
<div class="section" id="ID5">
<h2>Access Levels<a class="headerlink" href="AccessControl.html#ID5" title="Permalink to this headline">¶</a></h2>
<p>Swift provides five different <em>access levels</em> for entities within your code. These access levels are relative to the source file in which an entity is defined, and also relative to the module that source file belongs to.</p>
<ul class="simple">
<li><em>Open access</em> and <em>public access</em> enable entities to be used within any source file from their defining module, and also in a source file from another module that imports the defining module. You typically use open or public access when specifying the public interface to a framework. The difference between open and public access is described below.</li>
<li><em>Internal access</em> enables entities to be used within any source file from their defining module, but not in any source file outside of that module. You typically use internal access when defining an app’s or a framework’s internal structure.</li>
<li><em>File-private access</em> restricts the use of an entity to its own defining source file. Use file-private access to hide the implementation details of a specific piece of functionality when those details are used within an entire file.</li>
<li><em>Private access</em> restricts the use of an entity to the enclosing declaration, and to extensions of that declaration that are in the same file. Use private access to hide the implementation details of a specific piece of functionality when those details are used only within a single declaration.</li>
</ul>
<p>Open access is the highest (least restrictive) access level and private access is the lowest (most restrictive) access level.</p>
<p>Open access applies only to classes and class members, and it differs from public access as follows:</p>
<ul class="simple">
<li>Classes with public access, or any more restrictive access level, can be subclassed only within the module where they’re defined.</li>
<li>Class members with public access, or any more restrictive access level, can be overridden by subclasses only within the module where they’re defined.</li>
<li>Open classes can be subclassed within the module where they’re defined, and within any module that imports the module where they’re defined.</li>
<li>Open class members can be overridden by subclasses within the module where they’re defined, and within any module that imports the module where they’re defined.</li>
</ul>
<p>Marking a class as open explicitly indicates that you’ve considered the impact of code from other modules using that class as a superclass, and that you’ve designed your class’s code accordingly.</p>
<div class="section" id="ID6">
<h3>Guiding Principle of Access Levels<a class="headerlink" href="AccessControl.html#ID6" title="Permalink to this headline">¶</a></h3>
<p>Access levels in Swift follow an overall guiding principle: <em>No entity can be defined in terms of another entity that has a lower (more restrictive) access level.</em></p>
<p>For example:</p>
<ul class="simple">
<li>A public variable can’t be defined as having an internal, file-private, or private type, because the type might not be available everywhere that the public variable is used.</li>
<li>A function can’t have a higher access level than its parameter types and return type, because the function could be used in situations where its constituent types are unavailable to the surrounding code.</li>
</ul>
<p>The specific implications of this guiding principle for different aspects of the language are covered in detail below.</p>
</div>
<div class="section" id="ID7">
<h3>Default Access Levels<a class="headerlink" href="AccessControl.html#ID7" title="Permalink to this headline">¶</a></h3>
<p>All entities in your code (with a few specific exceptions, as described later in this chapter) have a default access level of internal if you don’t specify an explicit access level yourself. As a result, in many cases you don’t need to specify an explicit access level in your code.</p>
</div>
<div class="section" id="ID8">
<h3>Access Levels for Single-Target Apps<a class="headerlink" href="AccessControl.html#ID8" title="Permalink to this headline">¶</a></h3>
<p>When you write a simple single-target app, the code in your app is typically self-contained within the app and doesn’t need to be made available outside of the app’s module. The default access level of internal already matches this requirement. Therefore, you don’t need to specify a custom access level. You may, however, want to mark some parts of your code as file private or private in order to hide their implementation details from other code within the app’s module.</p>
</div>
<div class="section" id="ID9">
<h3>Access Levels for Frameworks<a class="headerlink" href="AccessControl.html#ID9" title="Permalink to this headline">¶</a></h3>
<p>When you develop a framework, mark the public-facing interface to that framework as open or public so that it can be viewed and accessed by other modules, such as an app that imports the framework. This public-facing interface is the application programming interface (or API) for the framework.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Any internal implementation details of your framework can still use the default access level of internal, or can be marked as private or file private if you want to hide them from other parts of the framework’s internal code. You need to mark an entity as open or public only if you want it to become part of your framework’s API.</p>
</div>
</div>
<div class="section" id="ID519">
<h3>Access Levels for Unit Test Targets<a class="headerlink" href="AccessControl.html#ID519" title="Permalink to this headline">¶</a></h3>
<p>When you write an app with a unit test target, the code in your app needs to be made available to that module in order to be tested. By default, only entities marked as open or public are accessible to other modules. However, a unit test target can access any internal entity, if you mark the import declaration for a product module with the <code class="docutils literal notranslate"><span class="pre">@testable</span></code> attribute and compile that product module with testing enabled.</p>
</div>
</div>
<div class="section" id="ID10">
<h2>Access Control Syntax<a class="headerlink" href="AccessControl.html#ID10" title="Permalink to this headline">¶</a></h2>
<p>Define the access level for an entity by placing one of the <code class="docutils literal notranslate"><span class="pre">open</span></code>, <code class="docutils literal notranslate"><span class="pre">public</span></code>, <code class="docutils literal notranslate"><span class="pre">internal</span></code>, <code class="docutils literal notranslate"><span class="pre">fileprivate</span></code>, or <code class="docutils literal notranslate"><span class="pre">private</span></code> modifiers before the entity’s introducer:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">public</span> <span class="k">class</span> <span class="nv">SomePublicClass</span> {}
</li><li><span class="k">internal</span> <span class="k">class</span> <span class="nv">SomeInternalClass</span> {}
</li><li><span class="k">fileprivate</span> <span class="k">class</span> <span class="nv">SomeFilePrivateClass</span> {}
</li><li><span class="k">private</span> <span class="k">class</span> <span class="nv">SomePrivateClass</span> {}
</li><li>
</li><li><span class="k">public</span> <span class="k">var</span> <span class="nv">somePublicVariable</span> = <span class="m">0</span>
</li><li><span class="k">internal</span> <span class="k">let</span> <span class="nv">someInternalConstant</span> = <span class="m">0</span>
</li><li><span class="k">fileprivate</span> <span class="k">func</span> <span class="nv">someFilePrivateFunction</span>() {}
</li><li><span class="k">private</span> <span class="k">func</span> <span class="nv">somePrivateFunction</span>() {}
</li></ol></div></div></div>
<p>Unless otherwise specified, the default access level is internal, as described in <a class="reference internal" href="AccessControl.html#ID7"><span class="std std-ref">Default Access Levels</span></a>. This means that <code class="docutils literal notranslate"><span class="pre">SomeInternalClass</span></code> and <code class="docutils literal notranslate"><span class="pre">someInternalConstant</span></code> can be written without an explicit access-level modifier, and will still have an access level of internal:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeInternalClass</span> {}              <span class="c">// implicitly internal</span>
</li><li><span class="k">let</span> <span class="nv">someInternalConstant</span> = <span class="m">0</span> <span class="c">// implicitly internal</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID11">
<h2>Custom Types<a class="headerlink" href="AccessControl.html#ID11" title="Permalink to this headline">¶</a></h2>
<p>If you want to specify an explicit access level for a custom type, do so at the point that you define the type. The new type can then be used wherever its access level permits. For example, if you define a file-private class, that class can only be used as the type of a property, or as a function parameter or return type, in the source file in which the file-private class is defined.</p>
<p>The access control level of a type also affects the default access level of that type’s <em>members</em> (its properties, methods, initializers, and subscripts). If you define a type’s access level as private or file private, the default access level of its members will also be private or file private. If you define a type’s access level as internal or public (or use the default access level of internal without specifying an access level explicitly), the default access level of the type’s members will be internal.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">A public type defaults to having internal members, not public members. If you want a type member to be public, you must explicitly mark it as such. This requirement ensures that the public-facing API for a type is something you opt in to publishing, and avoids presenting the internal workings of a type as public API by mistake.</p>
</div>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">public</span> <span class="k">class</span> <span class="nv">SomePublicClass</span> {                  <span class="c">// explicitly public class</span>
</li><li> <span class="k">public</span> <span class="k">var</span> <span class="nv">somePublicProperty</span> = <span class="m">0</span> <span class="c">// explicitly public class member</span>
</li><li> <span class="k">var</span> <span class="nv">someInternalProperty</span> = <span class="m">0</span> <span class="c">// implicitly internal class member</span>
</li><li> <span class="k">fileprivate</span> <span class="k">func</span> <span class="nv">someFilePrivateMethod</span>() {}  <span class="c">// explicitly file-private class member</span>
</li><li> <span class="k">private</span> <span class="k">func</span> <span class="nv">somePrivateMethod</span>() {}          <span class="c">// explicitly private class member</span>
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">SomeInternalClass</span> {                       <span class="c">// implicitly internal class</span>
</li><li> <span class="k">var</span> <span class="nv">someInternalProperty</span> = <span class="m">0</span> <span class="c">// implicitly internal class member</span>
</li><li> <span class="k">fileprivate</span> <span class="k">func</span> <span class="nv">someFilePrivateMethod</span>() {}  <span class="c">// explicitly file-private class member</span>
</li><li> <span class="k">private</span> <span class="k">func</span> <span class="nv">somePrivateMethod</span>() {}          <span class="c">// explicitly private class member</span>
</li><li>}
</li><li>
</li><li><span class="k">fileprivate</span> <span class="k">class</span> <span class="nv">SomeFilePrivateClass</span> {        <span class="c">// explicitly file-private class</span>
</li><li> <span class="k">func</span> <span class="nv">someFilePrivateMethod</span>() {}              <span class="c">// implicitly file-private class member</span>
</li><li> <span class="k">private</span> <span class="k">func</span> <span class="nv">somePrivateMethod</span>() {}          <span class="c">// explicitly private class member</span>
</li><li>}
</li><li>
</li><li><span class="k">private</span> <span class="k">class</span> <span class="nv">SomePrivateClass</span> {                <span class="c">// explicitly private class</span>
</li><li> <span class="k">func</span> <span class="nv">somePrivateMethod</span>() {}                  <span class="c">// implicitly private class member</span>
</li><li>}
</li></ol></div></div></div>
<div class="section" id="ID12">
<h3>Tuple Types<a class="headerlink" href="AccessControl.html#ID12" title="Permalink to this headline">¶</a></h3>
<p>The access level for a tuple type is the most restrictive access level of all types used in that tuple. For example, if you compose a tuple from two different types, one with internal access and one with private access, the access level for that compound tuple type will be private.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Tuple types don’t have a standalone definition in the way that classes, structures, enumerations, and functions do. A tuple type’s access level is deduced automatically when the tuple type is used, and can’t be specified explicitly.</p>
</div>
</div>
<div class="section" id="ID13">
<h3>Function Types<a class="headerlink" href="AccessControl.html#ID13" title="Permalink to this headline">¶</a></h3>
<p>The access level for a function type is calculated as the most restrictive access level of the function’s parameter types and return type. You must specify the access level explicitly as part of the function’s definition if the function’s calculated access level doesn’t match the contextual default.</p>
<p>The example below defines a global function called <code class="docutils literal notranslate"><span class="pre">someFunction()</span></code>, without providing a specific access-level modifier for the function itself. You might expect this function to have the default access level of “internal”, but this isn’t the case. In fact, <code class="docutils literal notranslate"><span class="pre">someFunction()</span></code> won’t compile as written below:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>() -&gt; (<span class="nc">SomeInternalClass</span>, <span class="nc">SomePrivateClass</span>) {
</li><li> <span class="c">// function implementation goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>The function’s return type is a tuple type composed from two of the custom classes defined above in <a class="reference internal" href="AccessControl.html#ID11"><span class="std std-ref">Custom Types</span></a>. One of these classes is defined as internal, and the other is defined as private. Therefore, the overall access level of the compound tuple type is private (the minimum access level of the tuple’s constituent types).</p>
<p>Because the function’s return type is private, you must mark the function’s overall access level with the <code class="docutils literal notranslate"><span class="pre">private</span></code> modifier for the function declaration to be valid:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">private</span> <span class="k">func</span> <span class="nv">someFunction</span>() -&gt; (<span class="nc">SomeInternalClass</span>, <span class="nc">SomePrivateClass</span>) {
</li><li> <span class="c">// function implementation goes here</span>
</li><li>}
</li></ol></div></div></div>
<p>It’s not valid to mark the definition of <code class="docutils literal notranslate"><span class="pre">someFunction()</span></code> with the <code class="docutils literal notranslate"><span class="pre">public</span></code> or <code class="docutils literal notranslate"><span class="pre">internal</span></code> modifiers, or to use the default setting of internal, because public or internal users of the function might not have appropriate access to the private class used in the function’s return type.</p>
</div>
<div class="section" id="ID14">
<h3>Enumeration Types<a class="headerlink" href="AccessControl.html#ID14" title="Permalink to this headline">¶</a></h3>
<p>The individual cases of an enumeration automatically receive the same access level as the enumeration they belong to. You can’t specify a different access level for individual enumeration cases.</p>
<p>In the example below, the <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> enumeration has an explicit access level of public. The enumeration cases <code class="docutils literal notranslate"><span class="pre">north</span></code>, <code class="docutils literal notranslate"><span class="pre">south</span></code>, <code class="docutils literal notranslate"><span class="pre">east</span></code>, and <code class="docutils literal notranslate"><span class="pre">west</span></code> therefore also have an access level of public:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">public</span> <span class="k">enum</span> <span class="nv">CompassPoint</span> {
</li><li> <span class="k">case</span> <span class="nv">north</span>
</li><li> <span class="k">case</span> <span class="nv">south</span>
</li><li> <span class="k">case</span> <span class="nv">east</span>
</li><li> <span class="k">case</span> <span class="nv">west</span>
</li><li>}
</li></ol></div></div></div>
<div class="section" id="ID468">
<h4>Raw Values and Associated Values<a class="headerlink" href="AccessControl.html#ID468" title="Permalink to this headline">¶</a></h4>
<p>The types used for any raw values or associated values in an enumeration definition must have an access level at least as high as the enumeration’s access level. You can’t use a private type as the raw-value type of an enumeration with an internal access level, for example.</p>
</div>
</div>
<div class="section" id="ID15">
<h3>Nested Types<a class="headerlink" href="AccessControl.html#ID15" title="Permalink to this headline">¶</a></h3>
<p>Nested types defined within a private type have an automatic access level of private. Nested types defined within a file-private type have an automatic access level of file private. Nested types defined within a public type or an internal type have an automatic access level of internal. If you want a nested type within a public type to be publicly available, you must explicitly declare the nested type as public.</p>
</div>
</div>
<div class="section" id="ID16">
<h2>Subclassing<a class="headerlink" href="AccessControl.html#ID16" title="Permalink to this headline">¶</a></h2>
<p>You can subclass any class that can be accessed in the current access context. A subclass can’t have a higher access level than its superclass—for example, you can’t write a public subclass of an internal superclass.</p>
<p>In addition, you can override any class member (method, property, initializer, or subscript) that is visible in a certain access context.</p>
<p>An override can make an inherited class member more accessible than its superclass version. In the example below, class <code class="docutils literal notranslate"><span class="pre">A</span></code> is a public class with a file-private method called <code class="docutils literal notranslate"><span class="pre">someMethod()</span></code>. Class <code class="docutils literal notranslate"><span class="pre">B</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">A</span></code>, with a reduced access level of “internal”. Nonetheless, class <code class="docutils literal notranslate"><span class="pre">B</span></code> provides an override of <code class="docutils literal notranslate"><span class="pre">someMethod()</span></code> with an access level of “internal”, which is <em>higher</em> than the original implementation of <code class="docutils literal notranslate"><span class="pre">someMethod()</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">public</span> <span class="k">class</span> <span class="nv">A</span> {
</li><li> <span class="k">fileprivate</span> <span class="k">func</span> <span class="nv">someMethod</span>() {}
</li><li>}
</li><li>
</li><li><span class="k">internal</span> <span class="k">class</span> <span class="nv">B</span>: <span class="nc">A</span> {
</li><li> <span class="k">override</span> <span class="k">internal</span> <span class="k">func</span> <span class="nv">someMethod</span>() {}
</li><li>}
</li></ol></div></div></div>
<p>It’s even valid for a subclass member to call a superclass member that has lower access permissions than the subclass member, as long as the call to the superclass’s member takes place within an allowed access level context (that is, within the same source file as the superclass for a file-private member call, or within the same module as the superclass for an internal member call):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">public</span> <span class="k">class</span> <span class="nv">A</span> {
</li><li> <span class="k">fileprivate</span> <span class="k">func</span> <span class="nv">someMethod</span>() {}
</li><li>}
</li><li>
</li><li><span class="k">internal</span> <span class="k">class</span> <span class="nv">B</span>: <span class="nc">A</span> {
</li><li> <span class="k">override</span> <span class="k">internal</span> <span class="k">func</span> <span class="nv">someMethod</span>() {
</li><li> <span class="k">super</span>.<span class="nv">someMethod</span>()
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Because superclass <code class="docutils literal notranslate"><span class="pre">A</span></code> and subclass <code class="docutils literal notranslate"><span class="pre">B</span></code> are defined in the same source file, it’s valid for the <code class="docutils literal notranslate"><span class="pre">B</span></code> implementation of <code class="docutils literal notranslate"><span class="pre">someMethod()</span></code> to call <code class="docutils literal notranslate"><span class="pre">super.someMethod()</span></code>.</p>
</div>
<div class="section" id="ID17">
<h2>Constants, Variables, Properties, and Subscripts<a class="headerlink" href="AccessControl.html#ID17" title="Permalink to this headline">¶</a></h2>
<p>A constant, variable, or property can’t be more public than its type. It’s not valid to write a public property with a private type, for example. Similarly, a subscript can’t be more public than either its index type or return type.</p>
<p>If a constant, variable, property, or subscript makes use of a private type, the constant, variable, property, or subscript must also be marked as <code class="docutils literal notranslate"><span class="pre">private</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">private</span> <span class="k">var</span> <span class="nv">privateInstance</span> = <span class="nv">SomePrivateClass</span>()
</li></ol></div></div></div>
<div class="section" id="ID18">
<h3>Getters and Setters<a class="headerlink" href="AccessControl.html#ID18" title="Permalink to this headline">¶</a></h3>
<p>Getters and setters for constants, variables, properties, and subscripts automatically receive the same access level as the constant, variable, property, or subscript they belong to.</p>
<p>You can give a setter a <em>lower</em> access level than its corresponding getter, to restrict the read-write scope of that variable, property, or subscript. You assign a lower access level by writing <code class="docutils literal notranslate"><span class="pre">fileprivate(set)</span></code>, <code class="docutils literal notranslate"><span class="pre">private(set)</span></code>, or <code class="docutils literal notranslate"><span class="pre">internal(set)</span></code> before the <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">subscript</span></code> introducer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This rule applies to stored properties as well as computed properties. Even though you don’t write an explicit getter and setter for a stored property, Swift still synthesizes an implicit getter and setter for you to provide access to the stored property’s backing storage. Use <code class="docutils literal notranslate"><span class="pre">fileprivate(set)</span></code>, <code class="docutils literal notranslate"><span class="pre">private(set)</span></code>, and <code class="docutils literal notranslate"><span class="pre">internal(set)</span></code> to change the access level of this synthesized setter in exactly the same way as for an explicit setter in a computed property.</p>
</div>
<p>The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">TrackedString</span></code>, which keeps track of the number of times a string property is modified:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">TrackedString</span> {
</li><li> <span class="k">private(set)</span> <span class="k">var</span> <span class="nv">numberOfEdits</span> = <span class="m">0</span>
</li><li> <span class="k">var</span> <span class="nv">value</span>: <span class="nc">String</span> = <span class="s">""</span> {
</li><li> <span class="k">didSet</span> {
</li><li> <span class="nv">numberOfEdits</span> += <span class="m">1</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">TrackedString</span></code> structure defines a stored string property called <code class="docutils literal notranslate"><span class="pre">value</span></code>, with an initial value of <code class="docutils literal notranslate"><span class="pre">""</span></code> (an empty string). The structure also defines a stored integer property called <code class="docutils literal notranslate"><span class="pre">numberOfEdits</span></code>, which is used to track the number of times that <code class="docutils literal notranslate"><span class="pre">value</span></code> is modified. This modification tracking is implemented with a <code class="docutils literal notranslate"><span class="pre">didSet</span></code> property observer on the <code class="docutils literal notranslate"><span class="pre">value</span></code> property, which increments <code class="docutils literal notranslate"><span class="pre">numberOfEdits</span></code> every time the <code class="docutils literal notranslate"><span class="pre">value</span></code> property is set to a new value.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">TrackedString</span></code> structure and the <code class="docutils literal notranslate"><span class="pre">value</span></code> property don’t provide an explicit access-level modifier, and so they both receive the default access level of internal. However, the access level for the <code class="docutils literal notranslate"><span class="pre">numberOfEdits</span></code> property is marked with a <code class="docutils literal notranslate"><span class="pre">private(set)</span></code> modifier to indicate that the property’s getter still has the default access level of internal, but the property is settable only from within code that’s part of the <code class="docutils literal notranslate"><span class="pre">TrackedString</span></code> structure. This enables <code class="docutils literal notranslate"><span class="pre">TrackedString</span></code> to modify the <code class="docutils literal notranslate"><span class="pre">numberOfEdits</span></code> property internally, but to present the property as a read-only property when it’s used outside the structure’s definition.</p>
<p>If you create a <code class="docutils literal notranslate"><span class="pre">TrackedString</span></code> instance and modify its string value a few times, you can see the <code class="docutils literal notranslate"><span class="pre">numberOfEdits</span></code> property value update to match the number of modifications:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">stringToEdit</span> = <span class="nv">TrackedString</span>()
</li><li><span class="nv">stringToEdit</span>.<span class="nv">value</span> = <span class="s">"This string will be tracked."</span>
</li><li><span class="nv">stringToEdit</span>.<span class="nv">value</span> += <span class="s">" This edit will increment numberOfEdits."</span>
</li><li><span class="nv">stringToEdit</span>.<span class="nv">value</span> += <span class="s">" So will this one."</span>
</li><li><span class="nv">print</span>(<span class="s">"The number of edits is </span>\<span class="p">(</span><span class="nv">stringToEdit</span>.<span class="nv">numberOfEdits</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c">// Prints "The number of edits is 3"</span>
</li></ol></div></div></div>
<p>Although you can query the current value of the <code class="docutils literal notranslate"><span class="pre">numberOfEdits</span></code> property from within another source file, you can’t <em>modify</em> the property from another source file. This restriction protects the implementation details of the <code class="docutils literal notranslate"><span class="pre">TrackedString</span></code> edit-tracking functionality, while still providing convenient access to an aspect of that functionality.</p>
<p>Note that you can assign an explicit access level for both a getter and a setter if required. The example below shows a version of the <code class="docutils literal notranslate"><span class="pre">TrackedString</span></code> structure in which the structure is defined with an explicit access level of public. The structure’s members (including the <code class="docutils literal notranslate"><span class="pre">numberOfEdits</span></code> property) therefore have an internal access level by default. You can make the structure’s <code class="docutils literal notranslate"><span class="pre">numberOfEdits</span></code> property getter public, and its property setter private, by combining the <code class="docutils literal notranslate"><span class="pre">public</span></code> and <code class="docutils literal notranslate"><span class="pre">private(set)</span></code> access-level modifiers:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">public</span> <span class="k">struct</span> <span class="nv">TrackedString</span> {
</li><li> <span class="k">public</span> <span class="k">private(set)</span> <span class="k">var</span> <span class="nv">numberOfEdits</span> = <span class="m">0</span>
</li><li> <span class="k">public</span> <span class="k">var</span> <span class="nv">value</span>: <span class="nc">String</span> = <span class="s">""</span> {
</li><li> <span class="k">didSet</span> {
</li><li> <span class="nv">numberOfEdits</span> += <span class="m">1</span>
</li><li>        }
</li><li>    }
</li><li> <span class="k">public</span> <span class="k">init</span>() {}
</li><li>}
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID19">
<h2>Initializers<a class="headerlink" href="AccessControl.html#ID19" title="Permalink to this headline">¶</a></h2>
<p>Custom initializers can be assigned an access level less than or equal to the type that they initialize. The only exception is for required initializers (as defined in <a class="reference internal" href="Initialization.html#ID231"><span class="std std-ref">Required Initializers</span></a>). A required initializer must have the same access level as the class it belongs to.</p>
<p>As with function and method parameters, the types of an initializer’s parameters can’t be more private than the initializer’s own access level.</p>
<div class="section" id="ID20">
<h3>Default Initializers<a class="headerlink" href="AccessControl.html#ID20" title="Permalink to this headline">¶</a></h3>
<p>As described in <a class="reference internal" href="Initialization.html#ID213"><span class="std std-ref">Default Initializers</span></a>, Swift automatically provides a <em>default initializer</em> without any arguments for any structure or base class that provides default values for all of its properties and doesn’t provide at least one initializer itself.</p>
<p>A default initializer has the same access level as the type it initializes, unless that type is defined as <code class="docutils literal notranslate"><span class="pre">public</span></code>. For a type that is defined as <code class="docutils literal notranslate"><span class="pre">public</span></code>, the default initializer is considered internal. If you want a public type to be initializable with a no-argument initializer when used in another module, you must explicitly provide a public no-argument initializer yourself as part of the type’s definition.</p>
</div>
<div class="section" id="ID21">
<h3>Default Memberwise Initializers for Structure Types<a class="headerlink" href="AccessControl.html#ID21" title="Permalink to this headline">¶</a></h3>
<p>The default memberwise initializer for a structure type is considered private if any of the structure’s stored properties are private. Likewise, if any of the structure’s stored properties are file private, the initializer is file private. Otherwise, the initializer has an access level of internal.</p>
<p>As with the default initializer above, if you want a public structure type to be initializable with a memberwise initializer when used in another module, you must provide a public memberwise initializer yourself as part of the type’s definition.</p>
</div>
</div>
<div class="section" id="ID22">
<h2>Protocols<a class="headerlink" href="AccessControl.html#ID22" title="Permalink to this headline">¶</a></h2>
<p>If you want to assign an explicit access level to a protocol type, do so at the point that you define the protocol. This enables you to create protocols that can only be adopted within a certain access context.</p>
<p>The access level of each requirement within a protocol definition is automatically set to the same access level as the protocol. You can’t set a protocol requirement to a different access level than the protocol it supports. This ensures that all of the protocol’s requirements will be visible on any type that adopts the protocol.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you define a public protocol, the protocol’s requirements require a public access level for those requirements when they’re implemented. This behavior is different from other types, where a public type definition implies an access level of internal for the type’s members.</p>
</div>
<div class="section" id="ID23">
<h3>Protocol Inheritance<a class="headerlink" href="AccessControl.html#ID23" title="Permalink to this headline">¶</a></h3>
<p>If you define a new protocol that inherits from an existing protocol, the new protocol can have at most the same access level as the protocol it inherits from. You can’t write a public protocol that inherits from an internal protocol, for example.</p>
</div>
<div class="section" id="ID24">
<h3>Protocol Conformance<a class="headerlink" href="AccessControl.html#ID24" title="Permalink to this headline">¶</a></h3>
<p>A type can conform to a protocol with a lower access level than the type itself. For example, you can define a public type that can be used in other modules, but whose conformance to an internal protocol can only be used within the internal protocol’s defining module.</p>
<p>The context in which a type conforms to a particular protocol is the minimum of the type’s access level and the protocol’s access level. If a type is public, but a protocol it conforms to is internal, the type’s conformance to that protocol is also internal.</p>
<p>When you write or extend a type to conform to a protocol, you must ensure that the type’s implementation of each protocol requirement has at least the same access level as the type’s conformance to that protocol. For example, if a public type conforms to an internal protocol, the type’s implementation of each protocol requirement must be at least “internal”.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Swift, as in Objective-C, protocol conformance is global—it isn’t possible for a type to conform to a protocol in two different ways within the same program.</p>
</div>
</div>
</div>
<div class="section" id="ID25">
<h2>Extensions<a class="headerlink" href="AccessControl.html#ID25" title="Permalink to this headline">¶</a></h2>
<p>You can extend a class, structure, or enumeration in any access context in which the class, structure, or enumeration is available. Any type members added in an extension have the same default access level as type members declared in the original type being extended. If you extend a public or internal type, any new type members you add have a default access level of internal. If you extend a file-private type, any new type members you add have a default access level of file private. If you extend a private type, any new type members you add have a default access level of private.</p>
<p>Alternatively, you can mark an extension with an explicit access-level modifier (for example, <code class="docutils literal notranslate"><span class="pre">private</span> <span class="pre">extension</span></code>) to set a new default access level for all members defined within the extension. This new default can still be overridden within the extension for individual type members.</p>
<p>You can’t provide an explicit access-level modifier for an extension if you’re using that extension to add protocol conformance. Instead, the protocol’s own access level is used to provide the default access level for each protocol requirement implementation within the extension.</p>
<div class="section" id="ID559">
<h3>Private Members in Extensions<a class="headerlink" href="AccessControl.html#ID559" title="Permalink to this headline">¶</a></h3>
<p>Extensions that are in the same file as the class, structure, or enumeration that they extend behave as if the code in the extension had been written as part of the original type’s declaration. As a result, you can:</p>
<ul class="simple">
<li>Declare a private member in the original declaration, and access that member from extensions in the same file.</li>
<li>Declare a private member in one extension, and access that member from another extension in the same file.</li>
<li>Declare a private member in an extension, and access that member from the original declaration in the same file.</li>
</ul>
<p>This behavior means you can use extensions in the same way to organize your code, whether or not your types have private entities. For example, given the following simple protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li><li> <span class="k">func</span> <span class="nv">doSomething</span>()
</li><li>}
</li></ol></div></div></div>
<p>You can use an extension to add protocol conformance, like this:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">SomeStruct</span> {
</li><li> <span class="k">private</span> <span class="k">var</span> <span class="nv">privateVariable</span> = <span class="m">12</span>
</li><li>}
</li><li>
</li><li><span class="k">extension</span> <span class="nc">SomeStruct</span>: <span class="nc">SomeProtocol</span> {
</li><li> <span class="k">func</span> <span class="nv">doSomething</span>() {
</li><li> <span class="nv">print</span>(<span class="nv">privateVariable</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID26">
<h2>Generics<a class="headerlink" href="AccessControl.html#ID26" title="Permalink to this headline">¶</a></h2>
<p>The access level for a generic type or generic function is the minimum of the access level of the generic type or function itself and the access level of any type constraints on its type parameters.</p>
</div>
<div class="section" id="ID27">
<h2>Type Aliases<a class="headerlink" href="AccessControl.html#ID27" title="Permalink to this headline">¶</a></h2>
<p>Any type aliases you define are treated as distinct types for the purposes of access control. A type alias can have an access level less than or equal to the access level of the type it aliases. For example, a private type alias can alias a private, file-private, internal, public, or open type, but a public type alias can’t alias an internal, file-private, or private type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This rule also applies to type aliases for associated types used to satisfy protocol conformances.</p>
</div>
</div>
</div><div class="section" id="advanced-operators">
<h1>Advanced Operators<a class="headerlink" href="AdvancedOperators.html#advanced-operators" title="Permalink to this headline">¶</a></h1>
<p>In addition to the operators described in <a class="reference internal" href="BasicOperators.html"><span class="doc">Basic Operators</span></a>, Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.</p>
<p>Unlike arithmetic operators in C, arithmetic operators in Swift do not overflow by default. Overflow behavior is trapped and reported as an error. To opt in to overflow behavior, use Swift’s second set of arithmetic operators that overflow by default, such as the overflow addition operator (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>). All of these overflow operators begin with an ampersand (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>).</p>
<p>When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types. Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create.</p>
<p>You’re not limited to the predefined operators. Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values. These operators can be used and adopted in your code like any of the predefined operators, and you can even extend existing types to support the custom operators you define.</p>
<div class="section" id="ID29">
<h2>Bitwise Operators<a class="headerlink" href="AdvancedOperators.html#ID29" title="Permalink to this headline">¶</a></h2>
<p><em>Bitwise operators</em> enable you to manipulate the individual raw data bits within a data structure. They are often used in low-level programming, such as graphics programming and device driver creation. Bitwise operators can also be useful when you work with raw data from external sources, such as encoding and decoding data for communication over a custom protocol.</p>
<p>Swift supports all of the bitwise operators found in C, as described below.</p>
<div class="section" id="ID30">
<h3>Bitwise NOT Operator<a class="headerlink" href="AdvancedOperators.html#ID30" title="Permalink to this headline">¶</a></h3>
<p>The <em>bitwise NOT operator</em> (<code class="docutils literal notranslate"><span class="pre">~</span></code>) inverts all bits in a number:</p>
<img alt="../_images/bitwiseNOT_2x.png" class="align-center" src="../_images/bitwiseNOT_2x.png" style="width: 447px;"/>
<p>The bitwise NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">initialBits</span>: <span class="nc">UInt8</span> = <span class="m">0b00001111</span>
</li><li><span class="k">let</span> <span class="nv">invertedBits</span> = ~<span class="nv">initialBits</span> <span class="c">// equals 11110000</span>
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">UInt8</span></code> integers have eight bits and can store any value between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">255</span></code>. This example initializes a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> integer with the binary value <code class="docutils literal notranslate"><span class="pre">00001111</span></code>, which has its first four bits set to <code class="docutils literal notranslate"><span class="pre">0</span></code>, and its second four bits set to <code class="docutils literal notranslate"><span class="pre">1</span></code>. This is equivalent to a decimal value of <code class="docutils literal notranslate"><span class="pre">15</span></code>.</p>
<p>The bitwise NOT operator is then used to create a new constant called <code class="docutils literal notranslate"><span class="pre">invertedBits</span></code>, which is equal to <code class="docutils literal notranslate"><span class="pre">initialBits</span></code>, but with all of the bits inverted. Zeros become ones, and ones become zeros. The value of <code class="docutils literal notranslate"><span class="pre">invertedBits</span></code> is <code class="docutils literal notranslate"><span class="pre">11110000</span></code>, which is equal to an unsigned decimal value of <code class="docutils literal notranslate"><span class="pre">240</span></code>.</p>
</div>
<div class="section" id="ID31">
<h3>Bitwise AND Operator<a class="headerlink" href="AdvancedOperators.html#ID31" title="Permalink to this headline">¶</a></h3>
<p>The <em>bitwise AND operator</em> (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) combines the bits of two numbers. It returns a new number whose bits are set to <code class="docutils literal notranslate"><span class="pre">1</span></code> only if the bits were equal to <code class="docutils literal notranslate"><span class="pre">1</span></code> in <em>both</em> input numbers:</p>
<img alt="../_images/bitwiseAND_2x.png" class="align-center" src="../_images/bitwiseAND_2x.png" style="width: 447px;"/>
<p>In the example below, the values of <code class="docutils literal notranslate"><span class="pre">firstSixBits</span></code> and <code class="docutils literal notranslate"><span class="pre">lastSixBits</span></code> both have four middle bits equal to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The bitwise AND operator combines them to make the number <code class="docutils literal notranslate"><span class="pre">00111100</span></code>, which is equal to an unsigned decimal value of <code class="docutils literal notranslate"><span class="pre">60</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">firstSixBits</span>: <span class="nc">UInt8</span> = <span class="m">0b11111100</span>
</li><li><span class="k">let</span> <span class="nv">lastSixBits</span>: <span class="nc">UInt8</span>  = <span class="m">0b00111111</span>
</li><li><span class="k">let</span> <span class="nv">middleFourBits</span> = <span class="nv">firstSixBits</span> &amp; <span class="nv">lastSixBits</span> <span class="c">// equals 00111100</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID32">
<h3>Bitwise OR Operator<a class="headerlink" href="AdvancedOperators.html#ID32" title="Permalink to this headline">¶</a></h3>
<p>The <em>bitwise OR operator</em> (<code class="docutils literal notranslate"><span class="pre">|</span></code>) compares the bits of two numbers. The operator returns a new number whose bits are set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the bits are equal to <code class="docutils literal notranslate"><span class="pre">1</span></code> in <em>either</em> input number:</p>
<img alt="../_images/bitwiseOR_2x.png" class="align-center" src="../_images/bitwiseOR_2x.png" style="width: 447px;"/>
<p>In the example below, the values of <code class="docutils literal notranslate"><span class="pre">someBits</span></code> and <code class="docutils literal notranslate"><span class="pre">moreBits</span></code> have different bits set to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The bitwise OR operator combines them to make the number <code class="docutils literal notranslate"><span class="pre">11111110</span></code>, which equals an unsigned decimal of <code class="docutils literal notranslate"><span class="pre">254</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someBits</span>: <span class="nc">UInt8</span> = <span class="m">0b10110010</span>
</li><li><span class="k">let</span> <span class="nv">moreBits</span>: <span class="nc">UInt8</span> = <span class="m">0b01011110</span>
</li><li><span class="k">let</span> <span class="nv">combinedbits</span> = <span class="nv">someBits</span> | <span class="nv">moreBits</span> <span class="c">// equals 11111110</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID33">
<h3>Bitwise XOR Operator<a class="headerlink" href="AdvancedOperators.html#ID33" title="Permalink to this headline">¶</a></h3>
<p>The <em>bitwise XOR operator</em>, or “exclusive OR operator” (<code class="docutils literal notranslate"><span class="pre">^</span></code>), compares the bits of two numbers. The operator returns a new number whose bits are set to <code class="docutils literal notranslate"><span class="pre">1</span></code> where the input bits are different and are set to <code class="docutils literal notranslate"><span class="pre">0</span></code> where the input bits are the same:</p>
<img alt="../_images/bitwiseXOR_2x.png" class="align-center" src="../_images/bitwiseXOR_2x.png" style="width: 447px;"/>
<p>In the example below, the values of <code class="docutils literal notranslate"><span class="pre">firstBits</span></code> and <code class="docutils literal notranslate"><span class="pre">otherBits</span></code> each have a bit set to <code class="docutils literal notranslate"><span class="pre">1</span></code> in a location that the other does not. The bitwise XOR operator sets both of these bits to <code class="docutils literal notranslate"><span class="pre">1</span></code> in its output value. All of the other bits in <code class="docutils literal notranslate"><span class="pre">firstBits</span></code> and <code class="docutils literal notranslate"><span class="pre">otherBits</span></code> match and are set to <code class="docutils literal notranslate"><span class="pre">0</span></code> in the output value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">firstBits</span>: <span class="nc">UInt8</span> = <span class="m">0b00010100</span>
</li><li><span class="k">let</span> <span class="nv">otherBits</span>: <span class="nc">UInt8</span> = <span class="m">0b00000101</span>
</li><li><span class="k">let</span> <span class="nv">outputBits</span> = <span class="nv">firstBits</span> ^ <span class="nv">otherBits</span> <span class="c">// equals 00010001</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID34">
<h3>Bitwise Left and Right Shift Operators<a class="headerlink" href="AdvancedOperators.html#ID34" title="Permalink to this headline">¶</a></h3>
<p>The <em>bitwise left shift operator</em> (<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>) and <em>bitwise right shift operator</em> (<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>) move all bits in a number to the left or the right by a certain number of places, according to the rules defined below.</p>
<p>Bitwise left and right shifts have the effect of multiplying or dividing an integer by a factor of two. Shifting an integer’s bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value.</p>
<div class="section" id="ID35">
<h4>Shifting Behavior for Unsigned Integers<a class="headerlink" href="AdvancedOperators.html#ID35" title="Permalink to this headline">¶</a></h4>
<p>The bit-shifting behavior for unsigned integers is as follows:</p>
<ol class="arabic simple">
<li>Existing bits are moved to the left or right by the requested number of places.</li>
<li>Any bits that are moved beyond the bounds of the integer’s storage are discarded.</li>
<li>Zeros are inserted in the spaces left behind after the original bits are moved to the left or right.</li>
</ol>
<p>This approach is known as a <em>logical shift</em>.</p>
<p>The illustration below shows the results of <code class="docutils literal notranslate"><span class="pre">11111111</span> <span class="pre">&lt;&lt;</span> <span class="pre">1</span></code> (which is <code class="docutils literal notranslate"><span class="pre">11111111</span></code> shifted to the left by <code class="docutils literal notranslate"><span class="pre">1</span></code> place), and <code class="docutils literal notranslate"><span class="pre">11111111</span> <span class="pre">&gt;&gt;</span> <span class="pre">1</span></code> (which is <code class="docutils literal notranslate"><span class="pre">11111111</span></code> shifted to the right by <code class="docutils literal notranslate"><span class="pre">1</span></code> place). Blue numbers are shifted, gray numbers are discarded, and orange zeros are inserted:</p>
<img alt="../_images/bitshiftUnsigned_2x.png" class="align-center" src="../_images/bitshiftUnsigned_2x.png" style="width: 649px;"/>
<p>Here’s how bit shifting looks in Swift code:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">shiftBits</span>: <span class="nc">UInt8</span> = <span class="m">4</span> <span class="c">// 00000100 in binary</span>
</li><li><span class="nv">shiftBits</span> &lt;&lt; <span class="m">1</span> <span class="c">// 00001000</span>
</li><li><span class="nv">shiftBits</span> &lt;&lt; <span class="m">2</span> <span class="c">// 00010000</span>
</li><li><span class="nv">shiftBits</span> &lt;&lt; <span class="m">5</span> <span class="c">// 10000000</span>
</li><li><span class="nv">shiftBits</span> &lt;&lt; <span class="m">6</span> <span class="c">// 00000000</span>
</li><li><span class="nv">shiftBits</span> &gt;&gt; <span class="m">2</span> <span class="c">// 00000001</span>
</li></ol></div></div></div>
<p>You can use bit shifting to encode and decode values within other data types:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">pink</span>: <span class="nc">UInt32</span> = <span class="m">0xCC6699</span>
</li><li><span class="k">let</span> <span class="nv">redComponent</span> = (<span class="nv">pink</span> &amp; <span class="m">0xFF0000</span>) &gt;&gt; <span class="m">16</span> <span class="c">// redComponent is 0xCC, or 204</span>
</li><li><span class="k">let</span> <span class="nv">greenComponent</span> = (<span class="nv">pink</span> &amp; <span class="m">0x00FF00</span>) &gt;&gt; <span class="m">8</span> <span class="c">// greenComponent is 0x66, or 102</span>
</li><li><span class="k">let</span> <span class="nv">blueComponent</span> = <span class="nv">pink</span> &amp; <span class="m">0x0000FF</span> <span class="c">// blueComponent is 0x99, or 153</span>
</li></ol></div></div></div>
<p>This example uses a <code class="docutils literal notranslate"><span class="pre">UInt32</span></code> constant called <code class="docutils literal notranslate"><span class="pre">pink</span></code> to store a Cascading Style Sheets color value for the color pink. The CSS color value <code class="docutils literal notranslate"><span class="pre">#CC6699</span></code> is written as <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> in Swift’s hexadecimal number representation. This color is then decomposed into its red (<code class="docutils literal notranslate"><span class="pre">CC</span></code>), green (<code class="docutils literal notranslate"><span class="pre">66</span></code>), and blue (<code class="docutils literal notranslate"><span class="pre">99</span></code>) components by the bitwise AND operator (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) and the bitwise right shift operator (<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>).</p>
<p>The red component is obtained by performing a bitwise AND between the numbers <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> and <code class="docutils literal notranslate"><span class="pre">0xFF0000</span></code>. The zeros in <code class="docutils literal notranslate"><span class="pre">0xFF0000</span></code> effectively “mask” the second and third bytes of <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code>, causing the <code class="docutils literal notranslate"><span class="pre">6699</span></code> to be ignored and leaving <code class="docutils literal notranslate"><span class="pre">0xCC0000</span></code> as the result.</p>
<p>This number is then shifted 16 places to the right (<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span> <span class="pre">16</span></code>). Each pair of characters in a hexadecimal number uses 8 bits, so a move 16 places to the right will convert <code class="docutils literal notranslate"><span class="pre">0xCC0000</span></code> into <code class="docutils literal notranslate"><span class="pre">0x0000CC</span></code>. This is the same as <code class="docutils literal notranslate"><span class="pre">0xCC</span></code>, which has a decimal value of <code class="docutils literal notranslate"><span class="pre">204</span></code>.</p>
<p>Similarly, the green component is obtained by performing a bitwise AND between the numbers <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> and <code class="docutils literal notranslate"><span class="pre">0x00FF00</span></code>, which gives an output value of <code class="docutils literal notranslate"><span class="pre">0x006600</span></code>. This output value is then shifted eight places to the right, giving a value of <code class="docutils literal notranslate"><span class="pre">0x66</span></code>, which has a decimal value of <code class="docutils literal notranslate"><span class="pre">102</span></code>.</p>
<p>Finally, the blue component is obtained by performing a bitwise AND between the numbers <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> and <code class="docutils literal notranslate"><span class="pre">0x0000FF</span></code>, which gives an output value of <code class="docutils literal notranslate"><span class="pre">0x000099</span></code>. There’s no need to shift this to the right, as <code class="docutils literal notranslate"><span class="pre">0x000099</span></code> already equals <code class="docutils literal notranslate"><span class="pre">0x99</span></code>, which has a decimal value of <code class="docutils literal notranslate"><span class="pre">153</span></code>.</p>
</div>
<div class="section" id="ID36">
<h4>Shifting Behavior for Signed Integers<a class="headerlink" href="AdvancedOperators.html#ID36" title="Permalink to this headline">¶</a></h4>
<p>The shifting behavior is more complex for signed integers than for unsigned integers, because of the way signed integers are represented in binary. (The examples below are based on 8-bit signed integers for simplicity, but the same principles apply for signed integers of any size.)</p>
<p>Signed integers use their first bit (known as the <em>sign bit</em>) to indicate whether the integer is positive or negative. A sign bit of <code class="docutils literal notranslate"><span class="pre">0</span></code> means positive, and a sign bit of <code class="docutils literal notranslate"><span class="pre">1</span></code> means negative.</p>
<p>The remaining bits (known as the <em>value bits</em>) store the actual value. Positive numbers are stored in exactly the same way as for unsigned integers, counting upwards from <code class="docutils literal notranslate"><span class="pre">0</span></code>. Here’s how the bits inside an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> look for the number <code class="docutils literal notranslate"><span class="pre">4</span></code>:</p>
<img alt="../_images/bitshiftSignedFour_2x.png" class="align-center" src="../_images/bitshiftSignedFour_2x.png" style="width: 396px;"/>
<p>The sign bit is <code class="docutils literal notranslate"><span class="pre">0</span></code> (meaning “positive”), and the seven value bits are just the number <code class="docutils literal notranslate"><span class="pre">4</span></code>, written in binary notation.</p>
<p>Negative numbers, however, are stored differently. They are stored by subtracting their absolute value from <code class="docutils literal notranslate"><span class="pre">2</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">n</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of value bits. An eight-bit number has seven value bits, so this means <code class="docutils literal notranslate"><span class="pre">2</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">7</span></code>, or <code class="docutils literal notranslate"><span class="pre">128</span></code>.</p>
<p>Here’s how the bits inside an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> look for the number <code class="docutils literal notranslate"><span class="pre">-4</span></code>:</p>
<img alt="../_images/bitshiftSignedMinusFour_2x.png" class="align-center" src="../_images/bitshiftSignedMinusFour_2x.png" style="width: 396px;"/>
<p>This time, the sign bit is <code class="docutils literal notranslate"><span class="pre">1</span></code> (meaning “negative”), and the seven value bits have a binary value of <code class="docutils literal notranslate"><span class="pre">124</span></code> (which is <code class="docutils literal notranslate"><span class="pre">128</span> <span class="pre">-</span> <span class="pre">4</span></code>):</p>
<img alt="../_images/bitshiftSignedMinusFourValue_2x.png" class="align-center" src="../_images/bitshiftSignedMinusFourValue_2x.png" style="width: 393px;"/>
<p>This encoding for negative numbers is known as a <em>two’s complement</em> representation. It may seem an unusual way to represent negative numbers, but it has several advantages.</p>
<p>First, you can add <code class="docutils literal notranslate"><span class="pre">-1</span></code> to <code class="docutils literal notranslate"><span class="pre">-4</span></code>, simply by performing a standard binary addition of all eight bits (including the sign bit), and discarding anything that doesn’t fit in the eight bits once you’re done:</p>
<img alt="../_images/bitshiftSignedAddition_2x.png" class="align-center" src="../_images/bitshiftSignedAddition_2x.png" style="width: 446px;"/>
<p>Second, the two’s complement representation also lets you shift the bits of negative numbers to the left and right like positive numbers, and still end up doubling them for every shift you make to the left, or halving them for every shift you make to the right. To achieve this, an extra rule is used when signed integers are shifted to the right: When you shift signed integers to the right, apply the same rules as for unsigned integers, but fill any empty bits on the left with the <em>sign bit</em>, rather than with a zero.</p>
<img alt="../_images/bitshiftSigned_2x.png" class="align-center" src="../_images/bitshiftSigned_2x.png" style="width: 649px;"/>
<p>This action ensures that signed integers have the same sign after they are shifted to the right, and is known as an <em>arithmetic shift</em>.</p>
<p>Because of the special way that positive and negative numbers are stored, shifting either of them to the right moves them closer to zero. Keeping the sign bit the same during this shift means that negative integers remain negative as their value moves closer to zero.</p>
</div>
</div>
</div>
<div class="section" id="ID37">
<h2>Overflow Operators<a class="headerlink" href="AdvancedOperators.html#ID37" title="Permalink to this headline">¶</a></h2>
<p>If you try to insert a number into an integer constant or variable that cannot hold that value, by default Swift reports an error rather than allowing an invalid value to be created. This behavior gives extra safety when you work with numbers that are too large or too small.</p>
<p>For example, the <code class="docutils literal notranslate"><span class="pre">Int16</span></code> integer type can hold any signed integer between <code class="docutils literal notranslate"><span class="pre">-32768</span></code> and <code class="docutils literal notranslate"><span class="pre">32767</span></code>. Trying to set an <code class="docutils literal notranslate"><span class="pre">Int16</span></code> constant or variable to a number outside of this range causes an error:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">potentialOverflow</span> = <span class="nv">Int16</span>.<span class="nv">max</span>
</li><li><span class="c">// potentialOverflow equals 32767, which is the maximum value an Int16 can hold</span>
</li><li><span class="nv">potentialOverflow</span> += <span class="m">1</span>
</li><li><span class="c">// this causes an error</span>
</li></ol></div></div></div>
<p>Providing error handling when values get too large or too small gives you much more flexibility when coding for boundary value conditions.</p>
<p>However, when you specifically want an overflow condition to truncate the number of available bits, you can opt in to this behavior rather than triggering an error. Swift provides three arithmetic <em>overflow operators</em> that opt in to the overflow behavior for integer calculations. These operators all begin with an ampersand (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>):</p>
<ul class="simple">
<li>Overflow addition (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>)</li>
<li>Overflow subtraction (<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>)</li>
<li>Overflow multiplication (<code class="docutils literal notranslate"><span class="pre">&amp;*</span></code>)</li>
</ul>
<div class="section" id="ID38">
<h3>Value Overflow<a class="headerlink" href="AdvancedOperators.html#ID38" title="Permalink to this headline">¶</a></h3>
<p>Numbers can overflow in both the positive and negative direction.</p>
<p>Here’s an example of what happens when an unsigned integer is allowed to overflow in the positive direction, using the overflow addition operator (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">unsignedOverflow</span> = <span class="nv">UInt8</span>.<span class="nv">max</span>
</li><li><span class="c">// unsignedOverflow equals 255, which is the maximum value a UInt8 can hold</span>
</li><li><span class="nv">unsignedOverflow</span> = <span class="nv">unsignedOverflow</span> &amp;+ <span class="m">1</span>
</li><li><span class="c">// unsignedOverflow is now equal to 0</span>
</li></ol></div></div></div>
<p>The variable <code class="docutils literal notranslate"><span class="pre">unsignedOverflow</span></code> is initialized with the maximum value a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> can hold (<code class="docutils literal notranslate"><span class="pre">255</span></code>, or <code class="docutils literal notranslate"><span class="pre">11111111</span></code> in binary). It is then incremented by <code class="docutils literal notranslate"><span class="pre">1</span></code> using the overflow addition operator (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>). This pushes its binary representation just over the size that a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> can hold, causing it to overflow beyond its bounds, as shown in the diagram below. The value that remains within the bounds of the <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> after the overflow addition is <code class="docutils literal notranslate"><span class="pre">00000000</span></code>, or zero.</p>
<img alt="../_images/overflowAddition_2x.png" class="align-center" src="../_images/overflowAddition_2x.png" style="width: 486px;"/>
<p>Something similar happens when an unsigned integer is allowed to overflow in the negative direction. Here’s an example using the overflow subtraction operator (<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">unsignedOverflow</span> = <span class="nv">UInt8</span>.<span class="nv">min</span>
</li><li><span class="c">// unsignedOverflow equals 0, which is the minimum value a UInt8 can hold</span>
</li><li><span class="nv">unsignedOverflow</span> = <span class="nv">unsignedOverflow</span> &amp;- <span class="m">1</span>
</li><li><span class="c">// unsignedOverflow is now equal to 255</span>
</li></ol></div></div></div>
<p>The minimum value that a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> can hold is zero, or <code class="docutils literal notranslate"><span class="pre">00000000</span></code> in binary. If you subtract <code class="docutils literal notranslate"><span class="pre">1</span></code> from <code class="docutils literal notranslate"><span class="pre">00000000</span></code> using the overflow subtraction operator (<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>), the number will overflow and wrap around to <code class="docutils literal notranslate"><span class="pre">11111111</span></code>, or <code class="docutils literal notranslate"><span class="pre">255</span></code> in decimal.</p>
<img alt="../_images/overflowUnsignedSubtraction_2x.png" class="align-center" src="../_images/overflowUnsignedSubtraction_2x.png" style="width: 486px;"/>
<p>Overflow also occurs for signed integers. All addition and subtraction for signed integers is performed in bitwise fashion, with the sign bit included as part of the numbers being added or subtracted, as described in <a class="reference internal" href="AdvancedOperators.html#ID34"><span class="std std-ref">Bitwise Left and Right Shift Operators</span></a>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">signedOverflow</span> = <span class="nv">Int8</span>.<span class="nv">min</span>
</li><li><span class="c">// signedOverflow equals -128, which is the minimum value an Int8 can hold</span>
</li><li><span class="nv">signedOverflow</span> = <span class="nv">signedOverflow</span> &amp;- <span class="m">1</span>
</li><li><span class="c">// signedOverflow is now equal to 127</span>
</li></ol></div></div></div>
<p>The minimum value that an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> can hold is <code class="docutils literal notranslate"><span class="pre">-128</span></code>, or <code class="docutils literal notranslate"><span class="pre">10000000</span></code> in binary. Subtracting <code class="docutils literal notranslate"><span class="pre">1</span></code> from this binary number with the overflow operator gives a binary value of <code class="docutils literal notranslate"><span class="pre">01111111</span></code>, which toggles the sign bit and gives positive <code class="docutils literal notranslate"><span class="pre">127</span></code>, the maximum positive value that an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> can hold.</p>
<img alt="../_images/overflowSignedSubtraction_2x.png" class="align-center" src="../_images/overflowSignedSubtraction_2x.png" style="width: 486px;"/>
<p>For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum.</p>
</div>
</div>
<div class="section" id="ID41">
<h2>Precedence and Associativity<a class="headerlink" href="AdvancedOperators.html#ID41" title="Permalink to this headline">¶</a></h2>
<p>Operator <em>precedence</em> gives some operators higher priority than others; these operators are applied first.</p>
<p>Operator <em>associativity</em> defines how operators of the same precedence are grouped together—either grouped from the left, or grouped from the right. Think of it as meaning “they associate with the expression to their left,” or “they associate with the expression to their right.”</p>
<p>It is important to consider each operator’s precedence and associativity when working out the order in which a compound expression will be calculated. For example, operator precedence explains why the following expression equals <code class="docutils literal notranslate"><span class="pre">17</span></code>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">2</span> + <span class="m">3</span> % <span class="m">4</span> * <span class="m">5</span>
</li><li><span class="c">// this equals 17</span>
</li></ol></div></div></div>
<p>If you read strictly from left to right, you might expect the expression to be calculated as follows:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">2</span></code> plus <code class="docutils literal notranslate"><span class="pre">3</span></code> equals <code class="docutils literal notranslate"><span class="pre">5</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">5</span></code> remainder <code class="docutils literal notranslate"><span class="pre">4</span></code> equals <code class="docutils literal notranslate"><span class="pre">1</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">1</span></code> times <code class="docutils literal notranslate"><span class="pre">5</span></code> equals <code class="docutils literal notranslate"><span class="pre">5</span></code></li>
</ul>
<p>However, the actual answer is <code class="docutils literal notranslate"><span class="pre">17</span></code>, not <code class="docutils literal notranslate"><span class="pre">5</span></code>. Higher-precedence operators are evaluated before lower-precedence ones. In Swift, as in C, the remainder operator (<code class="docutils literal notranslate"><span class="pre">%</span></code>) and the multiplication operator (<code class="docutils literal notranslate"><span class="pre">*</span></code>) have a higher precedence than the addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>). As a result, they are both evaluated before the addition is considered.</p>
<p>However, remainder and multiplication have the <em>same</em> precedence as each other. To work out the exact evaluation order to use, you also need to consider their associativity. Remainder and multiplication both associate with the expression to their left. Think of this as adding implicit parentheses around these parts of the expression, starting from their left:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">2</span> + ((<span class="m">3</span> % <span class="m">4</span>) * <span class="m">5</span>)
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">%</span> <span class="pre">4)</span></code> is <code class="docutils literal notranslate"><span class="pre">3</span></code>, so this is equivalent to:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">2</span> + (<span class="m">3</span> * <span class="m">5</span>)
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">*</span> <span class="pre">5)</span></code> is <code class="docutils literal notranslate"><span class="pre">15</span></code>, so this is equivalent to:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">2</span> + <span class="m">15</span>
</li></ol></div></div></div>
<p>This calculation yields the final answer of <code class="docutils literal notranslate"><span class="pre">17</span></code>.</p>
<p>For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see <a class="reference external" href="https://developer.apple.com/documentation/swift/operator_declarations">Operator Declarations</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Swift’s operator precedences and associativity rules are simpler and more predictable than those found in C and Objective-C. However, this means that they are not exactly the same as in C-based languages. Be careful to ensure that operator interactions still behave in the way you intend when porting existing code to Swift.</p>
</div>
</div>
<div class="section" id="ID42">
<h2>Operator Methods<a class="headerlink" href="AdvancedOperators.html#ID42" title="Permalink to this headline">¶</a></h2>
<p>Classes and structures can provide their own implementations of existing operators. This is known as <em>overloading</em> the existing operators.</p>
<p>The example below shows how to implement the arithmetic addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) for a custom structure. The arithmetic addition operator is a <em>binary operator</em> because it operates on two targets and is said to be <em>infix</em> because it appears in between those two targets.</p>
<p>The example defines a <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> structure for a two-dimensional position vector <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>, followed by a definition of an <em>operator method</em> to add together instances of the <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> structure:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Vector2D</span> {
</li><li> <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>}
</li><li>
</li><li><span class="k">extension</span> <span class="nc">Vector2D</span> {
</li><li> <span class="k">static</span> <span class="k">func</span> + (<span class="nv">left</span>: <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li><li> <span class="k">return</span> <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="nv">left</span>.<span class="nv">x</span> + <span class="nv">right</span>.<span class="nv">x</span>, <span class="nv">y</span>: <span class="nv">left</span>.<span class="nv">y</span> + <span class="nv">right</span>.<span class="nv">y</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The operator method is defined as a type method on <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>, with a method name that matches the operator to be overloaded (<code class="docutils literal notranslate"><span class="pre">+</span></code>). Because addition isn’t part of the essential behavior for a vector, the type method is defined in an extension of <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> rather than in the main structure declaration of <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>. Because the arithmetic addition operator is a binary operator, this operator method takes two input parameters of type <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> and returns a single output value, also of type <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>.</p>
<p>In this implementation, the input parameters are named <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> to represent the <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances that will be on the left side and right side of the <code class="docutils literal notranslate"><span class="pre">+</span></code> operator. The method returns a new <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instance, whose <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> properties are initialized with the sum of the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> properties from the two <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances that are added together.</p>
<p>The type method can be used as an infix operator between existing <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">vector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">1.0</span>)
</li><li><span class="k">let</span> <span class="nv">anotherVector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li><li><span class="k">let</span> <span class="nv">combinedVector</span> = <span class="nv">vector</span> + <span class="nv">anotherVector</span>
</li><li><span class="c">// combinedVector is a Vector2D instance with values of (5.0, 5.0)</span>
</li></ol></div></div></div>
<p>This example adds together the vectors <code class="docutils literal notranslate"><span class="pre">(3.0,</span> <span class="pre">1.0)</span></code> and <code class="docutils literal notranslate"><span class="pre">(2.0,</span> <span class="pre">4.0)</span></code> to make the vector <code class="docutils literal notranslate"><span class="pre">(5.0,</span> <span class="pre">5.0)</span></code>, as illustrated below.</p>
<img alt="../_images/vectorAddition_2x.png" class="align-center" src="../_images/vectorAddition_2x.png" style="width: 387px;"/>
<div class="section" id="ID43">
<h3>Prefix and Postfix Operators<a class="headerlink" href="AdvancedOperators.html#ID43" title="Permalink to this headline">¶</a></h3>
<p>The example shown above demonstrates a custom implementation of a binary infix operator. Classes and structures can also provide implementations of the standard <em>unary operators</em>. Unary operators operate on a single target. They are <em>prefix</em> if they precede their target (such as <code class="docutils literal notranslate"><span class="pre">-a</span></code>) and <em>postfix</em> operators if they follow their target (such as <code class="docutils literal notranslate"><span class="pre">b!</span></code>).</p>
<p>You implement a prefix or postfix unary operator by writing the <code class="docutils literal notranslate"><span class="pre">prefix</span></code> or <code class="docutils literal notranslate"><span class="pre">postfix</span></code> modifier before the <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword when declaring the operator method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Vector2D</span> {
</li><li> <span class="k">static</span> <span class="k">prefix</span> <span class="k">func</span> - (<span class="nv">vector</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li><li> <span class="k">return</span> <span class="nv">Vector2D</span>(<span class="nv">x</span>: -<span class="nv">vector</span>.<span class="nv">x</span>, <span class="nv">y</span>: -<span class="nv">vector</span>.<span class="nv">y</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The example above implements the unary minus operator (<code class="docutils literal notranslate"><span class="pre">-a</span></code>) for <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances. The unary minus operator is a prefix operator, and so this method has to be qualified with the <code class="docutils literal notranslate"><span class="pre">prefix</span></code> modifier.</p>
<p>For simple numeric values, the unary minus operator converts positive numbers into their negative equivalent and vice versa. The corresponding implementation for <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances performs this operation on both the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">positive</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li><li><span class="k">let</span> <span class="nv">negative</span> = -<span class="nv">positive</span>
</li><li><span class="c">// negative is a Vector2D instance with values of (-3.0, -4.0)</span>
</li><li><span class="k">let</span> <span class="nv">alsoPositive</span> = -<span class="nv">negative</span>
</li><li><span class="c">// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID44">
<h3>Compound Assignment Operators<a class="headerlink" href="AdvancedOperators.html#ID44" title="Permalink to this headline">¶</a></h3>
<p><em>Compound assignment operators</em> combine assignment (<code class="docutils literal notranslate"><span class="pre">=</span></code>) with another operation. For example, the addition assignment operator (<code class="docutils literal notranslate"><span class="pre">+=</span></code>) combines addition and assignment into a single operation. You mark a compound assignment operator’s left input parameter type as <code class="docutils literal notranslate"><span class="pre">inout</span></code>, because the parameter’s value will be modified directly from within the operator method.</p>
<p>The example below implements an addition assignment operator method for <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Vector2D</span> {
</li><li> <span class="k">static</span> <span class="k">func</span> += (<span class="nv">left</span>: <span class="k">inout</span> <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) {
</li><li> <span class="nv">left</span> = <span class="nv">left</span> + <span class="nv">right</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Because an addition operator was defined earlier, you don’t need to reimplement the addition process here. Instead, the addition assignment operator method takes advantage of the existing addition operator method, and uses it to set the left value to be the left value plus the right value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">original</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>)
</li><li><span class="k">let</span> <span class="nv">vectorToAdd</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li><li><span class="nv">original</span> += <span class="nv">vectorToAdd</span>
</li><li><span class="c">// original now has values of (4.0, 6.0)</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is not possible to overload the default assignment operator (<code class="docutils literal notranslate"><span class="pre">=</span></code>). Only the compound assignment operators can be overloaded. Similarly, the ternary conditional operator (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">?</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">c</span></code>) cannot be overloaded.</p>
</div>
</div>
<div class="section" id="ID45">
<h3>Equivalence Operators<a class="headerlink" href="AdvancedOperators.html#ID45" title="Permalink to this headline">¶</a></h3>
<p>By default, custom classes and structures don’t receive a default implementation of the <em>equivalence operators</em>, known as the <em>equal to</em> operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) and <em>not equal to</em> operator (<code class="docutils literal notranslate"><span class="pre">!=</span></code>).</p>
<p>To use the equivalence operators to check for equivalence of your own custom type, provide an implementation of the “equal to” operator in the same way as for other infix operators, and add conformance to the standard library’s <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Vector2D</span>: <span class="nc">Equatable</span> {
</li><li> <span class="k">static</span> <span class="k">func</span> == (<span class="nv">left</span>: <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Bool</span> {
</li><li> <span class="k">return</span> (<span class="nv">left</span>.<span class="nv">x</span> == <span class="nv">right</span>.<span class="nv">x</span>) &amp;&amp; (<span class="nv">left</span>.<span class="nv">y</span> == <span class="nv">right</span>.<span class="nv">y</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The above example implements an “equal to” operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) to check whether two <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances have equivalent values. In the context of <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>, it makes sense to consider “equal” as meaning “both instances have the same <code class="docutils literal notranslate"><span class="pre">x</span></code> values and <code class="docutils literal notranslate"><span class="pre">y</span></code> values”, and so this is the logic used by the operator implementation. If you’ve implemented an “equal to” operator, you usually don’t need to implement a “not equal to” operator (<code class="docutils literal notranslate"><span class="pre">!=</span></code>) yourself. The standard library provides a default implementation of the “not equal to” operator, which simply negates the result of the “equal to” operator that you implemented.</p>
<p>You can now use these operators to check whether two <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances are equivalent:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">twoThree</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li><li><span class="k">let</span> <span class="nv">anotherTwoThree</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li><li><span class="k">if</span> <span class="nv">twoThree</span> == <span class="nv">anotherTwoThree</span> {
</li><li> <span class="nv">print</span>(<span class="s">"These two vectors are equivalent."</span>)
</li><li>}
</li><li><span class="c">// Prints "These two vectors are equivalent."</span>
</li></ol></div></div></div>
<p>In many simple cases, you can ask Swift to provide synthesized implementations of the equivalence operators for you. Swift provides synthesized implementations for the following kinds of custom types:</p>
<ul class="simple">
<li>Structures that have only stored properties that conform to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol</li>
<li>Enumerations that have only associated types that conform to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol</li>
<li>Enumerations that have no associated types</li>
</ul>
<p>Declare <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> conformance in the file that contains the original declaration to receive these implementations.</p>
<p>The example below defines a <code class="docutils literal notranslate"><span class="pre">Vector3D</span></code> structure for a three-dimensional position vector <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>, similar to the <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> structure. Because the <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> properties are all of an <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> type, <code class="docutils literal notranslate"><span class="pre">Vector3D</span></code> receives default implementations of the equivalence operators.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Vector3D</span>: <span class="nc">Equatable</span> {
</li><li> <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>, <span class="nv">z</span> = <span class="m">0.0</span>
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">twoThreeFour</span> = <span class="nv">Vector3D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>, <span class="nv">z</span>: <span class="m">4.0</span>)
</li><li><span class="k">let</span> <span class="nv">anotherTwoThreeFour</span> = <span class="nv">Vector3D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>, <span class="nv">z</span>: <span class="m">4.0</span>)
</li><li><span class="k">if</span> <span class="nv">twoThreeFour</span> == <span class="nv">anotherTwoThreeFour</span> {
</li><li> <span class="nv">print</span>(<span class="s">"These two vectors are also equivalent."</span>)
</li><li>}
</li><li><span class="c">// Prints "These two vectors are also equivalent."</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID46">
<h2>Custom Operators<a class="headerlink" href="AdvancedOperators.html#ID46" title="Permalink to this headline">¶</a></h2>
<p>You can declare and implement your own <em>custom operators</em> in addition to the standard operators provided by Swift. For a list of characters that can be used to define custom operators, see <a class="reference internal" href="../ReferenceManual/LexicalStructure.html#ID418"><span class="std std-ref">Operators</span></a>.</p>
<p>New operators are declared at a global level using the <code class="docutils literal notranslate"><span class="pre">operator</span></code> keyword, and are marked with the <code class="docutils literal notranslate"><span class="pre">prefix</span></code>, <code class="docutils literal notranslate"><span class="pre">infix</span></code> or <code class="docutils literal notranslate"><span class="pre">postfix</span></code> modifiers:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">prefix</span> <span class="k">operator</span> +++
</li></ol></div></div></div>
<p>The example above defines a new prefix operator called <code class="docutils literal notranslate"><span class="pre">+++</span></code>. This operator does not have an existing meaning in Swift, and so it is given its own custom meaning below in the specific context of working with <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances. For the purposes of this example, <code class="docutils literal notranslate"><span class="pre">+++</span></code> is treated as a new “prefix doubling” operator. It doubles the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> values of a <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instance, by adding the vector to itself with the addition assignment operator defined earlier. To implement the <code class="docutils literal notranslate"><span class="pre">+++</span></code> operator, you add a type method called <code class="docutils literal notranslate"><span class="pre">+++</span></code> to <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> as follows:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Vector2D</span> {
</li><li> <span class="k">static</span> <span class="k">prefix</span> <span class="k">func</span> +++ (<span class="nv">vector</span>: <span class="k">inout</span> <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li><li> <span class="nv">vector</span> += <span class="nv">vector</span>
</li><li> <span class="k">return</span> <span class="nv">vector</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">toBeDoubled</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li><li><span class="k">let</span> <span class="nv">afterDoubling</span> = +++<span class="nv">toBeDoubled</span>
</li><li><span class="c">// toBeDoubled now has values of (2.0, 8.0)</span>
</li><li><span class="c">// afterDoubling also has values of (2.0, 8.0)</span>
</li></ol></div></div></div>
<div class="section" id="ID47">
<h3>Precedence for Custom Infix Operators<a class="headerlink" href="AdvancedOperators.html#ID47" title="Permalink to this headline">¶</a></h3>
<p>Custom infix operators each belong to a precedence group. A precedence group specifies an operator’s precedence relative to other infix operators, as well as the operator’s associativity. See <a class="reference internal" href="AdvancedOperators.html#ID41"><span class="std std-ref">Precedence and Associativity</span></a> for an explanation of how these characteristics affect an infix operator’s interaction with other infix operators.</p>
<p>A custom infix operator that is not explicitly placed into a precedence group is given a default precedence group with a precedence immediately higher than the precedence of the ternary conditional operator.</p>
<p>The following example defines a new custom infix operator called <code class="docutils literal notranslate"><span class="pre">+-</span></code>, which belongs to the precedence group <code class="docutils literal notranslate"><span class="pre">AdditionPrecedence</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">infix</span> <span class="k">operator</span> +-: <span class="nv">AdditionPrecedence</span>
</li><li><span class="k">extension</span> <span class="nc">Vector2D</span> {
</li><li> <span class="k">static</span> <span class="k">func</span> +- (<span class="nv">left</span>: <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li><li> <span class="k">return</span> <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="nv">left</span>.<span class="nv">x</span> + <span class="nv">right</span>.<span class="nv">x</span>, <span class="nv">y</span>: <span class="nv">left</span>.<span class="nv">y</span> - <span class="nv">right</span>.<span class="nv">y</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">firstVector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>)
</li><li><span class="k">let</span> <span class="nv">secondVector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li><li><span class="k">let</span> <span class="nv">plusMinusVector</span> = <span class="nv">firstVector</span> +- <span class="nv">secondVector</span>
</li><li><span class="c">// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</span>
</li></ol></div></div></div>
<p>This operator adds together the <code class="docutils literal notranslate"><span class="pre">x</span></code> values of two vectors, and subtracts the <code class="docutils literal notranslate"><span class="pre">y</span></code> value of the second vector from the first. Because it is in essence an “additive” operator, it has been given the same precedence group as additive infix operators such as <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code>. For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see <a class="reference external" href="https://developer.apple.com/documentation/swift/operator_declarations">Operator Declarations</a>. For more information about precedence groups and to see the syntax for defining your own operators and precedence groups, see <a class="reference internal" href="../ReferenceManual/Declarations.html#ID380"><span class="std std-ref">Operator Declaration</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You do not specify a precedence when defining a prefix or postfix operator. However, if you apply both a prefix and a postfix operator to the same operand, the postfix operator is applied first.</p>
</div>
</div>
</div>
</div></article>
<div class="next_previous">
<p class="previous"><a href="../GuidedTour/GuidedTour.html">A Swift Tour</a></p>
<p class="next"><a href="BasicOperators.html">Basic Operators</a></p>
</div>
<div class="admonition-beta admonition">
<p class="first admonition-title">Beta Software</p>
<p>
          This documentation contains preliminary information about an API or technology in development.
          This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.
        </p>
<p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
</div>
</main>
<footer role="contentinfo">
<aside>
<a href="https://swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
<a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
</aside>
<p class="copyright">Copyright © 2018 Apple Inc. All rights reserved.</p>
<p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
<p class="privacy">
<a href="https://www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
<a href="https://www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
</p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../_static/javascripts/application.js"></script>
</body>

